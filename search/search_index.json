{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Be\u00e1gyazott oper\u00e1ci\u00f3s rendszerek \u00e9s kliens alkalmaz\u00e1sok (BORKA)","text":"<p>Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAC07 \u00e9s BMEVIAUAC14 Be\u00e1gyazott oper\u00e1ci\u00f3s rendszerek \u00e9s kliens alkalmaz\u00e1sok c. t\u00e1rgyakhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC07 \u00e9s BMEVIAUAC14 t\u00e1rgyak hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-osztaly","title":"Absztrakt oszt\u00e1ly","text":"<p>A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.:</p> <pre><code>abstract class Shape { \u2026 }\n</code></pre> <p>Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni:</p> <pre><code>\u2026\nabstract void Draw();\n\u2026\n</code></pre> <p>Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet:</p> <ul> <li>Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t.</li> <li>Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k).</li> </ul> <p>.NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz","title":"Interf\u00e9sz","text":"<p>Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt.</p> <p>C# nyelven az <code>interface</code> kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni:</p> <pre><code>public interface ISerializable {\nvoid WriteToStream(Stream s);\nvoid LoadFromStream(Stream s);\n}\n\npublic interface IComparable {\nint CompareTo(Object obj);\n}\n</code></pre> <p>M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n\u2026\n}\n</code></pre> <p>Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az <code>ISerializable</code> \u00e9s <code>IComparable</code> interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t. Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt.</p> <p>Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g:</p> <ul> <li>A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni.</li> <li>Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani). Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-os-es-interfesz-osszehasonlitasa","title":"Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa","text":"<p>Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat.</p> <p>Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet.</p> <p>Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1. Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent.</p> <p>\u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja. B\u0151vebben inform\u00e1ci\u00f3 itt:  default interface methods.</p> <p>Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).</p>"},{"location":"egyeb/uml-kod-kapcsolata/","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#bevezeto","title":"Bevezet\u0151","text":"<p>A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt.</p> <p>Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt.</p> <p>Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#fogalmak","title":"Fogalmak","text":"<ul> <li>Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni.</li> <li>Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti.</li> <li>Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban.</li> </ul> <p>Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni.</p> <p>A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#osztalyok-lekepezese","title":"Oszt\u00e1lyok lek\u00e9pez\u00e9se","text":"<p>Mondhatni trivi\u00e1lisan egyszer\u0171:</p> <ul> <li>UML oszt\u00e1ly -&gt; oszt\u00e1ly</li> <li>UML attrib\u00fatum -&gt; tagv\u00e1ltoz\u00f3</li> <li>UML m\u0171velet -&gt; m\u0171velet/met\u00f3dus</li> </ul> <p>Egy p\u00e9lda:</p> <p></p> <p>, mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven:</p> <pre><code>public abstract class Shape\n{\nprivate int x;\nprivate int y;\npublic Shape(int x, int y) { this.x = x; this.y = y; }\npublic abstract void Draw(Graphics gr);\n}\n</code></pre> <p>A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s:</p> <ul> <li>+: public</li> <li>-: private</li> <li>#: protected</li> </ul> <p>Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#i-altalanositas-specializacio-kapcsolat","title":"I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat","text":"<p>C# lek\u00e9pez\u00e9s:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#ii-asszociacio","title":"II. Asszoci\u00e1ci\u00f3","text":"<p>Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#a-lekepezes-01-multiplicitasu-asszociacios-kapcsolat-eseten","title":"A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda:</p> <p></p> <p>C++ lek\u00e9pez\u00e9s:</p> <pre><code>class Application\n{\nWindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k):</p> <pre><code>class Application\n{\nWindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role), mely a p\u00e9ld\u00e1ban a <code>windowManager</code>. A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni.</p> <p>Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#b-lekepezes-0n-multiplicitasu-asszociacios-kapcsolat-eseten","title":"B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda:</p> <p></p> <p>Egy <code>WindowManager</code> objektum t\u00f6bb <code>Window</code> objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista, stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel.</p> <p>Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven:</p> <pre><code>class WindowManager\n{\nvector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Illetve C# nyelven:</p> <pre><code>class WindowManager\n{\nList&lt;Window&gt; windows; };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#iii-aggregacio-tartalmazas-resz-egesz-viszony","title":"III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony)","text":"<p>\u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#iv-fuggoseg-dependency","title":"IV. F\u00fcgg\u0151s\u00e9g (dependency)","text":"<p>A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda:</p> <p></p> <p>A jelent\u00e9se: a <code>Window</code> oszt\u00e1ly f\u00fcgg a <code>Graphics</code> oszt\u00e1lyt\u00f3l. Vagyis, ha a <code>Graphics</code> oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a Window oszt\u00e1ly onDraw m\u0171velete param\u00e9terk\u00e9nt megkapja a Graphics oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a <code>Graphics</code> oszt\u00e1ly met\u00f3dusait. Ha pl. a <code>Graphics</code> oszt\u00e1ly <code>FillRect</code> met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a Window oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.</p>"},{"location":"gyakorlat/doc-view/","title":"Document-View architekt\u00fara","text":""},{"location":"gyakorlat/doc-view/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai:</p> <ul> <li>UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa</li> <li>A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban</li> <li>UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n</li> <li>A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (<code>Paint</code> esem\u00e9ny, <code>Invalidate</code>, <code>Graphics</code> haszn\u00e1lata)</li> </ul> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga:</p> <ul> <li>UML alap\u00fa modellez\u00e9s</li> <li>Windows Forms alkalmaz\u00e1sfejleszt\u00e9s</li> <li>Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara)</li> </ul>"},{"location":"gyakorlat/doc-view/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"gyakorlat/doc-view/#a-gyakorlat-menete","title":"A gyakorlat menete","text":"<p>Az al\u00e1bbiak szerint fogunk dolgozni:</p> <ul> <li>A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se</li> <li>A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se</li> <li>Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se)</li> <li>A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se</li> </ul> Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra <p>A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st (innen kl\u00f3nozzuk ki: https://github.com/bmeviauab00/lab-docview-megoldas). A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik a feladat bemutat\u00e1sa.</p>"},{"location":"gyakorlat/doc-view/#1-feladat-a-feladat-ismertetese","title":"1. Feladat - A feladat ismertet\u00e9se","text":"<p>Interakt\u00edv FontEditor (bet\u0171t\u00edpus szerkeszt\u0151) k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s az aktu\u00e1lis bet\u0171k\u00e9szlet alapj\u00e1n tetsz\u0151leges p\u00e9ldasz\u00f6veg megjelen\u00edthet\u0151. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben:</p> <p></p> <p>A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia:</p> <ul> <li>T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface).</li> <li>\u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t).</li> <li>Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k (File/Save), bet\u00f6lthet\u0151k (File/Open), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 (File/Close). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF).</li> <li>A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se<ul> <li>Az oldal tetej\u00e9n (Sample text) egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt.</li> <li>Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy, az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet.</li> <li>Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck.</li> </ul> </li> <li>A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se<ul> <li>Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik.</li> <li>Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3</li> <li>\u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l</li> <li>\u2019+\u2019 gomb: nagy\u00edt\u00e1s</li> <li>\u2019-\u2019 gomb: kicsiny\u00edt\u00e9s</li> </ul> </li> </ul> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s vizsg\u00e1ljuk meg a m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen n\u00e9zz\u00fck meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl.</p> <p>Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor k\u00f3dmegjegyz\u00e9sekkel el van l\u00e1tva, mely seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t.</p>"},{"location":"gyakorlat/doc-view/#2-feladat-az-alkalmazas-megtervezese","title":"2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se","text":"<p>A c\u00e9l az, hogy l\u00e1ssuk, milyen folyamatot k\u00f6vetve, milyen l\u00e9p\u00e9sekben dolgozunk, mikor milyen tervez\u0151i l\u00e9p\u00e9seket kell meghoznunk. T\u00f6rekedj\u00fcnk oktat\u00f3i \u00e9s hallgat\u00f3i r\u00e9szr\u0151l is az interaktivit\u00e1sra, k\u00f6z\u00f6sen hozzuk meg a d\u00f6nt\u00e9seket.</p> <p>Hozzunk l\u00e9tre egy \u00faj C# nyelv\u0171 \u201eWindow Form App\u201d projektet (.NET 8-ast), legyen a neve FontEditor. Vegy\u00fcnk fel egy oszt\u00e1lydiagramot: projekten jobb katt, Add / New Item, majd a megjelen\u0151 ablakban Class Diagram kiv\u00e1laszt\u00e1sa, a neve maradhat az alap\u00e9rtelmezett. \u00c1ll\u00edtsuk be, hogy a diagram mutassa majd a m\u0171veletek szignat\u00far\u00e1it is (pl. jobb katt a h\u00e1tt\u00e9ren, Change Members Format / Display Full Signature). A gyakorlat nagy r\u00e9sz\u00e9ben ezt a diagramot fogjuk szerkeszteni.</p> <p>A k\u00e9sz oszt\u00e1lydiagram a k\u00f6vetkez\u0151, eddig fogunk fokozatosan eljutni:</p> <p></p>"},{"location":"gyakorlat/doc-view/#document-view-architektura_1","title":"Document-View architekt\u00fara","text":"<p>Az els\u0151 tervez\u0151i d\u00f6nt\u00e9s: architekt\u00far\u00e1t kell v\u00e1lasztani. A Document-View eset\u00fcnkben egy\u00e9rtelm\u0171 v\u00e1laszt\u00e1s: dokumentumokkal dolgozunk, \u00e9s t\u00f6bb n\u00e9zettel, melyeket szinkronban kell tartani. Az al\u00e1bbi \u00e1bra ismerteti a m\u0171k\u00f6d\u00e9st. A n\u00e9zetek az observerek, a document pedig a subject, melynek v\u00e1ltoz\u00e1saira az egyes n\u00e9zetek fel vannak iratkozva.</p> <p></p> <p>A D-V architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g\u00fcnk lesz dokumentum oszt\u00e1lyra, amely a dokumentum adatait t\u00e1rolja (tagv\u00e1ltoz\u00f3kban), mint pl. a n\u00e9v, el\u00e9r\u00e9si \u00fat, pixelm\u00e1trix. Tegy\u00fck fel, hogy a k\u00e9s\u0151bbiekben t\u00f6bb dokumentum t\u00edpust is t\u00e1mogatni kell majd: pl. megnyithatunk egy olyan tabf\u00fclet, melyen a BKK j\u00e1rm\u0171vekhez tudjuk rendelni a bet\u0171t\u00edpusokat (elektronikus kijelz\u0151). Vannak olyan dokumentum adatok, melyek minden dokumentum t\u00edpusban megjelennek (pl. n\u00e9v, el\u00e9r\u00e9si \u00fat). Az egyes dokumentum t\u00edpusoknak a k\u00f6z\u00f6s tulajdons\u00e1gait/m\u0171veleteit c\u00e9lszer\u0171 egy <code>Document</code> \u0151soszt\u00e1lyba kiszervezni, hogy ne legyenek duplik\u00e1lva az egyes dokumentum t\u00edpusokat reprezent\u00e1l\u00f3 dokumentum oszt\u00e1lyokban.</p> <ul> <li>Vegy\u00fck fel a <code>Document</code> oszt\u00e1lyt (ez az absztrakt \u0151s).</li> <li>Vegy\u00fcnk fel bele egy <code>string Name</code> property-t (ez jelenik meg a tabf\u00fcleken).</li> </ul> <p>A Document-View architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g van egy n\u00e9zet interf\u00e9szre (egy <code>Update</code> m\u0171velettel a n\u00e9zet \u00e9rtes\u00edt\u00e9s\u00e9hez), valamint a dokumentumoknak nyilv\u00e1n kell tartaniuk egy list\u00e1ban a n\u00e9zeteiket:</p> <ul> <li>Vegy\u00fck fel az <code>IView</code> interf\u00e9szt.</li> <li>Vegy\u00fcnk fel bele egy <code>Update</code> m\u0171veletet.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel egy <code>List&lt;IView&gt; views</code> mez\u0151t (a Fields-n\u00e9l). Jobb gombbal kattintsunk a mez\u0151 nev\u00e9n a diagramon, \u00e9s a men\u00fcb\u0151l Show as collection association kiv\u00e1laszt\u00e1sa.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel a <code>void AttachView(IView view)</code> m\u0171veletet, mellyel \u00faj n\u00e9zetet lehet beregisztr\u00e1lni.</li> <li>V\u00e9g\u00fcl vegy\u00fcnk fel egy <code>void DetachView(IView view)</code>-t, mert n\u00e9zetet bez\u00e1rni is lehet.</li> </ul> <p>T\u00e1mogatnunk kell az egyes dokumentumok tartalm\u00e1nak perziszt\u00e1l\u00e1s\u00e1t (ment\u00e9s/bet\u00f6lt\u00e9s). Ezekhez vegy\u00fcnk fel a <code>Document</code> \u0151sbe a megfelel\u0151 m\u0171veleteket:</p> <ul> <li><code>Document</code>-be <code>LoadDocument(string path)</code> felv\u00e9tele.</li> <li><code>Document</code>-be <code>SaveDocument(string path)</code> felv\u00e9tele.</li> <li>Mindkett\u0151 legyen absztrakt, hiszen csak az egyes dokumentum lesz\u00e1rmazottakban tudunk implement\u00e1ci\u00f3t megadni: szelekt\u00e1ljuk ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban az Inheritence modifier legyen Abstract.</li> </ul> <p>Az egyes dokumentumoknak t\u00e1mogatniuk kell a n\u00e9zeteik friss\u00edt\u00e9s\u00e9t, ez minden dokumentum t\u00edpusra k\u00f6z\u00f6s:</p> <ul> <li>A <code>Document</code>-be vegy\u00fck fel az <code>UpdateAllViews()</code>-t (ez felel meg az Observer minta Notify m\u0171velet\u00e9nek).</li> </ul>"},{"location":"gyakorlat/doc-view/#konkret-dokumentum-es-adatai","title":"Konkr\u00e9t dokumentum \u00e9s adatai","text":"<p>Sz\u00fcks\u00e9g van egy olyan dokumentum t\u00edpusra, ami a bet\u0171t\u00edpusok szerkeszt\u00e9s\u00e9hez tartozik, amely a tagv\u00e1ltoz\u00f3iban nyilv\u00e1ntartja a sz\u00fcks\u00e9ges adatokat: legyen a neve <code>FontEditorDocument</code>.</p> <ul> <li>Vegy\u00fck fel a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Sz\u00e1rmaztassuk a <code>Document</code>-b\u0151l (Toolbox \u2013 Inheritence kapcsolat).</li> <li>Ekkor a <code>LoadDocument</code> \u00e9s <code>SaveDocument</code> m\u0171veletekre automatikusan megsz\u00fcletik az override-ol\u00f3 m\u0171velet. Ha m\u00e9gsem lenne \u00edgy<ul> <li>Jel\u00f6lj\u00fck ki az \u0151sben a k\u00e9t m\u0171veletet.</li> <li>Copy</li> <li>Jel\u00f6lj\u00fck ki a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Paste</li> <li>Jel\u00f6lj\u00fck itt ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban a Instance Modifier legyen <code>override</code>.</li> </ul> </li> </ul> <p>A dokumentumunk tagv\u00e1ltoz\u00f3kban t\u00e1rolja az adatokat. Gondoljuk \u00e1t, hogy ezt hogyan c\u00e9lszer\u0171 megval\u00f3s\u00edtani. Lehetne egy h\u00e1romdimenzi\u00f3s t\u00f6mb (karakter \u2013 x \u2013 y), de ink\u00e1bb emelj\u00fck ki egy k\u00fcl\u00f6n oszt\u00e1lyba az egy adott karakter pixeleinek t\u00e1rol\u00e1s\u00e1t/menedzsel\u00e9s\u00e9t: vezess\u00fck be a <code>CharDef</code> oszt\u00e1lyt.</p> <p>Pixel t\u00f6mb helyett</p> <p>Az\u00e9rt nem a pixelt\u00f6mb\u00f6t haszn\u00e1ljuk k\u00f6zvetlen\u00fcl, mert csak egy \u00faj oszt\u00e1ly bevezet\u00e9s\u00e9vel van lehet\u0151s\u00e9g\u00fcnk kifejezetten ide tartoz\u00f3 m\u0171veletek bevezet\u00e9s\u00e9re, vagyis az egys\u00e9gbez\u00e1r\u00e1s korrekt megval\u00f3s\u00edt\u00e1s\u00e1ra.</p> <ul> <li>Vegy\u00fck fel a <code>CharDef</code> oszt\u00e1lyt.</li> <li> <p><code>CharDef</code>-be <code>bool[,] Pixels</code> tulajdons\u00e1g felv\u00e9tele.</p> <p>t\u00f6bbdimenzo\u00f3s t\u00f6mb\u00f6k C#-ban</p> <p>A fenti p\u00e9ld\u00e1ban egy t\u00f6bbdimenzi\u00f3s t\u00f6mb\u00f6t haszn\u00e1ltunk <code>bool[,]</code> \u00e9s nem t\u00f6mb\u00f6k t\u00f6mbj\u00e9t <code>bool[][]</code>, mivel ezt nyelvi szinten is t\u00e1mogatja a C# \u00e9s jobb teljes\u00edtm\u00e9nyt ny\u00fajt, mint a t\u00f6mb\u00f6k t\u00f6mbje, mert egy objektumk\u00e9nt t\u00f6rol\u00f3dik a heapen.</p> </li> <li> <p><code>CharDef</code>-be <code>char Character</code> felv\u00e9tele: az egyes <code>CharDef</code> oszt\u00e1lyok t\u00e1rolj\u00e1k magukr\u00f3l, hogy mely karakter pixeleit reprezent\u00e1lj\u00e1k.</p> </li> </ul> <p>A dokumentumnak lesz egy gy\u0171jtem\u00e9nye <code>CharDef</code> objektumokb\u00f3l: minden karakterhez pontosan egy darab. Gondoljuk \u00e1t, hogy a legc\u00e9lszer\u0171bb ezt megval\u00f3s\u00edtani. Az egyes karakterdefin\u00edci\u00f3kat a karakterk\u00f3djukkal akarjuk c\u00edmezni, \u00edgy a <code>Dictionary&lt;char, CharDef&gt;</code> ide\u00e1lis v\u00e1laszt\u00e1s: a karakterk\u00f3d a kulcs, az hozz\u00e1 tartoz\u00f3 <code>CharDef</code> pedig az \u00e9rt\u00e9k.</p> <ul> <li><code>FontEditorDocument</code>-be: <code>Dictionary&lt;char, CharDef&gt; charDefs</code> mez\u0151 felv\u00e9tele. Jobb katt, Show as collection association.</li> </ul>"},{"location":"gyakorlat/doc-view/#dokumentumok-menedzselese-app-singleton-osztaly","title":"Dokumentumok menedzsel\u00e9se - App Singleton oszt\u00e1ly","text":"<p>Az alkalmaz\u00e1sban nyilv\u00e1n kell tartani a megnyitott dokumentumok list\u00e1j\u00e1t. Mely oszt\u00e1ly felel\u0151ss\u00e9ge legyen? Vezess\u00fcnk be r\u00e1 egy alkalmaz\u00e1sszint\u0171 oszt\u00e1lyt: legyen a neve <code>App</code> (Windows Forms alatt m\u00e1r van <code>Application</code>, nem c\u00e9lszer\u0171 ezt a nevet v\u00e1lasztani). Ez lesz az alkalmaz\u00e1sunk \u201egy\u00f6k\u00e9roszt\u00e1lya\u201d.</p> <ul> <li>Vegy\u00fck fel az <code>App</code> oszt\u00e1lyt.</li> <li><code>App</code>-ba <code>List&lt;FontEditorDocument&gt; documents</code> mez\u0151 felv\u00e9tele, majd Show as collection association.</li> </ul> <p>Gondoljuk v\u00e9gig, hogyan t\u00f6rt\u00e9nik majd egy \u00faj dokumentum l\u00e9trehoz\u00e1sa (mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor): be kell k\u00e9rni a felhaszn\u00e1l\u00f3t\u00f3l a dokumentum nev\u00e9t, l\u00e9tre kell hozni egy <code>FontEditorDocument</code> objektumot, fel kell venni a megnyitott dokumentumok list\u00e1j\u00e1ba stb. Ezt a logik\u00e1t ne tegy\u00fck a GUI-ba (men\u00fcelem click esem\u00e9nykezel\u0151): tegy\u00fck abba az oszt\u00e1lyba, melynek a felel\u0151ss\u00e9ge a megnyitott dokumentumok menedzsel\u00e9se, amely t\u00e1rolja a sz\u00fcks\u00e9ges adatokat hozz\u00e1 (dokumentum lista). \u00cdgy legyen ez az <code>App</code> oszt\u00e1lyunk feladata, benne vegy\u00fck fel a sz\u00fcks\u00e9ges m\u0171veleteket:</p> <ul> <li><code>App</code>-ba <code>NewDocument</code> \u00e9s <code>OpenDocument</code> m\u0171veletek felv\u00e9tele.</li> </ul> <p>Most a dokumentum ment\u00e9st gondoljuk v\u00e9gig: a File/Save mindig az akt\u00edv dokumentumra vonatkozik. Valakinek nyilv\u00e1n kell tartani, melyik az akt\u00edv dokumentum: legyen ez az <code>App</code>, hiszen \u0151 t\u00e1rolja a dokumentumok list\u00e1j\u00e1t is.</p> <ul> <li>A Toolbox-on v\u00e1lasszuk ki az Association kapcsolatot. Az <code>App</code>-b\u00f3l h\u00fazzunk egy nyilat a <code>FontEditorDocument</code>-be. V\u00e1lasszuk ki az \u00fajonnan l\u00e9trehozott kapcsolatot, \u00e9s nevezz\u00fck \u00e1t <code>ActiveDocument</code>-re.</li> <li><code>App</code>-ba <code>void SaveActiveDocument()</code> felv\u00e9tele.</li> <li><code>App</code>-ba <code>void CloseActiveDocument\u00e1()</code> felv\u00e9tele.</li> </ul> <p>Konkr\u00e9t dokumentumra vagy absztrakt \u0151sre hivatkozzunk?</p> <p>Mivel az <code>App</code> oszt\u00e1lyunk alkalmaz\u00e1s specifikus funkci\u00f3kat l\u00e1t el, nyugodtan hivatkozhat a konkr\u00e9t dokumentum t\u00edpusra, \u00e9s felesleges az absztrakt \u0151st\u0151l f\u00fcggen\u00fcnk, mert az csak nem k\u00edv\u00e1nt castol\u00e1sokhoz vezetne.</p> <p>Az <code>App</code> objektumb\u00f3l \u00e9rtelemszer\u0171en csak egyet kell/szabad l\u00e9trehozni, amely a fut\u00f3 alkalmaz\u00e1st reprezent\u00e1lja. Van m\u00e9g egy probl\u00e9m\u00e1nk: a File/Save stb. men\u00fcelem click esem\u00e9nykezel\u0151ben el kell \u00e9rj\u00fck ezt az egy objektumot. Illetve, majd t\u00f6bb m\u00e1s helyen is. J\u00f3 lenne, ha nem kellene minden oszt\u00e1lyban k\u00fcl\u00f6n el\u00e9rhet\u0151v\u00e9 tenni (tagv\u00e1ltoz\u00f3 vagy f\u00fcggv\u00e9nyparam\u00e9ter form\u00e1j\u00e1ban), hanem b\u00e1rhonnan egyszer\u0171en el\u00e9rhet\u0151 lenne. Erre ny\u00fajt megold\u00e1st a Singleton tervez\u00e9si minta. Egy oszt\u00e1lyb\u00f3l csak egy objektumot enged l\u00e9trehozni, \u00e9s ahhoz glob\u00e1lis hozz\u00e1f\u00e9r\u00e9st biztos\u00edt, m\u00e9gpedig az oszt\u00e1ly nev\u00e9n \u00e9s egy statikus <code>Instance</code> property-n kereszt\u00fcl, pl. \u00edgy: <code>App.Instance.SaveDocument</code>, stb. Nem val\u00f3s\u00edtjuk meg teljes \u00e9rt\u00e9k\u0171en, de tegy\u00fck meg az al\u00e1bbiakat:</p> <ul> <li><code>App</code>-ba <code>App Instance</code> property felv\u00e9tele. Properties ablakban static: true.</li> <li><code>App</code>-ba priv\u00e1t konstruktor felv\u00e9tele.</li> </ul> <p>Az <code>App</code>-oszt\u00e1llyal v\u00e9gezt\u00fcnk.</p>"},{"location":"gyakorlat/doc-view/#nezetek","title":"N\u00e9zetek","text":"<p>A n\u00e9zetekkel eddig nem foglalkoztunk, ez a k\u00f6vetkez\u0151 l\u00e9p\u00e9s. Futtassuk a k\u00e9sz alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, hogy h\u00e1ny t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g, melyikb\u0151l h\u00e1ny p\u00e9ld\u00e1ny lesz:</p> <ul> <li>K\u00e9t t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g: az egyik a mintasz\u00f6veget jelen\u00edti meg, a m\u00e1sik egy adott karakter szerkeszt\u00e9s\u00e9t teszi lehet\u0151v\u00e9.</li> <li>Legyen az el\u0151z\u0151 neve <code>SampleTextView</code>, az ut\u00f3bbi\u00e9 <code>FontEditorView</code>.</li> <li><code>SampleTextView</code>-b\u00f3l mindig egy van (egy adott dokumentumra vonatkoz\u00f3an), a <code>FontEditorView</code> objektumok ig\u00e9ny szerint j\u00f6nnek l\u00e9tre, 0..n p\u00e9ld\u00e1ny l\u00e9tezhet.</li> <li>Vegy\u00fck fel a k\u00e9t oszt\u00e1lyt.</li> <li>Implement\u00e1ltassuk vel\u00fck az <code>IView</code> interf\u00e9szt (Toolbox / Inheritence kapcsolat). Az <code>Update</code> m\u0171velet automatikusan implement\u00e1lva lesz.</li> </ul> <p>Az egyes n\u00e9zetek a dokumentumukb\u00f3l \u201et\u00e1pl\u00e1lkoznak\u201d, a a dokumentumukban t\u00e1rolt adatokat jelen\u00edtik meg, azokat m\u00f3dos\u00edtj\u00e1k. Ehhez, a D-V architekt\u00far\u00e1nak megfelel\u0151en el kell \u00e9rj\u00e9k a dokumentumukat.</p> <ul> <li>A <code>SampleTextView</code> \u00e9s <code>FontEditorView</code>-ban vegy\u00fcnk fel egy <code>FontEditorDocument</code> t\u00edpus\u00fa <code>document</code> nev\u0171 mez\u0151t (ha felvett\u00fck az egyikben, lehet copy-paste-tel m\u00e1solni a m\u00e1sikba), majd \"Show as Association\". Megjegyz\u00e9s: az\u00e9rt nem c\u00e9lszer\u0171 \u00e1ltal\u00e1nos <code>Document</code> t\u00edpus\u00fat felvenni (\u00e9s az interf\u00e9szbe felvinni), mert a view-knak a konkr\u00e9t dokumentum adatait (l\u00e1sd al\u00e1bb) el kell \u00e9rni\u00fck.</li> </ul> <p>Gondoljuk v\u00e9gig, milyen adattagokkal rendelkeznek az egyes n\u00e9zetek. Ehhez futtassuk az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg ism\u00e9t a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t.</p> <ul> <li>A <code>SampleTextView</code> t\u00e1rolja a mintasz\u00f6veget, melyet meg kell jelen\u00edteni. Vegy\u00fcnk fel egy <code>sampleText:string</code> mez\u0151t. Ha el kellene menteni a mintasz\u00f6veget is, akkor a <code>FontEditorDocument</code>-ben kellene t\u00e1rolni (\u00e9s onnan mindig lek\u00e9rdezni), mert az adatok ment\u00e9s\u00e9\u00e9rt a dokumentum oszt\u00e1lyunk a felel\u0151s.</li> <li>A <code>FontEditorView</code> k\u00e9t dolgot t\u00e1rol:<ul> <li>A karakter k\u00f3dja, melynek pixeleit megjelen\u00edti. Vegy\u00fcnk fel egy <code>editedChar: char</code> mez\u0151t.</li> <li>A nagy\u00edt\u00e1si t\u00e9nyez\u0151t (<code>zoom: double</code> felv\u00e9tele)</li> </ul> </li> </ul> <p>A n\u00e9zetek maguk felel\u0151sek a kirajzol\u00e1suk\u00e9rt:</p> <ul> <li><code>Draw (g:Grapics)</code> felv\u00e9tele mindk\u00e9t n\u00e9zetbe.</li> </ul>"},{"location":"gyakorlat/doc-view/#fonteditordocument-muveletek","title":"FontEditorDocument m\u0171veletek","text":"<p>A <code>FontEditorDocument</code>-ben egy priv\u00e1t list\u00e1ban van egyel\u0151re jelen a <code>CharDef</code>-ek list\u00e1ja. A n\u00e9zetek \u00edgy nem tudj\u00e1k el\u00e9rni, pedig a megjelen\u00edt\u00e9shez sz\u00fcks\u00e9g\u00fck lenne r\u00e1. A dokumentumunkban be kell vezess\u00fcnk olyan m\u0171veleteket, melyek a dokumentum \u00e1ltal t\u00e1rolt adatokat a n\u00e9zetek sz\u00e1m\u00e1ra el\u00e9rhet\u0151v\u00e9 teszik, \u00e9s lehet\u0151s\u00e9get biztos\u00edtanak a m\u00f3dos\u00edt\u00e1sra is.</p> <ul> <li>Mindk\u00e9t n\u00e9zet el kell \u00e9rje a megjelen\u00edtett karakterek pixeleit t\u00e1rol\u00f3 <code>CharDef</code> objektumokat. Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben a <code>GetCharDef(c:char):CharDef</code> m\u0171veletet. Ezt hossz\u00fa t\u00e1von majd \u00fagy lesz c\u00e9lszer\u0171 megval\u00f3s\u00edtani, hogy a <code>GetCharDef</code> nem az eredeti objektumot adja vissza, hanem annak egy m\u00e1solat\u00e1t (clone). Ha az eredetit adn\u00e1 vissza, akkor a n\u00e9zetek K\u00d6ZVETLEN\u00dcL tudn\u00e1k m\u00f3dos\u00edtani a pixelek \u00e9rt\u00e9k\u00e9t, ezt mi nem akarjuk (b\u00e1r a funkci\u00f3k b\u0151v\u00edt\u00e9s\u00e9vel r\u00e1k\u00e9nyszer\u00fclhet\u00fcnk).</li> <li>A <code>FontEditorView</code>-nak k\u00e9pesnek kell lennie egy adott <code>CharDef</code> adott koordin\u00e1t\u00e1ban lev\u0151 pixel \u00e9rt\u00e9k\u00e9t invert\u00e1lni (eg\u00e9r kattint\u00e1skor). Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben az <code>InvertCharDefPixel(c:char, x: int, y: int)</code> m\u0171veletet.</li> </ul>"},{"location":"gyakorlat/doc-view/#a-tervezes-zarasa","title":"A tervez\u00e9s z\u00e1r\u00e1sa","text":"<p>Eljutottunk oda, hogy megtervezt\u00fck az architekt\u00far\u00e1t, minden igaz\u00e1n l\u00e9nyeges d\u00f6nt\u00e9st meghoztunk. Az UML diagram alapj\u00e1n megsz\u00fcletett az oszt\u00e1lyok v\u00e1za. Ezt term\u00e9szetesen jelent\u0151sen b\u0151v\u00edteni kell, m\u00e9g sz\u00fcletnek \u00faj oszt\u00e1lyok is (pl. Form-ok, vez\u00e9rl\u0151k).</p>"},{"location":"gyakorlat/doc-view/#3-feladat-a-kesz-alkalmazas-attekintese","title":"3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se","text":"<p>Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t (laboron kb. 15 percben), annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t.</p> <p>T\u00f6lts\u00fck le  a k\u00e9sz megold\u00e1st. Ehhez parancssorban navig\u00e1ljunk a c:\\work\\ mapp\u00e1ba (ha a laborban dolgozunk), \u00e9s adjuk ki a k\u00f6vetkez\u0151 parancsot: <p><code>git clone https://github.com/bmeviauab00/lab-docview-megoldas</code></p> <p>Nyissuk meg a k\u00e9sz solution-t, futtassuk \u00e9s pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1s alapfunkci\u00f3it.</p>"},{"location":"gyakorlat/doc-view/#nezetek-megvalositasa","title":"N\u00e9zetek megval\u00f3s\u00edt\u00e1sa","text":"<p>Nyissuk meg a <code>FontEditorView</code>-t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A <code>FontEditorView</code> egyr\u00e9szt implement\u00e1lja az <code>IView</code> interf\u00e9szt, m\u00e1sr\u00e9szt a <code>UserControl</code>-b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. A Visual Studio designer fel\u00fclet\u00e9n ak\u00e1r bele is m\u00f3dos\u00edthatn\u00e1nk a layoutba \u00e9s a vez\u00e9rl\u0151k tulajdons\u00e1gaiba. Ha k\u00edv\u00e1ncsiak vagyunk, ki is pr\u00f3b\u00e1lhatjuk ezt (pl. a nagy\u00edt\u00e1s \u00e9s a kicsiny\u00edt\u00e9s gombok hely\u00e9nek megv\u00e1ltoztat\u00e1s\u00e1val).</p> <p>A <code>SampleTextView</code> is <code>UserControl</code> lesz\u00e1rmazott, b\u00e1r annak egyszer\u0171 a fel\u00fclete (nincsenek rajta m\u00e1s vez\u00e9rl\u0151k), \u00edgy lehetett volna k\u00f6z\u00f6ns\u00e9ges <code>Control</code> lesz\u00e1rmazott is.</p> <p> Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan <code>UserControl</code>-k\u00e9nt (esetleg <code>Control</code>-k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani.</p>"},{"location":"gyakorlat/doc-view/#egy-oldal-tab-elrendezese","title":"Egy oldal (tab) elrendez\u00e9se","text":"<p>Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A <code>UserControl</code>-ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a <code>FontDocumentControl</code>-t tervez\u0151i n\u00e9zetben. Ez egy olyan vez\u00e9rl\u0151, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki (<code>Label</code>, <code>TextBox</code>, <code>Panel</code>-ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u00e9rdekess\u00e9g pedig az, hogy a <code>SampleTextView</code>-t is a Toolbox-r\u00f3l drag&amp;drop-pal ker\u00fclt felhelyez\u00e9sre (pont \u00fagy, mintha egy be\u00e9p\u00edtett vez\u00e9rl\u0151 lenne). Annyit n\u00e9zz\u00fcnk meg, hogy a <code>SampleTextView</code> val\u00f3ban ott van a Toolbox tetej\u00e9n.</p>"},{"location":"gyakorlat/doc-view/#forgatokonyv-1-egy-pixel-invertalasa-nezetek-szinkronizalasa","title":"Forgat\u00f3k\u00f6nyv 1 \u2013 Egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa","text":"<p> Ez egy kiemelt jelent\u0151s\u00e9g\u0171 forgat\u00f3k\u00f6nyv, mert ezt illusztr\u00e1lja a D-V architekt\u00fara alapmechanizmus\u00e1t, a n\u00e9zetek friss\u00edt\u00e9s\u00e9t \u00e9s konzisztensen tart\u00e1s\u00e1t. Keress\u00fck meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz pixel invert\u00e1l\u00e1s folyamat elindul. A <code>FontEditorView.FontEditorView_MouseClick</code> a kiindul\u00f3pont. Itt az al\u00e1bb kiemelt sor a l\u00e9nyeg:</p> <pre><code>private void FontEditorView_MouseClick(object sender, MouseEventArgs e)\n{\nint x = e.X / zoom;\nint y = (e.Y - offsetY) / zoom;\nif (x &gt;= CharDef.FontSize.Width)\nreturn;\n\ndocument.InvertCharDefPixel(editedChar, x, y);\n}\n</code></pre> <p>N\u00e9zz\u00fck meg a <code>FontEditorDocument.InvertCharDefPixel</code>-t. Az invert\u00e1lja a megfelel\u0151 <code>CharDef</code> pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor:</p> <pre><code>public void InvertCharDefPixel(char c, int x, int y)\n{\nvar charDef = GetCharDefCore(c);\nif (charDef == null)\nreturn;\n\ncharDef.Pixels[x, y] = !charDef.Pixels[x, y];\n\nUpdateAllViews();\n}\n</code></pre> <p>Az <code>UpdateAllViews</code> a <code>Document</code> \u0151sben van, <code>Update</code>-et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az <code>Update</code> hogyan van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a <code>FontEditView</code>-t:</p> <pre><code>public void Update()\n{\nInvalidate();\n}\n</code></pre> <p>Az <code>Update</code> hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az <code>Update</code>-ben nem tudunk rajzolni, csak az <code>OnPaint</code>-ben. \u00cdgy itt az <code>Invalidate</code> h\u00edv\u00e1ssal kiv\u00e1ltjuk a <code>Paint</code> esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban a n\u00e9zetek <code>Update</code> f\u00fcggv\u00e9ny\u00e9ben tipikusan egy <code>Invalidate</code> h\u00edv\u00e1s szokott lenni.</p> <p>Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a <code>FontEditView.OnPaint</code> megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis <code>CharDef</code>-et (mert a n\u00e9zet a D-V architekt\u00fara alapelveinek megfelel\u0151en nem t\u00e1rolja), majd ki kell azt rajzolni.</p> <pre><code>protected override void OnPaint(PaintEventArgs e)\n{\nbase.OnPaint(e);\n\nvar editedCharDef = document.GetCharDef(editedChar);\nCharDefViewModel.DrawFont(e.Graphics, editedCharDef, 0, offsetY, zoom);\n}\n</code></pre> <p>Kirajzol\u00e1s logik\u00e1ja</p> <p>Mivel a kirajzol\u00e1s logik\u00e1ja a <code>FontEditorView</code>-ban \u00e9s a <code>SampleTextView</code>-ban is azonosan m\u0171k\u00f6dik a <code>Graphics</code> oszt\u00e1ly haszn\u00e1lat\u00e1val, kiszervezt\u00fck ezt egy <code>CharDefViewModel</code> seg\u00e9doszt\u00e1lyba az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g kedv\u00e9\u00e9rt.</p> <p>A <code>CharDef</code>-be nem c\u00e9lszer\u0171 rakni ezt a logik\u00e1t, mivel az egy n\u00e9zet f\u00fcggetlen adatreprezent\u00e1ci\u00f3, \u00e9s sokkal ink\u00e1bb a dokumentumhoz tartozik, mint a n\u00e9zethez.</p>"},{"location":"gyakorlat/doc-view/#forgatokonyv-2-uj-dokumentum-letrehozasa-opcionalis","title":"Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa (opcion\u00e1lis)","text":"<p>Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor.</p> <p>Nyissuk meg a <code>MainForm</code>-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, majd ugorjunk el a <code>Click</code> esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az <code>App</code> oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el:</p> <pre><code>App.Instance.NewDocument();\n</code></pre> <p>Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az <code>App</code>-ba.</p> <p>Tekints\u00fck \u00e1t az <code>App.NewDocument</code> t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban fussuk \u00e1t a fontosabb l\u00e9p\u00e9seket.</p> <ol> <li><code>NewDocForm</code> n\u00e9zet megnyit\u00e1sa \u00e9s v\u00e1rakoz\u00e1s a v\u00e1laszra.</li> <li>Sikeres v\u00e1lasz eset\u00e9n \u00faj <code>FontEditorDocument</code> l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentumok k\u00f6z\u00e9, valamint akt\u00edvv\u00e1 t\u00e9tele.</li> <li>\u00daj tab l\u00e9trehoz\u00e1sa a n\u00e9zetekkel.</li> </ol> <pre><code>public void NewDocument()\n{\n// Bek\u00e9rj\u00fckk az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a\n// felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban.\nvar form = new NewDocForm(GetDocumentNames());\nif (form.ShowDialog() != DialogResult.OK)\nreturn;\n\n// \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentum list\u00e1ba.\nvar doc = new FontEditorDocument(form.FontName);\ndocuments.Add(doc);\n\n// Az \u00faj tab lesz az akt\u00edv, az activeDocument tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani.\nUpdateActiveDocument(doc.Name);\n\nCreateTabForNewDocument(doc);\n}\n</code></pre> <p>App oszt\u00e1ly felel\u0151ss\u00e9gi k\u00f6re</p> <p>Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben az <code>App</code> oszt\u00e1ly most t\u00f6bb felel\u0151ss\u00e9ggel is rendelkezik, de ide\u00e1lis esetben sz\u00e9t lenne szedve pl. a k\u00f6vetkez\u0151 oszt\u00e1lyokra a felel\u0151ss\u00e9gi k\u00f6r\u00f6knek megfelel\u0151en:</p> <ul> <li><code>DocumentManager</code>: a megjelen\u00edt\u00e9st\u0151l f\u00fcggetlen\u00fcl a dokumentumokat t\u00e1roln\u00e1.</li> <li><code>ViewManager</code>: feladata a n\u00e9zetek menedzsel\u00e9se, tabcontrolokhoz hozz\u00e1ad\u00e1sa stb. lenne.</li> </ul> <p>Az <code>App.OpenDocument</code> m\u0171velet t\u00f6rzse nincs implement\u00e1lva, de a l\u00e9p\u00e9sek k\u00f3dmegjegyz\u00e9sek form\u00e1j\u00e1ban adottak, remek otthoni gyakorl\u00e1si lehet\u0151s\u00e9g a m\u0171velet t\u00e9nyleges megval\u00f3s\u00edt\u00e1sa.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/","title":"A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa","text":""},{"location":"gyakorlat/felhasznaloi-felulet/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja egy l\u00e1tv\u00e1nyos, gyors alkalmaz\u00e1sfejleszt\u00e9s bemutat\u00e1sa, mely egyben megteremti a lehet\u0151s\u00e9get a Windows Forms fejleszt\u00e9s alapjainak elsaj\u00e1t\u00edt\u00e1s\u00e1ra. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt):</p> <ul> <li>Windows Forms alkalmaz\u00e1sfejleszt\u00e9s alapok</li> <li>Men\u00fck</li> <li>Dokkol\u00e1s \u00e9s horgonyz\u00e1s</li> <li>SplitView</li> <li>TreeView</li> <li>ListView  </li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Vastagkliens alkalmaz\u00e1sok fejleszt\u00e9se.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"gyakorlat/felhasznaloi-felulet/#bevezeto","title":"Bevezet\u0151","text":"<p>A Rapid Application Development (RAD) elve a fejleszt\u00e9si id\u0151 ler\u00f6vid\u00edt\u00e9s\u00e9t c\u00e9lozza meg az\u00e1ltal, hogy a fejleszt\u00e9s sor\u00e1n k\u00e9sz komponensekkel dolgozik, integr\u00e1lt fejleszt\u0151 k\u00f6rnyezetet (pl. Visual Studio) \u00e9s sok automatizmust alkalmaz. Fontos ugyanakkor, hogy az automatizmusok ne sz\u0171k\u00edts\u00e9k be t\u00falzottan a fejleszt\u0151 lehet\u0151s\u00e9geit \u00e9s kell\u0151 rugalmass\u00e1got adjanak neki a rendszerek testre szab\u00e1s\u00e1ban. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban l\u00e1tni fogjuk, mik\u00e9nt alkalmas mindezekre a Windows Forms k\u00f6rnyezet.</p> <p>A Window Forms alkalmaz\u00e1sok legfontosabb koncepci\u00f3it a t\u00e1rgy 3.-4. el\u0151ad\u00e1sa ismerteti. Egy Windows Forms alkalmaz\u00e1sban az alkalmaz\u00e1sunk minden ablak\u00e1nak egy saj\u00e1t oszt\u00e1lyt kell l\u00e9trehozni, mely a be\u00e9p\u00edtett Form oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Erre \u2013 tipikusan a Visual Studio designer\u00e9vel - vez\u00e9rl\u0151ket helyez\u00fcnk fel, melyek a Form oszt\u00e1lyunk tagv\u00e1ltoz\u00f3i lesznek.</p> <p>IntelliSense</p> <p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban sz\u00e1mos gener\u00e1lt (\u00e9s emiatt hossz\u00fa) elnevez\u00e9ssel fogunk tal\u00e1lkozni. Programjaink megval\u00f3s\u00edt\u00e1sakor haszn\u00e1ljuk ki az automatikus k\u00f3dkieg\u00e9sz\u00edt\u00e9s (IntelliSense) ny\u00fajtotta lehet\u0151s\u00e9geket \u00e9s ne k\u00e9zzel g\u00e9pelj\u00fck be az egyes elnevez\u00e9seket.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-winforms-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#1-feladat-hello-world-windows-forms-technologiaval","title":"1. Feladat \u2013 \u201eHello world\u201d Windows Forms technol\u00f3gi\u00e1val","text":"<p>A feladat sor\u00e1n egy olyan Windows Forms alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk el, amely egy egyszer\u0171 ablakban ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget.</p> <ol> <li> <p>Ind\u00edtsuk el a Visual Studio 2022-t</p> </li> <li> <p>Hozzunk l\u00e9tre egy C# nyelv\u0171, Windows Forms t\u00edpus\u00fa alkalmaz\u00e1st, m\u00e9gpedig .NET platformra.</p> <ol> <li>Ehhez a VS ind\u00edt\u00f3ablak\u00e1ban jobb oldalt a Create new project gombon kell kattintani, majd a projekt l\u00e9trehoz\u00f3 var\u00e1zsl\u00f3ban a Windows Forms App sablont kell kiv\u00e1lasztani. L\u00e9nyeges, hogy NE a Windows Forms App (.NETFramework) legyen! A sablon kikeres\u00e9s\u00e9hez haszn\u00e1ljuk az ablak keres\u0151/sz\u0171r\u0151mez\u0151it, amennyiben sz\u00fcks\u00e9ges. Kattintsunk a Next gombra.</li> <li>A megjelen\u0151 oldalon<ol> <li>A Projekt name \u00e9s Solution name legyen <code>HelloWorldWF</code></li> <li>Az \u00fatvonal a laborg\u00e9peken: <code>C:\\Work\\</code> alatt egy mappa, mely a saj\u00e1t nev\u00fcnk vagy Neptun k\u00f3dunk szerint van nevezve.</li> <li>Next gombbal k\u00f6vetkez\u0151 oldalra v\u00e1lt\u00e1s</li> </ol> </li> <li>A Framework mez\u0151ben v\u00e1lasszuk ki a .NET 8.0 (Long term support)-ot.</li> </ol> <p>Futtassuk a kiindul\u00f3 projektet, hogy l\u00e1ssuk, mit biztos\u00edt a kiindul\u00f3 alkalmaz\u00e1skeret (nem sokat, van egy egyszer\u0171 ablak). \u00c1ll\u00edtsuk le a fut\u00f3 alkalmaz\u00e1st.</p> </li> <li> <p>Kattintsunk dupl\u00e1n a <code>Form1.cs</code> f\u00e1jlra! Ezt k\u00f6vet\u0151en a fel\u00fcleten megjelenik egy sz\u00fcrke ablak. Amennyiben a Solution Explorerben a <code>Form1.cs</code> f\u00e1jl elemet kibontjuk, l\u00e1tni fogjuk, hogy egy <code>Form1.designer.cs</code> nev\u0171 f\u00e1jl is tartozik hozz\u00e1.</p> <p>A fenti egyszer\u0171 program fel\u00e9p\u00edt\u00e9s\u00e9t k\u00f6nnyen v\u00e9gig k\u00f6vethetj\u00fck kor\u00e1bbi ismereteink alapj\u00e1n. A program bel\u00e9p\u00e9si pontja itt is a <code>Program.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 <code>Main</code> f\u00fcggv\u00e9ny. A f\u00fcggv\u00e9ny l\u00e9trehoz egy p\u00e9ld\u00e1nyt a <code>Form1</code> oszt\u00e1lyb\u00f3l, majd az <code>Application.Run</code> f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9vel elind\u00edtja az \u00fczenetkezel\u0151 ciklust \u00e9s megjelen\u00edti az ablakot (a Windows Forms vil\u00e1g\u00e1ban \u201eForm\u201d-nak h\u00edvjuk az ablakokat).</p> <p>A <code>Form1</code> oszt\u00e1ly k\u00f3dja k\u00e9t f\u00e1jlban van defini\u00e1lva (ezt a C# <code>partial</code> kulcsszava teszi lehet\u0151v\u00e9). A <code>Form1.cs</code> a felhaszn\u00e1l\u00f3 \u00e1ltal kezelt k\u00f3dr\u00e9szleteket, m\u00edg a <code>Form1.designer.cs</code> a grafikus Form designer \u00e1ltal gener\u00e1lt k\u00f3dot tartalmazza. Ez ut\u00f3bbi mindig teljes szinkronban van a design n\u00e9zettel, k\u00f6zvetlen m\u00f3dos\u00edt\u00e1s\u00e1ra ugyan van lehet\u0151s\u00e9g, de a speci\u00e1lis hibaelh\u00e1r\u00edt\u00e1si eseteket lesz\u00e1m\u00edtva felesleges \u00e9s ker\u00fclend\u0151. Figyelj\u00fck meg, hogy a k\u00e9t f\u00e1jl k\u00f6z\u00f6tt m\u00e1r a gener\u00e1lt k\u00f3d alapj\u00e1n is kapcsolat van, hiszen a <code>Form1</code> konstruktora \u00e1th\u00edv a m\u00e1sik f\u00e1jlban defini\u00e1lt <code>InitializeComponent()</code> f\u00fcggv\u00e9nybe.</p> <p>Designer n\u00e9zet \u00e9s k\u00f3d k\u00f6z\u00f6tt v\u00e1lt\u00e1s</p> <p>Amennyiben a <code>Form1.cs</code> f\u00e1jlra dupl\u00e1n kattintunk, alap\u00e9rtelmez\u00e9sben nem a forr\u00e1sk\u00f3d, hanem a tervez\u0151 n\u00e9zet (Form designer) jelenik meg. Innen a forr\u00e1sk\u00f3d n\u00e9zetre a fel\u00fcleten jobb kattintva, a View Code men\u00fcponttal, vagy az F7 billenty\u0171 megnyom\u00e1s\u00e1val juthatunk.</p> <p>Elk\u00e9pzelhet\u0151, hogy megjelenik egy tov\u00e1bbi, <code>Form1.resx</code> nev\u0171 f\u00e1jl is. Ez az ablakhoz tartoz\u00f3 er\u0151forr\u00e1sokat (tipikusan k\u00e9pek, sz\u00f6vegek) tartalmazhatja, de a mi eset\u00fcnkben most nincs jelent\u0151s\u00e9ge.</p> </li> <li> <p>Kattintsunk dupl\u00e1n a <code>Form1.cs</code> f\u00e1jlra! Ez alap\u00e9rtelmez\u00e9sben a tervez\u0151 n\u00e9zetet nyitja meg.</p> </li> <li> <p>Kattintsunk az \u0171rlap h\u00e1tter\u00e9n, hogy az \u0171rlap legyen kiv\u00e1lasztva. A Visual Studio Properties ablak\u00e1ban l\u00e1thatjuk az \u0171rlapunk aktu\u00e1lis tulajdons\u00e1gait. Amennyiben a Properties ablak nem l\u00e1that\u00f3, az F4 billenty\u0171vel tudjuk el\u0151csalni (vagy View men\u00fc / Properties). A Properties ablakban keress\u00fck meg a <code>Text</code> tulajdons\u00e1got, \u00e9s \u00edrjuk \u00e1t \u201eHello World\u201d -re. Ez az \u0171rlapunk fejl\u00e9c\u00e9nek a sz\u00f6veg\u00e9t \u00e1ll\u00edtja be.</p> <p></p> <p>Mint l\u00e1that\u00f3, az \u0171rlapunk sz\u00e1mos tulajdons\u00e1ggal rendelkezik, ezek mindegyik\u00e9t a Properties ablakban be tudjuk \u00e1ll\u00edtani az aktu\u00e1lis ig\u00e9nyeknek megfelel\u0151en.</p> </li> <li> <p>Nyissuk ki a Toolbox-ot (View men\u00fc / Toolbox).</p> </li> <li> <p>H\u00fazzunk r\u00e1 a formra egy <code>TextBox</code> \u00e9s egy <code>Button</code> (gomb) vez\u00e9rl\u0151t tetsz\u0151leges helyre! (Ezeket a vez\u00e9rl\u0151ket a Toolbox Common Windows Forms csoportj\u00e1ban tal\u00e1ljuk).</p> </li> <li> <p>Kattintsunk egyszer a gomb vez\u00e9rl\u0151n, hogy biztosan az legyen kiv\u00e1lasztva a designerben. Ekkor a Properties ablakban a gombunk tulajdons\u00e1gai jelennek meg. \u00c1ll\u00edtsuk be a <code>Text</code> tulajdons\u00e1g\u00e1t \u201eBe\u00e1ll\u00edt\u201d-ra, ez a gombunk sz\u00f6veg\u00e9t fogja ennek megfelel\u0151en be\u00e1ll\u00edtani.</p> </li> <li> <p>Ugyanitt a Properties ablakban \u00e1ll\u00edtsuk be gombunk referenci\u00e1j\u00e1t tartalmaz\u00f3 oszt\u00e1lyv\u00e1ltoz\u00f3 nev\u00e9t, vagyis a <code>Name</code> tulajdons\u00e1g\u00e1t <code>button1</code>-r\u0151l <code>bUpdateText</code>-re. L\u00e9nyeges, hogy a vez\u00e9rl\u0151inket a funkci\u00f3juknak megfelel\u0151 nevekkel l\u00e1ssuk el, ez nagyban seg\u00edti a k\u00f3dunk olvashat\u00f3s\u00e1g\u00e1t. A <code>b</code> prefix a vez\u00e9rl\u0151 <code>Button</code> t\u00edpus\u00e1ra utal.</p> <p>Hungarian Notation</p> <p>A fenti prefixelt elnevez\u00e9si konvenci\u00f3t Hungarian Notationnek h\u00edvj\u00e1k, mert Charles Simonyi (Simonyi K\u00e1roly fia) tal\u00e1lta ki, amikor az Excel csapatban dolgozott a Microsoftn\u00e1l.</p> <p>A koncepci\u00f3 els\u0151sorban C++-hoz k\u00e9sz\u00fclt, olyan id\u0151kben, amikor m\u00e9g nem voltak gazdag funkcionalit\u00e1s\u00fa fejelszt\u0151k\u00f6rnyezetek, \u00e9s egy egyszer\u0171 sz\u00f6vegszerkeszt\u0151vel is r\u00e1n\u00e9z\u00e9sre meg kellett tudni mondani, hogy a v\u00e1ltoz\u00f3 milyen t\u00edpus\u00fa. Ez manaps\u00e1g m\u00e1r nem relev\u00e1ns, mert a Visual Studio is pl. az eg\u00e9rkurzor seg\u00edts\u00e9g\u00e9vel visszajelz\u00e9st ad a v\u00e1ltoz\u00f3 t\u00edpus\u00e1r\u00f3l.</p> </li> <li> <p>Az el\u0151z\u0151 l\u00e9p\u00e9s mint\u00e1j\u00e1ra nevezz\u00fck \u00e1t a <code>TextBox</code> vez\u00e9rl\u0151nket <code>tbDemoText</code>-re. A <code>tb</code> prefix a vez\u00e9rl\u0151 <code>TextBox</code> t\u00edpus\u00e1ra utal.</p> </li> <li> <p>Az \u0171rlapunk neve jelenleg <code>Form1</code>, mely szint\u00e9n el\u00e9g semmitmond\u00f3. Nevezz\u00fck \u00e1t <code>MainForm</code>-ra, az al\u00e1bbi l\u00e9p\u00e9seket k\u00f6vetve. Az \u00e1tnevez\u00e9st a Solution Explorerben tudjuk megtenni, itt t\u00f6bb technik\u00e1t is haszn\u00e1lhatunk. </p> <p>Miel\u0151tt \u00e1tnevezz\u00fck az \u0171rlapot</p> <p>Egy VS2022-es bug miatt fontos, hogy \u00e1tnevez\u00e9s el\u0151tt mindenk\u00e9ppen z\u00e1rjuk be az \u0171rlap designer fel\u00fclet\u00e9t, \u00e9s minden, az \u0171rlaphoz tartoz\u00f3 f\u00e1jlt. Ha nem tessz\u00fck meg, akkor az \u00e1tnevez\u00e9st k\u00f6vet\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 kellemetlen anom\u00e1li\u00e1kat tapasztalhatunk (elt\u0171nnek a vez\u00e9rl\u0151k a fel\u00fcletr\u0151l, nem lehet esem\u00e9nykezel\u0151ket felvenni, furcsa hib\u00e1kat jelez a designer stb.)</p> <ul> <li> <p>V\u00e1lasszuk ki a <code>Form1</code> elemet, majd m\u00e9g egyszer kattintsunk rajta bal gombbal: ekkor a n\u00e9v szerkeszthet\u0151v\u00e9 v\u00e1lik (pont \u00fagy dolgozunk, ahogy egy f\u00e1jlt is \u00e1tnevez\u00fcnk Windows F\u00e1jlkezel\u0151ben/File Explorerben).</p> </li> <li> <p>Vagy egyszer\u0171en csak megnyomjuk az F2 billenty\u0171t az \u00e1tnevez\u00e9s elind\u00edt\u00e1s\u00e1hoz.</p> </li> <li> <p>Vagy ak\u00e1r haszn\u00e1lhatjuk a jobb gombos men\u00fc Rename funkci\u00f3j\u00e1t. Ak\u00e1rhogy is indultunk, \u00edrjuk be \u00faj n\u00e9vnek a <code>MainForm.cs</code>-t, majd nyomjuk meg az Enter billenty\u0171t.</p> </li> </ul> <p>Ekkor a Visual Studio r\u00e1k\u00e9rdez egy felugr\u00f3 ablakban, hogy minden kapcsol\u00f3d\u00f3 elemet nevezzen-e \u00e1t ennek megfelel\u0151en: itt mindenk\u00e9ppen Yes-t v\u00e1lasszunk:</p> <p></p> <p>Hiba \u00e1tnevez\u00e9s ut\u00e1n</p> <p>Ekkor a VS2022 hajlamos egy hiba\u00fczenetet megjelen\u00edteni az \u0171rlapunk hely\u00e9n, amennyiben meg volt nyitva a designerben. Ne ijedj\u00fcnk meg t\u0151le, z\u00e1rjuk be az \u0171rlap tabf\u00fcl\u00e9t (vagy valamennyi megnyitott f\u00e1jl tabf\u00fcl\u00e9t), \u00e9s nyissuk meg \u00fajra a Solution Explorerben az \u0171rlapot: ekkor a hiba elt\u0171nik.</p> </li> <li> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a gombkattint\u00e1s esem\u00e9nyt fogjuk lekezelni: ennek hat\u00e1s\u00e1ra a <code>tbDemoText</code> <code>TextBox</code> vez\u00e9rl\u0151be be\u00edrjuk a \u201eHello\u201d sz\u00f6veget. Egy \u0171rlap/vez\u00e9rl\u0151 esem\u00e9nyeinek megjelen\u00edt\u00e9s\u00e9re is a Properties ablak szolg\u00e1l, csak \u00e1t kell v\u00e1ltsunk az esem\u00e9nymegjelen\u00edt\u0151 n\u00e9zet\u00e9re. Ehhez a Properties ablak fels\u0151 r\u00e9sz\u00e9n tal\u00e1lhat\u00f3 vill\u00e1m ikonon kell kattintanunk:</p> <p></p> <p>Tulajdons\u00e1gok</p> <p>A tulajdons\u00e1gok megjelen\u00edt\u00e9s\u00e9re \u00fagy tudunk a k\u00e9s\u0151bbiekben majd visszav\u00e1ltani, ha a vill\u00e1m ikont\u00f3l balra elhelyezked\u0151 vill\u00e1skulcs ikonra kattintunk (ezt egyel\u0151re ne tegy\u00fck meg).</p> <p></p> <p>Az esem\u00e9nylist\u00e1ban l\u00e1that\u00f3, hogy a <code>Button</code> oszt\u00e1lynak sz\u00e1mos esem\u00e9nye van. Sz\u00e1munkra most a <code>Click</code> esem\u00e9ny az \u00e9rdekes. Erre k\u00e9tf\u00e9lek\u00e9ppen tudunk feliratkozni:</p> <ul> <li>Az esem\u00e9nylist\u00e1ban a <code>Click</code> elemen dupl\u00e1n kattintunk.</li> <li>A designer fel\u00fcleten a gombon dupl\u00e1n kattintva. A designer fel\u00fcleten a dupl\u00e1n kattint\u00e1s mindig a vez\u00e9rl\u0151 - a vez\u00e9rl\u0151 t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151 - alap\u00e9rtelmezett esem\u00e9ny\u00e9re iratkozik fel. Mivel a <code>Click</code> esem\u00e9ny a <code>Button</code> oszt\u00e1ly alap\u00e9rtelemezett esem\u00e9nye, ez nek\u00fcnk most pont meg is felel.</li> </ul> <p>V\u00e1lasszuk most a m\u00e1sodik lehet\u0151s\u00e9get, kattintsunk dupl\u00e1n a gomb vez\u00e9rl\u0151n. Ez l\u00e9trehoz egy esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt, mely akkor h\u00edv\u00f3dik fut\u00e1s k\u00f6zben, amikor a felhaszn\u00e1l\u00f3 kattint a gombon (ak\u00e1r eg\u00e9rrel, ak\u00e1r a Tab billenty\u0171vel r\u00e1navig\u00e1lva a Space billenty\u0171 lenyom\u00e1s\u00e1val). A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben a <code>tbDemoText</code> objektum <code>Text</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be \"Hell\u00f3\"-ra.</p> <pre><code>private void bUpdateText_Click(object sender, EventArgs e)\n{\ntbDemoText.Text = \"Hello\";\n}\n</code></pre> <p>Esem\u00e9nykezel\u0151k fejl\u00e9ce</p> <p>Ha nem tetszik a dupla klikkes gener\u00e1lt n\u00e9v (a hungarian notation miatt kisbet\u0171vel kezd\u0151dik, ami nem t\u00fal C#-os), akkor egyszer\u0171en kezdj\u00fck el beg\u00e9pelni a Properties ablak k\u00edv\u00e1nt esem\u00e9ny\u00e9hez a f\u00fcggv\u00e9ny nev\u00e9t, majd nyomjunk Entert.</p> <p>Az esem\u00e9nykezel\u0151ket tipikusan \u00fagy szoktuk elnevezni, hogy utaljon a vez\u00e9rl\u0151re (alap\u00e9rtelmezetten a neve) majd alulvon\u00e1s ut\u00e1n az esem\u00e9ny neve k\u00f6vetkezik.</p> <p>A Windows Forms vez\u00e9rl\u0151inek esem\u00e9nykezel\u0151iben szinte mindig k\u00e9t param\u00e9tert kapunk:</p> <ul> <li><code>object sender</code>: A kiv\u00e1lt\u00f3 objektum (sajnos nem er\u0151sen t\u00edpusosan)</li> <li><code>EventArgs e</code>: Az esem\u00e9nyhez tartoz\u00f3 param\u00e9tereket tartalmazza. T\u00edpusa <code>EventArgs</code>, vagy annak lesz\u00e1rmazottja. Az <code>EventArgs</code> itt egy \u00fcres param\u00e9tert reprezent\u00e1l, mert a gombkattint\u00e1shoz nem tartozik semmi extra adat. <code>EventArgs</code> lesz\u00e1rmazott olyan esem\u00e9nyek eset\u00e9n haszn\u00e1lt, melyekhez valamilyen plusz adat is tartozik (pl. billenty\u0171 lenyom\u00e1sn\u00e1l a lenyomott billenty\u0171 k\u00f3dja).</li> </ul> </li> <li> <p>Futtassuk az alkalmaz\u00e1st (F5)! Nyomjuk meg a gombot!</p> </li> <li> <p>N\u00e9zz\u00fcnk bele \u00fajra a <code>MainForm.Designer.cs</code>-be. Megtal\u00e1ljuk az \u00fajonnan gener\u00e1lt k\u00f3dot: az \u0171rlapon elhelyezett vez\u00e9rl\u0151kb\u0151l tagv\u00e1ltoz\u00f3k lesznek, melyek az <code>InitializeComponent</code> f\u00fcggv\u00e9nyben ker\u00fclnek inicializ\u00e1l\u00e1sra, itt tal\u00e1ljuk a tulajdons\u00e1gaik be\u00e1ll\u00edt\u00e1s\u00e1t, valamint az esem\u00e9nyekre val\u00f3 feliratkoz\u00e1st.</p> <p>Figyelj\u00fck meg azt is, hogy a gomb lenyom\u00e1s\u00e1ra tulajdonk\u00e9ppen egy C# esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt regisztr\u00e1ltunk be a m\u00e1r ismert <code>+=</code> oper\u00e1tor alkalmaz\u00e1s\u00e1val.</p> <p>L\u00e1thatjuk, hogy a designer csak olyan k\u00f3dot gener\u00e1l, melyet ak\u00e1r mi is meg tudn\u00e1nk \u00edrni, de persze \u00edgy egyszer\u0171bb azt elk\u00e9sz\u00edteni.</p> </li> </ol>"},{"location":"gyakorlat/felhasznaloi-felulet/#nehany-alapfogalom-attekintese","title":"N\u00e9h\u00e1ny alapfogalom \u00e1ttekint\u00e9se","text":""},{"location":"gyakorlat/felhasznaloi-felulet/#form-felulettervezes","title":"Form - fel\u00fclettervez\u00e9s","text":"<p>A <code>Form</code> oszt\u00e1ly az ablakot reprezent\u00e1lja, \u00e9s egyben a kont\u00e9ner-vez\u00e9rl\u0151 kapcsolatban a legfels\u0151 szint\u0171 kont\u00e9ner (tartalmaz\u00f3).</p> <p>A fel\u00fclet kialak\u00edt\u00e1sa szempontj\u00e1b\u00f3l az alkalmaz\u00e1sunk lehet:</p> <ul> <li>Dial\u00f3gus alap\u00fa: Kiz\u00e1r\u00f3lag vez\u00e9rl\u0151ket helyez\u00fcnk el az \u0171rlapon, mintha egy dial\u00f3gus ablak lenne. Ha sz\u00fcks\u00e9ges, \u00faj ablakot nyitunk az egyes funkci\u00f3knak. Pl. sokszor ilyenek az \u00fczleti/v\u00e1llalati alkalmaz\u00e1sok.</li> <li>SDI, vagy MDI: Dokumentum alap\u00fa alkalmaz\u00e1s, mely esetben az \u0171rlap a dokumentum megjelen\u00edt\u0151je \u00e9s esetleg szerkeszt\u0151je. Az egy\u00e9b vez\u00e9rl\u0151ket/funkci\u00f3kat a men\u00fcbe \u00e9s a toolbarra (eszk\u00f6zs\u00e1v) tessz\u00fck. Az SDI (Single Document Interface) egy dokumentumot kezel egy id\u0151ben, az MDI (Multiple Document Interface) pedig t\u00f6bbet. Pl. ilyenek sz\u00f6vegszerkeszt\u0151k, vagy maga a Visual Studio is.</li> <li>Vegyes: Az ilyen jelleg\u0171 alkalmaz\u00e1sokban a dokumentum szerkeszt\u00e9se a c\u00e9l csak\u00fagy, mint az SDI/MDI v\u00e1ltozatokban, azonban az ablak egy r\u00e9sze fenn van tartva vez\u00e9rl\u0151k sz\u00e1m\u00e1ra, ahol k\u00f6nnyen el\u00e9rhetj\u00fck a funkci\u00f3kat. Pl. ilyenek a CAD alkalmaz\u00e1sok.</li> </ul>"},{"location":"gyakorlat/felhasznaloi-felulet/#kontener-vezerlo-tartalmazasi-hierarchia","title":"Kont\u00e9ner-vez\u00e9rl\u0151 tartalmaz\u00e1si hierarchia","text":"<p>Egy ablak/\u0171rlap hierarchikus (fa) fel\u00e9p\u00edt\u00e9s\u0171, amelyben a gy\u00f6k\u00e9robjektum maga a <code>Form</code>. L\u00e9nyeges, hogy itt nem sz\u00e1rmaztat\u00e1si, hanem tartalmaz\u00e1si hierarchi\u00e1r\u00f3l van sz\u00f3. Alatta \u00fajabb kont\u00e9nerek lehetnek egym\u00e1sba \u00e1gyazva, vagy csak egym\u00e1s mellett.  A hierarchia alj\u00e1n vannak az egyszer\u0171 vez\u00e9rl\u0151k, de lehetnek vez\u00e9rl\u0151 n\u00e9lk\u00fcli kont\u00e9nerek is.</p> <p>Az egym\u00e1sba \u00e1gyaz\u00e1s az\u00e9rt sz\u00fcks\u00e9ges, hogy egys\u00e9gk\u00e9nt lehessen kezelni a kont\u00e9nereket \u00e9s a gyerekeiket, \u00edgy p\u00e9ld\u00e1ul od\u00e9bb h\u00fazva a kont\u00e9nert vele mozognak az \u00e1ltala tartalmazott vez\u00e9rl\u0151k is. A m\u00e1sik fontos ok a tulajdons\u00e1g\u00f6r\u00f6kl\u00e9s, amely lehet\u0151v\u00e9 teszi, hogy ha megv\u00e1ltoztatjuk valamelyik kont\u00e9ner \u00f6r\u00f6k\u00f6lhet\u0151 tulajdons\u00e1g\u00e1t (pl. <code>Font</code>), akkor azt a gyerekei is meg\u00f6r\u00f6k\u00f6lj\u00e9k. Ez nem a szok\u00e1sos objektum-orient\u00e1lt \u00f6r\u00f6kl\u00e9s, de a sz\u00fcl\u0151-gyermek viszony azonos elvre \u00e9p\u00fcl.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#uzenetkezeles","title":"\u00dczenetkezel\u00e9s","text":"<p>A Windows Forms alap\u00fa alkalmaz\u00e1sok \u00fczenetkezel\u00e9sre \u00e9p\u00fclnek, amelynek a h\u00e1tter\u00e9ben az oper\u00e1ci\u00f3s rendszer \u00fczenetkezel\u0151 mechanizmusa \u00e1ll. Az \u00fczenetkezel\u0151 ciklus a <code>Main</code> f\u00fcggv\u00e9nyben van (<code>Application.Run</code>), amely csak akkor l\u00e9p ki, ha bez\u00e1rjuk az alkalmaz\u00e1sunkat.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#visual-studio-designer","title":"Visual Studio Designer","text":"<p>A designer a felhaszn\u00e1l\u00f3i fel\u00fclet szerkeszt\u0151je, amelyben lehet\u0151s\u00e9g\u00fcnk van \u00faj elemeket felvenni, illetve a megl\u00e9v\u0151ket m\u00f3dos\u00edtani \u00e9s t\u00f6r\u00f6lni. A designer fontosabb elemei/kell\u00e9kei:</p> <ul> <li>Toolbox: Err\u0151l lehet a kont\u00e9nereket \u00e9s vez\u00e9rl\u0151ket r\u00e1h\u00fazni az \u0171rlapra.</li> <li>Properties ablak/Property Editor: A kijel\u00f6lt vez\u00e9rl\u0151 tulajdons\u00e1gait \u00e9s esem\u00e9nyeit mutatja, illetve itt lehet ezeket m\u00f3dos\u00edtani is. Az F4 billenty\u0171vel is el\u00e9rhet\u0151.</li> <li>Smart tag: A legt\u00f6bb vez\u00e9rl\u0151 t\u00edpus eset\u00e9n t\u00e1mogatott. A vez\u00e9rl\u0151t kiv\u00e1lasztva annak jobb fels\u0151 sark\u00e1ban megjelenik egy kis ny\u00edl, amelyre kattintva megjelenik. Ebben n\u00e9h\u00e1ny kiemelt tulajdons\u00e1g \u00e9s k\u00e9nyelmi funkci\u00f3 \u00e9rhet\u0151 el.</li> <li>Document outline ablak: A kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t mutatja. Itt ki lehet jel\u00f6lni az egyes vez\u00e9rl\u0151ket, illetve mozgatni is lehet \u0151ket a hierarchi\u00e1ban, mely \u00e9rv\u00e9nyes\u00fcl az \u0171rlapon is.</li> </ul>"},{"location":"gyakorlat/felhasznaloi-felulet/#2-feladat-menuk-horgonyzas-dokkolas","title":"2. Feladat - Men\u00fck, Horgonyz\u00e1s, Dokkol\u00e1s","text":""},{"location":"gyakorlat/felhasznaloi-felulet/#menuk","title":"Men\u00fck","text":"<p>A fel\u00fclettervez\u00e9s k\u00f6vetkez\u0151 feladata a men\u00fck megszerkeszt\u00e9se. Ehhez v\u00e9gezz\u00fck el a k\u00f6vetkez\u0151 l\u00e9p\u00e9ssorozatot.</p> <ol> <li>A Toolboxr\u00f3l h\u00fazzunk r\u00e1 a <code>Form</code>-ra egy <code>MenuStrip</code>-et (Menus &amp; Toolbars kateg\u00f3ri\u00e1ban van).</li> <li>A <code>MenuStrip</code> smart tag-j\u00e9t kinyitva (kicsi ny\u00edl a jobb fels\u0151 sark\u00e1ban) kattintsunk az Insert Standard Items-re.</li> <li>Ism\u00e9telj\u00fck az els\u0151 k\u00e9t l\u00e9p\u00e9st a <code>ToolStrip</code> vez\u00e9rl\u0151vel is.</li> <li>Majd helyezz\u00fcnk fel alulra egy <code>StatusStrip</code> vez\u00e9rl\u0151t is.</li> </ol> <p>Tesztelj\u00fck az alkalmaz\u00e1st, vegy\u00fck \u00e9szre, hogy a <code>ToolStrip</code>-nek van kis foganty\u00faja, azonban azt hi\u00e1ba fogjuk meg, nem mozog. Ekkor j\u00f6n seg\u00edts\u00e9g\u00fcnkre a <code>ToolStripContainer</code>. A <code>ToolStripContainer</code> egy olyan kont\u00e9ner vez\u00e9rl\u0151, mely \u00f6t panelt tartalmaz: egy Top, Bottom, Left, Right \u00e9s egy k\u00f6z\u00e9pen elhelyezked\u0151 Content panelt.</p> <ol> <li> <p>A men\u00fc smart tag-\u00e9ben v\u00e1lasszuk ki az Embed In ToolStripContainer parancsot, amely feltesz egy <code>ToolStripContainer</code>-t, \u00e9s a men\u00fct \u00e1thelyezi ennek fels\u0151 panelj\u00e9be. Az \u0171rlapunk megjelen\u00e9se kaotikuss\u00e1 v\u00e1lik, mivel a t\u00f6bbi strip egyel\u0151re nem ker\u00fclt a <code>ToolStripContainer</code>-be.</p> </li> <li> <p>A <code>ToolStripContainer</code> smart tag-j\u00e9n v\u00e1lasszuk a Dock Fill in Form funkci\u00f3t. Akkor l\u00e1tsz\u00f3lag minden a hely\u00e9re ker\u00fcl, lesz\u00e1m\u00edtva, hogy a men\u00fc \u00e9s a toolbar fel vannak cser\u00e9lve.</p> <p>Kiv\u00e1laszt\u00e1s a designerben</p> <p>A <code>ToolStripContainer</code> kijel\u00f6l\u00e9se kicsit tr\u00fckk\u00f6s a takar\u00e1si viszonyok miatt. Ehhez haszn\u00e1ljuk a Document Outline ablakot, vagy haszn\u00e1ljuk a context men\u00fc Select men\u00fcpontj\u00e1t.</p> <p></p> </li> <li> <p>Rendezz\u00fck a kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t! Nyissuk meg a Document Outline ablakot (View / Other Windows / Document Outline) \u00e9s korrig\u00e1ljuk a hierarchi\u00e1t:</p> <ul> <li> <p>H\u00fazzuk \u00e1t a <code>ToolStrip</code>-et \u00e9s a <code>StatusStrip</code>-et a <code>ToolStripContainer</code> fels\u0151, illetve als\u00f3 panelj\u00e9be, tov\u00e1bb\u00e1 a <code>TextBox</code> \u00e9s <code>Button</code> vez\u00e9rl\u0151ket <code>ContentPanel</code>-re. A v\u00e9geredm\u00e9ny \u00edgy n\u00e9z ki:</p> <p></p> </li> <li> <p>A <code>MenuStrip</code> smart tag-j\u00e9ben \u00e1ll\u00edtsuk \u00e1t a Grip Style-t Visible-re, ekkor m\u00e1r a men\u00fc is mozgathat\u00f3.</p> </li> </ul> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, a <code>ToolStrip</code> \u00e9s a <code>MenuStrip</code> mozgathat\u00f3 lett (oldalra \u00e9s alulra is).</p> </li> <li> <p>P\u00e9ldak\u00e9nt adjunk esem\u00e9nykezel\u0151t a File/Exit men\u00fcelemhez: dupl\u00e1n klikkelj\u00fcnk a men\u00fcelemen, majd a k\u00f3dban adjuk ki a <code>Close()</code> parancsot, mely bez\u00e1rja az ablakot \u00e9s ezzel le\u00e1ll\u00edtja az alkalmaz\u00e1st.</p> <pre><code>private void exitToolStripMenuItem_Click(object sender, EventArgs e)\n{\nClose();\n}\n</code></pre> </li> <li> <p>Futtassuk \u00e9s tesztelj\u00fck az alkalmaz\u00e1st.</p> </li> </ol>"},{"location":"gyakorlat/felhasznaloi-felulet/#horgonyzas-anchor","title":"Horgonyz\u00e1s (anchor)","text":"<p>Horgonyz\u00e1s, dokkol\u00e1s dem\u00f3k</p> <p>A horgonyz\u00e1shoz \u00e9s dokkol\u00e1shoz GitHub-on a t\u00e1rgy alatt tal\u00e1lhat\u00f3 szeml\u00e9letes dem\u00f3.</p> <ul> <li> <p>Forr\u00e1sk\u00f3d a k\u00f6vetkez\u0151 utas\u00edt\u00e1ssal parancssorb\u00f3l egyszer\u0171en let\u00f6lthet\u0151: </p> <pre><code>git clone https://github.com/bmeviauab00/AnchorAndDockDemo \n</code></pre> </li> <li> <p>Futtathat\u00f3 verzi\u00f3 a download gombbal t\u00f6lthet\u0151 le.</p> </li> </ul> <p>Anchor: A horgonyz\u00e1s seg\u00edts\u00e9g\u00e9vel el\u00e9rhet\u0151, hogy a vez\u00e9rl\u0151 adott oldala \u00e1lland\u00f3 t\u00e1vols\u00e1got tartson a sz\u00fcl\u0151 kont\u00e9ner ugyanazon oldal\u00e1t\u00f3l. Egy vez\u00e9rl\u0151re egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl be\u00e1ll\u00edthat\u00f3 a fel\u00fclre, alulra, balra \u00e9s jobbra horgonyz\u00e1s. Ha pl. a jobbra horgonyz\u00e1s be van \u00e1ll\u00edtva egy vez\u00e9rl\u0151re, akkor a jobb oldala fix t\u00e1vols\u00e1got tart a kont\u00e9ner\u00e9nek jobb oldal\u00e1t\u00f3l. Ez a kont\u00e9ner \u00e1tm\u00e9retez\u00e9sekor v\u00e1lik l\u00e1that\u00f3v\u00e1: amikor a kont\u00e9ner jobb oldala fut\u00e1s k\u00f6zben az \u00e1tm\u00e9retez\u00e9s sor\u00e1n elmozdul, akkor a tartalmazott vez\u00e9rl\u0151 jobb oldala ezt automatikusan lek\u00f6veti, a t\u00e1vols\u00e1g a kett\u0151 k\u00f6z\u00f6tt \u00e1lland\u00f3 marad. Ugyanez \u00e1ll fent a jobbra, fel\u00fclre \u00e9s alulra horgonyz\u00e1s eset\u00e9n is (\u00e9rtelemszer\u0171en a jobb, fels\u0151 \u00e9s als\u00f3 oldalakra vonatkoztatva). Alap\u00e9rtelmez\u00e9sben a vez\u00e9rl\u0151k bal oldala \u00e9s teteje van lehorgonyozva. Ha k\u00e9t ellent\u00e9tes oldal is le van horgonyozva (p\u00e9ld\u00e1ul a bal \u00e9s a jobb oldal), akkor a sz\u00fcl\u0151 v\u00edzszintes \u00e1tm\u00e9retez\u00e9sekor a vez\u00e9rl\u0151 n\u0151ni vagy zsugorodni fog, hogy a k\u00e9t sz\u00e9le megtartsa a t\u00e1vols\u00e1got a sz\u00fcl\u0151 sz\u00e9leit\u0151l.</p> <p>T\u00e9rj\u00fcnk vissza az alkalmaz\u00e1sunkhoz:</p> <ol> <li> <p>H\u00fazzuk be az els\u0151 feladatban l\u00e9trehozott gombot a form k\u00f6zep\u00e9re (de egy \u00fajat is feldobhatunk).</p> </li> <li> <p>A Property Editor-ban keress\u00fck ki \u00e9s nyissuk le az <code>Anchor</code> tulajdons\u00e1got.</p> </li> </ol> <p>A tulajdons\u00e1g \u00e9rt\u00e9ke val\u00f3j\u00e1ban egyszer\u0171 enum, melyhez a Visual Studio az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt egy grafikus n\u00e9zetet ad. Figyelj\u00fck meg, hogy jelenleg a vez\u00e9rl\u0151 bal oldala \u00e9s teteje van a sz\u00fcl\u0151j\u00e9hez k\u00f6tve.</p> <ol> <li> <p>Az <code>Anchor</code> szerkeszt\u0151j\u00e9ben kattintsunk a jobb oldali horgonyra is. \u00cdgy m\u00e1r h\u00e1rom oldal\u00e1t r\u00f6gz\u00edtett\u00fck a gombnak.</p> </li> <li> <p>Tesztelj\u00fck a v\u00e1ltoztat\u00e1s hat\u00e1s\u00e1t!</p> <p>Mivel a horgonyok m\u00e1r tervez\u00e9si id\u0151ben is m\u0171k\u00f6dnek, ehhez az alkalmaz\u00e1st sem kell elind\u00edtani. El\u00e9g a tervez\u00e9si n\u00e9zetben \u00e1tm\u00e9retezni a formot. Figyelj\u00fck meg, hogy imm\u00e1r a gomb jobb oldala egy\u00fctt mozog a form jobb sz\u00e9l\u00e9vel!</p> </li> <li> <p>M\u00f3dos\u00edtsuk a horgonyt \u00fagy, hogy a jobb \u00e9s az als\u00f3 oldala legyen r\u00f6gz\u00edtve a gombnak, a teteje \u00e9s a bal oldala nem. Tesztelj\u00fck a megold\u00e1st!</p> <p>Ut\u00f3bbi megold\u00e1s haszn\u00e1lhat\u00f3 p\u00e9ld\u00e1ul arra, hogy egy dial\u00f3gusablak bez\u00e1r\u00f3 gombj\u00e1t mindig a jobb als\u00f3 sarokban tartsuk.</p> </li> <li> <p>A gombra a tov\u00e1bbiakban nem lesz sz\u00fcks\u00e9g\u00fcnk, t\u00f6r\u00f6lj\u00fck a fel\u00fcletr\u0151l.</p> </li> </ol>"},{"location":"gyakorlat/felhasznaloi-felulet/#dokkolas-dock","title":"Dokkol\u00e1s (dock)","text":"<p>Dock: A dokkol\u00e1s (szok\u00e1s m\u00e9g csatol\u00e1snak vagy ragaszt\u00e1snak is nevezni) seg\u00edts\u00e9g\u00e9vel egy vez\u00e9rl\u0151 hozz\u00e1csatolhat\u00f3 az \u0151t tartalmaz\u00f3 kont\u00e9ner valamelyik sz\u00e9l\u00e9hez, vagy be\u00e1ll\u00edthat\u00f3, hogy t\u00f6ltse ki a rendelkez\u00e9sre \u00e1ll\u00f3 helyet. Lehets\u00e9ges \u00e9rt\u00e9kei: <code>None</code>, <code>Top</code>, <code>Left</code>, <code>Right</code>, <code>Bottom</code> \u00e9s <code>Fill</code>. Egy fel\u00fclre vagy alulra dokkolt vez\u00e9rl\u0151 a sz\u00fcl\u0151 \u00e1tm\u00e9retez\u00e9sekor megtartja a magass\u00e1g\u00e1t, a sz\u00e9less\u00e9gv\u00e1ltoz\u00e1st pedig lek\u00f6veti (pl. egy men\u00fc vagy st\u00e1tuszs\u00e1v tipikusan \u00edgy viselkedik). Ahhoz, hogy egy vez\u00e9rl\u0151 kit\u00f6ltse a teljes marad\u00f3 teret, a dokkol\u00e1st <code>Fill</code>-re kell \u00e1ll\u00edtani.</p> <p>Itt is \u00e9rdemes a GitHub dem\u00f3t futtatva, az \u0171rlapot \u00e1tm\u00e9retezve kipr\u00f3b\u00e1lni, \u00edme a k\u00e9p az \u0171rlap \u00e1tm\u00e9retez\u00e9se el\u0151tt \u00e9s ut\u00e1n:</p> <p></p> <p>\u00c1tm\u00e9retez\u00e9s ut\u00e1n (sz\u00e9lesebbre \u00e9s alacsonyabbra m\u00e9retezve az ablakot):</p> <p></p>"},{"location":"gyakorlat/felhasznaloi-felulet/#3-feladat-miniexplorer","title":"3. Feladat - MiniExplorer","text":""},{"location":"gyakorlat/felhasznaloi-felulet/#miniexplorer-layout","title":"MiniExplorer layout","text":"<p>A feladat sor\u00e1n egy Windows Forms alap\u00fa f\u00e1jlrendszer b\u00f6ng\u00e9sz\u0151 (MiniExplorer) alkalmaz\u00e1st kell elk\u00e9sz\u00edteni. A program kin\u00e9zet\u00e9t a k\u00f6vetkez\u0151 \u00e1bra szeml\u00e9lteti. </p> <p></p> <p>Az ablak h\u00e1rom r\u00e9szb\u0151l \u00e1lljon:</p> <ul> <li>c\u00edmsor az ablak tetej\u00e9n (<code>TextBox</code>)</li> <li><code>TreeView</code> a c\u00edmsor alatt bal oldalon</li> <li><code>ListView</code> a c\u00edmsor alatt jobb oldalon</li> </ul> <p>A c\u00edmsorban mindig az aktu\u00e1lisan kiv\u00e1lasztott mappa teljes el\u00e9r\u00e9si \u00fatvonal\u00e1t l\u00e1thatjuk. Kezdetben legyenek a csom\u00f3pontok \u00f6sszecsukott \u00e1llapotban (\u201e+\u201d ikon mellett\u00fck a f\u00e1ban), lenyitva \u0151ket jelenjenek meg a gyerek csom\u00f3pontok, ha van mappa az adott mapp\u00e1n bel\u00fcl. Elfogadhat\u00f3, hogy el\u0151sz\u00f6r minden csom\u00f3pont lenyithat\u00f3, \u00e9s csak akkor t\u0171nik el a lenyit\u00e1sra/\u00f6sszecsuk\u00e1sra szolg\u00e1l\u00f3 ikon, ha a felhaszn\u00e1l\u00f3 megpr\u00f3b\u00e1lta lenyitni \u00e9s nincs benne mappa. Ha a felhaszn\u00e1l\u00f3 kiv\u00e1laszt egy mapp\u00e1t a <code>TreeView</code>-ban (itt nem a lenyit/\u00f6sszecsuk m\u0171veletre kell gondolni), akkor a <code>ListView</code>-ban jelenjenek meg a mapp\u00e1ban tal\u00e1lhat\u00f3 f\u00e1jlok. A <code>ListView</code> h\u00e1rom oszlopban jelen\u00edtse meg a f\u00e1jlok nev\u00e9t, m\u00e9ret\u00e9t \u00e9s az utols\u00f3 m\u00f3dos\u00edt\u00e1s d\u00e1tum\u00e1t.</p> <ol> <li>V\u00e1lasszuk ki a formon l\u00e9v\u0151 <code>TextBox</code>-ot (melyet az els\u0151 p\u00e9ld\u00e1ban raktunk ki), \u00e9s \u00e1ll\u00edtsuk a <code>Dock</code> tulajdons\u00e1g\u00e1t <code>Top</code>-ra. Ezzel a c\u00edmsort az ablak tetej\u00e9hez igaz\u00edtottuk.</li> <li> <p>Tegy\u00fcnk a formra egy <code>SplitContainer</code>-t (ToolBox / Containers).</p> <p>SplitContainer</p> <p>SplitContainer: Figyelj\u00fck meg, hogy ez egy speci\u00e1lis vez\u00e9rl\u0151, mely k\u00e9t egym\u00e1s mell\u00e9 rendezett panelb\u0151l \u00e1ll \u00e9s lehet\u0151s\u00e9get ad a panelok k\u00f6zti ar\u00e1ny v\u00e1ltoztat\u00e1s\u00e1ra. Ez egy olyan kont\u00e9ner t\u00edpus\u00fa vez\u00e9rl\u0151, mely az \u0151t tartalmaz\u00f3 kont\u00e9nert k\u00e9t panelre osztja f\u00fcgg\u0151leges vagy v\u00edzszintes ir\u00e1nyban. A k\u00e9t panel k\u00f6z\u00e9 egy splittert helyez el, mellyel ak\u00e1r fut\u00e1sid\u0151ben is \u00e1tm\u00e9retezhet\u0151 a k\u00e9t panel. A splitter mozgat\u00e1sa letilthat\u00f3, \u00e9s a k\u00e9t panel k\u00f6z\u00fcl az egyikre be\u00e1ll\u00edthat\u00f3, hogy a sz\u00fcl\u0151 kont\u00e9ner m\u00e9retez\u00e9sekor a megadott panel m\u00e9rete ne v\u00e1ltozzon. (Fixed nev\u0171 tulajdons\u00e1gokn\u00e1l \u00e9rdemes keresni.)</p> </li> <li> <p>A SplitContainer elvileg m\u00e1r <code>Fill</code> Dock m\u00f3don ker\u00fclt fel az el\u0151z\u0151 l\u00e9p\u00e9sben (kit\u00f6lti a teret). Ha m\u00e9gsem \u00edgy lenne: v\u00e1lasszuk ki a Dock in parent container opci\u00f3t a SplitPanel smart tag-j\u00e9ben!</p> </li> <li>A bal oldali panel-re rakjunk r\u00e1 egy <code>TreeView</code> vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk a Dock in parent container funkci\u00f3t.</li> <li>A jobb oldali panelre rakjunk egy <code>ListView</code> vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk itt is a Dock in parent container funkci\u00f3t.</li> </ol> <p>Ezzel el is k\u00e9sz\u00fclt a MiniExplorer, legal\u00e1bbis a fel\u00fclete.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#miniexplorer-logika","title":"MiniExplorer logika","text":"<p>Mivel k\u00e9szen van a fel\u00fclet, a k\u00f6vetkez\u0151 feladat azt kit\u00f6lteni.</p> <ol> <li> <p>Dupl\u00e1n klikkelj\u00fcnk a form fejl\u00e9c\u00e9n, ezzel tudjuk implement\u00e1lni a <code>Form.Load</code> esem\u00e9ny\u00e9t. Itt fogjuk inicializ\u00e1lni a f\u00e1t:</p> <pre><code>private void MainForm_Load(object sender, EventArgs e)\n{\nvar root = treeView1.Nodes.Add(\"Local Disk (C:)\");\nroot.Tag = new DirectoryInfo(@\"C:\\\");\nroot.Nodes.Add(\"\");\n}\n</code></pre> <p>A <code>TreeView</code> vez\u00e9rl\u0151 <code>TreeNode</code> objektumokat tud megjelen\u00edteni (ezek a fa csom\u00f3pontjait jelk\u00e9pezik). A t\u00e9nyleges inform\u00e1ci\u00f3t (vagyis, hogy melyik k\u00f6nyvt\u00e1r tartozik hozz\u00e1) a <code>TreeNode</code> <code>Tag</code> tulajdons\u00e1gban t\u00e1roljuk el. Ez egy <code>object</code> t\u00edpus\u00fa tulajdons\u00e1g, amivel a legt\u00f6bb vez\u00e9rl\u0151 rendelkezik, \u00e9s pont azt a c\u00e9lt szolg\u00e1lja, hogy a fejleszt\u0151k tetsz\u0151leges, sz\u00e1mukra relev\u00e1ns \u00e9s az adott vez\u00e9rl\u0151h\u00f6z k\u00f6t\u0151d\u0151 inform\u00e1ci\u00f3t t\u00e1roljanak benne. A megold\u00e1sunkban a csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r inform\u00e1ci\u00f3t t\u00e1roljuk el benne egy <code>DirectoryInfo</code> objektum form\u00e1j\u00e1ban. R\u00f6videsen megl\u00e1tjuk, mi\u00e9rt van erre sz\u00fcks\u00e9g.</p> <p>A f\u00fcggv\u00e9ny utols\u00f3 sor\u00e1ban l\u00e9trehozunk egy \u201e\u00fcres\u201d gyerek csom\u00f3pontot. Ennek k\u00f6sz\u00f6nhet\u0151en a sz\u00fcl\u0151 mellett meg fog jelenni a kibont\u00e1s jele (+).</p> </li> <li> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a csom\u00f3pontok kibont\u00e1s\u00e1t val\u00f3s\u00edtjuk meg: amikor a felhaszn\u00e1l\u00f3 kibont (expand) egy csom\u00f3pontot, le kell k\u00e9rdezz\u00fck a csom\u00f3pont \u00e1ltal reprezent\u00e1lt k\u00f6nyvt\u00e1rban tal\u00e1lhat\u00f3 alk\u00f6nyvt\u00e1rakat, \u00e9s a lenyitott <code>TreeNode</code> csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r minden alk\u00f6nyvt\u00e1rhoz egy gyerek <code>TreeNode</code> csom\u00f3pontot kell felvegy\u00fcnk. Egy csom\u00f3pont kibont\u00e1s\u00e1r\u00f3l a <code>TreeView</code> vez\u00e9rl\u0151 a <code>BeforeExpand</code> \u00e9s <code>AfterExpand</code> esem\u00e9nyekben \u00e9rtes\u00edt. Sz\u00e1munkra most a <code>BeforeExpand</code> a megfelel\u0151 v\u00e1laszt\u00e1s. Azt, hogy melyik csom\u00f3pont ker\u00fclt kibont\u00e1sra, az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg. Azt pedig, hogy melyik k\u00f6nyvt\u00e1r tartozik egy csom\u00f3ponthoz, a <code>TreeNode</code> <code>Tag</code> tulajdons\u00e1g\u00e1ban mi magunk t\u00e1roljuk el!</p> <p>Menj\u00fcnk vissza a designer-be, v\u00e1lasszuk ki a <code>TreeView</code>-t, majd a Properties ablakban v\u00e1ltsunk esem\u00e9ny n\u00e9zetre (vill\u00e1m ikon). Dupl\u00e1n klikkelj\u00fcnk a <code>BeforeExpand</code> esem\u00e9nyen, hogy implement\u00e1lhassuk:</p> <pre><code>private void treeView1_BeforeExpand(object sender, TreeViewCancelEventArgs e)\n{\nvar parentDI = e.Node?.Tag as DirectoryInfo;\nif (parentDI == null)\nreturn;\n\ne.Node?.Nodes.Clear();\ntry\n{\nforeach (var di in parentDI.GetDirectories())\n{\nvar node = new TreeNode(di.Name);\nnode.Tag = di;\nnode.Nodes.Add(\"\");\ne.Node?.Nodes.Add(node);\n}\n}\ncatch\n{\n// lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa\n}\n}\n</code></pre> <p>A <code>?.</code> oper\u00e1tor</p> <p>A <code>?.</code>, vagyis a null-conditional oper\u00e1tor m\u0171k\u00f6d\u00e9se hasonl\u00f3 a klasszikus <code>.</code>, vagyis taghozz\u00e1f\u00e9r\u00e9s oper\u00e1torhoz, de a taghozz\u00e1f\u00e9r\u00e9s csak akkor t\u00f6rt\u00e9nik meg, ha a kifejez\u00e9s bal oldala nem null (egy\u00e9bk\u00e9nt pedig a kifejez\u00e9s \u00e9rt\u00e9ke null lesz). Tulajdonk\u00e9ppen ezt haszn\u00e1ltuk kor\u00e1bban a C# esem\u00e9nyek felt\u00e9teles els\u00fct\u00e9sekor az <code>&lt;esem\u00e9ny&gt;?.Invoke()</code> sor\u00e1n is.</p> </li> <li> <p>Tesztelj\u00fck az alkalmaz\u00e1st.</p> </li> <li> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t a jobboldali panel megval\u00f3s\u00edt\u00e1s\u00e1ra.</p> <p>Itt akkor kell a tartalmat friss\u00edteni, amikor (pontosabban miut\u00e1n) a baloldali <code>TreeView</code>-ban a felhaszn\u00e1l\u00f3 kiv\u00e1lasztott egy csom\u00f3pontot. Err\u0151l a <code>TreeView</code> az <code>AfterSelect</code> esem\u00e9ny\u00e9ben k\u00fcld \u00e9rtes\u00edt\u00e9st. A kor\u00e1bbihoz hasonl\u00f3an a kiv\u00e1lasztott <code>TreeNode</code> csom\u00f3pontot az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg.</p> <pre><code>private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)\n{\nvar parentDI = e.Node?.Tag as DirectoryInfo;\nif (parentDI == null)\nreturn;\n\nlistView1.Items.Clear();\ntry\n{\nforeach (FileInfo fi in parentDI.GetFiles())\n{\nlistView1.Items.Add(fi.Name);\n}\n}\ncatch\n{\n// lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa\n}\n}\n</code></pre> <p>Hibakezel\u00e9s</p> <p>Vegy\u00fck \u00e9szre, hogy a fenti k\u00e9t f\u00fcggv\u00e9nyben mindk\u00e9t esetben egy try-catch blokkot haszn\u00e1ltunk. Ez az\u00e9rt van, mert a laborg\u00e9peken \u00e1tlagos felhaszn\u00e1l\u00f3k\u00e9nt sokszor nincs jogunk egyes mapp\u00e1k/f\u00e1jlok el\u00e9r\u00e9s\u00e9re, ami a list\u00e1z\u00f3 f\u00fcggv\u00e9nyek eset\u00e9ben kiv\u00e9telt v\u00e1lt ki. Egy val\u00f3s alkalmaz\u00e1sban semmik\u00e9ppen nem hagyn\u00e1nk \u00fcresen a <code>catch</code> blokkot, mindenk\u00e9ppen napl\u00f3zn\u00e1nk, vagy a felhaszn\u00e1l\u00f3 tudom\u00e1s\u00e1ra hozn\u00e1nk a hib\u00e1t.</p> <p>A legegyszer\u0171bb <code>MessageBox</code> alap\u00fa megold\u00e1s ez lenne:</p> <pre><code>catch (UnauthorizedAccessException ex)\n{\nMessageBox.Show(ex.Message, \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error))\n}\n</code></pre> </li> <li> <p>Ugyanitt ki tudjuk t\u00f6lteni az Address r\u00e9szt is:</p> <pre><code>tbDemoText.Text = parentDI.FullName;\n</code></pre> </li> <li> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtsuk meg a t\u00f6bboszlopos n\u00e9zetet a jobboldali panelen. A k\u00f3dot m\u00f3dos\u00edtsuk \u00fagy, hogy ne csak a nev\u00e9t adja meg a f\u00e1jlnak, hanem egy\u00e9b param\u00e9tereit is. Az <code>Add</code> f\u00fcggv\u00e9nyt param\u00e9terezz\u00fck \u00edgy:</p> <pre><code>listView1.Items.Add(\nnew ListViewItem(new string[]\n{\nfi.Name,\nfi.Length.ToString(),\nfi.LastWriteTime.ToString(),\nfi.FullName\n}));\n</code></pre> </li> <li> <p>Az adatok teh\u00e1t m\u00e1r megvannak, de m\u00e9g nem jelennek meg. Ehhez a <code>ListView</code>-t m\u00f3dos\u00edtani kell a designer-ben, hogy mutassa a r\u00e9szleteket is. Hozzuk el\u0151 a smart tag-j\u00e9t, \u00e9s \u00e1ll\u00edtsuk \u00e1t rajta a View-t Details-re.</p> </li> <li> <p>Az oszlopokat nek\u00fcnk kell l\u00e9trehoznunk, amihez a smart tag-j\u00e9ben v\u00e1lasszuk az Edit Columns funkci\u00f3t, majd a megjelen\u0151 list\u00e1t t\u00f6lts\u00fck fel 3 \u00faj elemmel, amelyeknek a <code>Text</code> tulajdons\u00e1ga legyen: <code>Name</code>, <code>Size</code>, <code>Modified</code>.</p> <p>Rendezz\u00fck el sz\u00e9pen az oszlopok sz\u00e9less\u00e9g\u00e9t olyan m\u00f3don, hogy minden kif\u00e9rjen majd a felt\u00f6lt\u00e9s ut\u00e1n is. Ezekben az oszlopokban az adatok pont olyan sorrendben fognak megjelenni, mint ahogy a 6. pontban a listaelemhez hozz\u00e1rendelt\u00fck azokat.</p> </li> </ol> <p>ListView oszlopok</p> <p>Sajnos a <code>ListView</code> be\u00e9p\u00edtetten el\u00e9g t\u00f6r\u00e9keny megold\u00e1st ny\u00fajt csak az oszlopok \u00e9s azok \u00e9rt\u00e9keinek \u00f6sszerendel\u00e9s\u00e9re. A modernebb UI keretrendszerek (pl.: WPF, WinUI, .NET MAUI) az adatk\u00f6t\u00e9s mechanizmus\u00e1n kereszt\u00fcl egy k\u00e9nyelmesebb, deklarat\u00edvabb \u00e9s robusztusabb megold\u00e1st ny\u00fajtanak erre.</p>"},{"location":"gyakorlat/felhasznaloi-felulet/#futtatas","title":"Futtat\u00e1s","text":"<p>Utols\u00f3 \u00e9rdekess\u00e9gk\u00e9nt megoldhatjuk, hogy a jobb oldali n\u00e9zetben egy f\u00e1jlon dupl\u00e1n kattintva a rendszer megnyissa/v\u00e9grehajtsa azt. Ehhez iratkozzunk fel a <code>ListView</code> <code>DoubleClick</code> esem\u00e9ny\u00e9re \u00e9s val\u00f3s\u00edtsuk meg a k\u00f6vetkez\u0151k\u00e9ppen:</p> <pre><code>private void listView1_DoubleClick(object sender, EventArgs e)\n{\nif (listView1.SelectedItems.Count != 1)\nreturn;\n\nvar fullName = listView1.SelectedItems[0].SubItems[3].Text;\nif (fullName != null)\n{\nProcess.Start(new ProcessStartInfo(fullName) { UseShellExecute = true });\n}\n}\n</code></pre>"},{"location":"gyakorlat/felhasznaloi-felulet/#windows-stilusok-nem-tanagyag","title":"Windows st\u00edlusok (nem tanagyag)","text":"<p>Ha zavar minket, hogy nem a rendszer st\u00edlus\u00e1t haszn\u00e1lj\u00e1k a <code>TreeView</code> \u00e9s a <code>ListView</code> vez\u00e9rl\u0151k, akkor a <code>SetWindowTheme</code> Win32 API f\u00fcggv\u00e9nyt megh\u00edvva ki tudjuk k\u00e9nyszer\u00edteni, hogy a File Explorer/F\u00e1jlkezel\u0151 alkalmaz\u00e1sban megszokott st\u00edlusban jelenjenek meg.</p> <pre><code>[DllImport(\"uxtheme.dll\", ExactSpelling = true, CharSet = CharSet.Unicode)]\nprivate static extern int SetWindowTheme(IntPtr hwnd, string pszSubAppName, string? pszSubIdList);\nprivate void MainForm_Load(object sender, EventArgs e)\n{\nvar root = treeView1.Nodes.Add(\"Local Disk (C:)\");\nroot.Tag = new DirectoryInfo(@\"C:\\\");\nroot.Nodes.Add(\"\");\n\nSetWindowTheme(treeView1.Handle, \"explorer\", null);\nSetWindowTheme(listView1.Handle, \"explorer\", null);\n// Elt\u00fcnteti a csom\u00f3pontokat \u00f6sszek\u00f6t\u0151 vonalakat\ntreeView1.ShowLines = false;\n}\n</code></pre> <p>A megold\u00e1sunkban a .NET platform \u00fan. P/Invoke (Platform Invoke) mechanizmus\u00e1t vetj\u00fck be. Ez lehet\u0151v\u00e9 teszi, hogy a <code>DllImport</code> attrib\u00fatummal nat\u00edv DLL-ekb\u0151l f\u00fcggv\u00e9nyeket hivatkozzunk be, megfelel\u0151 param\u00e9terez\u00e9s\u0171 statikus C# f\u00fcggv\u00e9nydeklar\u00e1ci\u00f3khoz rendelj\u00fck, majd ezek seg\u00edts\u00e9g\u00e9vel a nat\u00edv f\u00fcggv\u00e9nyeket megh\u00edvjuk. A <code>SetWindowTheme</code> f\u00fcggv\u00e9ny els\u0151 param\u00e9terek\u00e9nt a vez\u00e9rl\u0151 <code>Handle</code>-j\u00e9t kell \u00e1tadni, m\u00e1sodik param\u00e9terek\u00e9nt pedig a process nev\u00e9t, amelyr\u0151l m\u00e1solni akarjuk a st\u00edlusokat. A fenti k\u00f3d utols\u00f3 sor\u00e1ban a <code>treeView1.ShowLines</code> <code>false</code>-ra \u00e1ll\u00edt\u00e1s\u00e1val kikapcsoljuk a fastrukt\u00far\u00e1ban az \u00f6sszek\u00f6t\u0151 vonalak alkalmaz\u00e1s\u00e1t. \u00cdme a v\u00e9geredm\u00e9ny:</p> <p></p>"},{"location":"gyakorlat/nyelvi-eszkozok/","title":"Nyelvi eszk\u00f6z\u00f6k","text":""},{"location":"gyakorlat/nyelvi-eszkozok/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k:</p> <ul> <li>Tulajdons\u00e1g (property)</li> <li>Deleg\u00e1t (delegate, met\u00f3dusreferencia)</li> <li>Esem\u00e9ny (event)</li> <li>Attrib\u00fatum (attribute)</li> <li>Lambda kifejez\u00e9s (lambda expression)</li> <li>Generikus t\u00edpus (generic type)</li> <li>N\u00e9h\u00e1ny tov\u00e1bbi nyelvi konstrukci\u00f3</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Nyelvi eszk\u00f6z\u00f6k.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Gyakorlat Linuxon vagy macOS alatt</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de az elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is m\u00e1s fejleszt\u0151eszk\u00f6z\u00f6kkel (pl. VS Code, Rider, Visual Studio for Mac), vagy ak\u00e1r egy sz\u00f6vegszerkeszt\u0151vel \u00e9s CLI (parancssori) eszk\u00f6z\u00f6kkel. Ezt az teszi lehet\u0151v\u00e9, hogy a p\u00e9ld\u00e1k egy egyszer\u0171 Console alkalmaz\u00e1s kontextus\u00e1ban ker\u00fclnek ismertet\u00e9sre (nincsenek Windows specifikus elemek),  a .NET 8 SDK pedig t\u00e1mogatott Linuxon \u00e9s macOS alatt. Hello World Linuxon</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#bevezeto","title":"Bevezet\u0151","text":"<p>Kitekint\u0151 r\u00e9szek</p> <p>Jelen \u00fatmutat\u00f3 t\u00f6bb helyen is b\u0151v\u00edtett ismeretanyagot, illetve extra magyar\u00e1zatot ad meg jelen megjegyz\u00e9ssel egyez\u0151 sz\u00ednnel keretezett \u00e9s ugyanilyen ikonnal ell\u00e1tott form\u00e1ban. Ezek hasznos kitekint\u00e9sek, de nem k\u00e9pezik az alap tananyag r\u00e9sz\u00e9t.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-nyelvieszkozok-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#0-feladat-var-kulcsszo-implicit-tipusu-lokalis-valtozok-implicitly-typed-local-variables","title":"0. Feladat - var kulcssz\u00f3 - Implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3k (implicitly typed local variables)","text":"<p>Egy egyszer\u0171, bemeleg\u00edt\u0151 feladattal kezd\u00fcnk. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l.</p> <ol> <li>Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET alap\u00fat (vagyis ne .NET Framework-\u00f6set):<ul> <li>Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel.</li> <li>A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n.</li> </ul> </li> <li>Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz <code>Person</code> n\u00e9ven.     (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az Add / Class men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk <code>Person.cs</code>-re, majd nyomjuk meg az Add gombot.)</li> <li> <p>Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a <code>public</code> kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor egy k\u00e9s\u0151bbi feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni.</p> <pre><code>public class Person\n{\n\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat.</p> <pre><code>static void Main(string[] args)\n{\nPerson p = new Person();\n}\n</code></pre> </li> <li> <p>A lok\u00e1lis v\u00e1ltoz\u00f3k t\u00edpus\u00e1nak explicit megad\u00e1sa helyett haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t is:</p> <pre><code>static void Main(string[] args)\n{\nvar p = new Person();\n}\n</code></pre> <p>Ezt implicitly typed local variables-nek, magyarul implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3-nak nevezz\u00fck. Ilyenkor a ford\u00edt\u00f3 a kontextusb\u00f3l, az egyenl\u0151s\u00e9gjel jobb oldal\u00e1b\u00f3l megpr\u00f3b\u00e1lja kital\u00e1lni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t, fenti esetben ez egy <code>Person</code> lesz. Fontos, hogy ett\u0151l a nyelv m\u00e9g statikusan tipusos marad (teh\u00e1t nem \u00fagy m\u0171k\u00f6dik mint a JavaScript-es <code>var</code> kulcssz\u00f3), mert a <code>p</code> v\u00e1ltoz\u00f3 t\u00edpusa a k\u00e9s\u0151bbiekben nem v\u00e1ltozhat meg, ez csak egy egyszer\u0171 szintaktikai \u00e9des\u00edt\u0151szer annek \u00e9rdek\u00e9ben, hogy t\u00f6m\u00f6rebben tudjunk lok\u00e1lis v\u00e1ltoz\u00f3kat defini\u00e1lni (ne kelljen a t\u00edpust \"dupl\u00e1n\", az <code>=</code> bal \u00e9s jobb oldal\u00e1n is megadni).</p> <p>Target-typed <code>new</code> expressions</p> <p>Egy m\u00e1sik megk\u00f6zel\u00edt\u00e9s lehet a a C# 9-ben megjelent Target-typed <code>new</code> expressions, ahol a new oper\u00e1tor eset\u00e9n hagyhat\u00f3 el a t\u00edpus, ha az a ford\u00edt\u00f3 \u00e1ltal kital\u00e1lhat\u00f3 a kontektusb\u00f3l (pl.: \u00e9rt\u00e9kad\u00e1s bal oldala, param\u00e9ter t\u00edpusa, stb.). A fenti <code>Person</code> konstruktorunk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9zne ki:</p> <pre><code>Person p = new();\n</code></pre> <p>Ennek a megk\u00f6zel\u00edt\u00e9snek az el\u0151nye a <code>var</code>-ral szemben, hogy tagv\u00e1ltoz\u00f3k eset\u00e9ben is alkalmazhat\u00f3. Fontos, hogy ezt ne keverj\u00fck \u00f6ssze a C# anon\u00edm t\u00edpusaival (<code>new {}</code>, kerekz\u00e1r\u00f3jel n\u00e9lk\u00fcl), mely t\u00e9mak\u00f6rt ez a tant\u00e1rgy nem fog \u00e9rinteni.</p> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#1-feladat-tulajdonsag-property","title":"1. Feladat \u2013 Tulajdons\u00e1g (property)","text":"<p>A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de mint l\u00e1tni fogjuk, nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktika tekintet\u00e9ben hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t, s\u0151t k\u00fcl\u00f6n k\u00fcl\u00f6n is meghat\u00e1rozhatjuk a lek\u00e9rdez\u00e9s \u00e9s a be\u00e1ll\u00edt\u00e1s l\u00e1that\u00f3s\u00e1g\u00e1t.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#tulajdonsag-szintaktikaja","title":"Tulajdons\u00e1g szintaktik\u00e1ja","text":"<p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, <code>name</code> \u00e9s <code>age</code>. A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a <code>Name</code>, illetve <code>Age</code> publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert <code>SetX(\u2026)</code> illetve <code>GetX()</code> t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott.</p> <ol> <li> <p>Az el\u0151z\u0151 feladatban bevezetett <code>Person</code> oszt\u00e1lyon bel\u00fcl hozzunk l\u00e9tre egy <code>int</code> t\u00edpus\u00fa <code>age</code> nev\u0171 tagv\u00e1ltoz\u00f3t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 <code>Age</code> tulajdons\u00e1got.</p> <pre><code>public class Person\n{\nprivate int age;\npublic int Age\n{\nget { return age; }\nset { age = value; }\n}\n}\n</code></pre> <p>Visual Studio snippetek</p> <p>A laboron ugyan a gyakorl\u00e1s kedv\u00e9\u00e9rt k\u00e9zzel g\u00e9pelt\u00fck be a teljes tulajdons\u00e1got, de a Visual Studio-ban a gyakran el\u0151fordul\u00f3 k\u00f3dr\u00e9szletek l\u00e9trehoz\u00e1s\u00e1ra \u00fagynevezett code snippetek \u00e1llnak rendelkez\u00e9s\u00fcnkre, melyekkel a gyakori nyelvi konstrukci\u00f3kat tudjuk sablonszer\u0171en felhaszn\u00e1lni. A fenti property k\u00f3dr\u00e9szletet a <code>propfull</code> snippettel tudjuk el\u0151csalni. G\u00e9pelj\u00fck be a snippet nev\u00e9t (<code>propfull</code>), majd addig nyomjuk a Tab billenty\u0171t am\u00edg a snippet nem aktiv\u00e1l\u00f3dik (tipikusan 2x).</p> <p>Eml\u00edt\u00e9sre m\u00e9lt\u00f3 egy\u00e9b snippetek a teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl:</p> <ul> <li><code>ctor</code>: konstruktor</li> <li><code>for</code>: for ciklus</li> <li><code>foreach</code>: foreach ciklus</li> <li><code>prop</code>: auto property (l\u00e1sd k\u00e9s\u0151bb)</li> <li><code>switch</code>: switch utas\u00edt\u00e1s</li> <li><code>cw</code>: Console.WriteLine</li> </ul> <p>Ilyen snippeteket egy\u00e9bk\u00e9nt mi is k\u00e9sz\u00edthet\u00fcnk.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj tulajdons\u00e1gunkat.</p> <pre><code>static void Main(string[] args)\n{\nvar p = new Person();\np.Age = 17;\np.Age++;\nConsole.WriteLine(p.Age);\n}\n</code></pre> </li> <li> <p>Futtassuk a programunkat (F5)</p> <p>L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>get</code> r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>set</code> r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis <code>value</code> v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel.</p> <p>Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a <code>p.setAge(p.getAge() + 1)</code> form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok/lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l.</p> </li> <li> <p>Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a <code>get</code> \u00e9s <code>set</code> r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva.</p> </li> <li> <p>Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st.</p> <p>L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik.</p> </li> <li> <p>A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az <code>Age</code> tulajdons\u00e1g setter-\u00e9t.</p> <pre><code>public int Age\n{\nget { return age; }\nset {\nif (value &lt; 0)\nthrow new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\nage = value; }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck.</p> </li> <li> <p>Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9ben.</p> <pre><code>p.Age = -2;\n</code></pre> </li> <li> <p>Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort.</p> <pre><code>p.Age = 2;\n</code></pre> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#autoimplementalt-tulajdonsag-auto-implemented-property","title":"Autoimplement\u00e1lt tulajdons\u00e1g (auto-implemented property)","text":"<p>A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben:</p> <ul> <li>nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat,</li> <li>nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re.</li> </ul> <p>Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t.</p> <ol> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Person</code> oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property). K\u00e9sz\u00edts\u00fcnk egy <code>string</code> t\u00edpus\u00fa <code>Name</code> nev\u0171 tulajdons\u00e1got.</p> <pre><code>public string Name { get; set; }\n</code></pre> <p>A szintaktikai k\u00fcl\u00f6nbs\u00e9g a kor\u00e1bbiakhoz k\u00e9pest: a get \u00e9s a set \u00e1gnak sem adtunk implement\u00e1ci\u00f3t (nincsenek kapcsos z\u00e1r\u00f3jelek). Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Hangs\u00falyozand\u00f3, hogy ez nem a kor\u00e1bban bevezetett <code>name</code> tagv\u00e1ltoz\u00f3t \u00e1ll\u00edtja \u00e9s k\u00e9rdezi le (az ki is t\u00f6r\u00f6lhetn\u00e9nk), hanem egy rejtett, \u00faj v\u00e1ltoz\u00f3n dolgozik!</p> </li> <li> <p>Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a <code>Main</code> f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel.</p> <pre><code>static void Main(string[] args)\n{\n// ...\np.Name = \"Luke\";\n// ...\nConsole.WriteLine(p.Name);\n}\n</code></pre> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#alapertelmezett-ertek-default-value","title":"Alap\u00e9rtelmezett \u00e9rt\u00e9k (default value)","text":"<p>Az autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9ben megadhat\u00f3 a kezdeti \u00e9rt\u00e9k\u00fck is a deklar\u00e1ci\u00f3 sor\u00e1n.</p> <ol> <li> <p>Adjunk kiindul\u00f3 \u00e9rt\u00e9ket a <code>Name</code> tulajdons\u00e1gnak.</p> <pre><code>public string Name { get; set; } = \"anonymous\";\n</code></pre> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#tulajdonsagok-lathatosaga","title":"Tulajdons\u00e1gok l\u00e1that\u00f3s\u00e1ga","text":"<p>A tulajdons\u00e1gok nagy el\u0151nye a teljesen szabad implement\u00e1ci\u00f3 mellett, hogy a getter \u00e9s a setter l\u00e1that\u00f3s\u00e1g\u00e1t k\u00fcl\u00f6n k\u00fcl\u00f6n is lehet \u00e1ll\u00edtani.</p> <ol> <li> <p>\u00c1ll\u00edtsuk a <code>Name</code> tulajdons\u00e1g setter\u00e9nek a l\u00e1that\u00f3s\u00e1g\u00e1t priv\u00e1tra.</p> <pre><code>public string Name { get; private set; }\n</code></pre> <p>Ilyenkor a <code>Program</code> oszt\u00e1lyban ford\u00edt\u00e1si hib\u00e1t kapunk a <code>p.Name = \"Luke\";</code> utas\u00edt\u00e1sra. Az alapvet\u0151 szab\u00e1ly az, hogy a getter \u00e9s a setter \u00f6r\u00f6kli a property l\u00e1that\u00f3s\u00e1g\u00e1t, mely tov\u00e1bb sz\u0171k\u00edthet\u0151, de nem laz\u00edthat\u00f3. A l\u00e1that\u00f3s\u00e1g szab\u00e1lyoz\u00e1sa autoimplement\u00e1lt \u00e9s nem autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9n is haszn\u00e1lhat\u00f3.</p> </li> <li> <p>\u00c1ll\u00edtsuk vissza a l\u00e1that\u00f3s\u00e1got (t\u00e1vol\u00edtsuk el a <code>private</code> kulcssz\u00f3t a <code>Name</code> tulajdons\u00e1g settere el\u0151l), hogy megsz\u0171nj\u00f6n a ford\u00edt\u00e1si hiba.</p> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#csak-olvashato-tulajdonsag-readonly-property","title":"Csak olvashat\u00f3 tulajdons\u00e1g (readonly property)","text":"<p>A setter elhagyhat\u00f3, \u00edgy egy olyan tulajdons\u00e1got kapunk, mely csak olvashat\u00f3. Autoimplement\u00e1lt tulajdons\u00e1g eset\u00e9n ennek is adhat\u00f3 kezd\u0151\u00e9rt\u00e9k: erre csak konstruktorban, vagy alap\u00e9rtelmezett \u00e9rt\u00e9kkel val\u00f3 ell\u00e1t\u00e1ssal (l\u00e1sd fent) van lehet\u0151s\u00e9g, ellent\u00e9tben a priv\u00e1t setterrel rendelkez\u0151 tulajdons\u00e1gokkal, melyek settere b\u00e1rmely, az oszt\u00e1lyban tal\u00e1lhat\u00f3 tagf\u00fcggv\u00e9nyb\u0151l h\u00edvhat\u00f3.</p> <p>Csak olvashat\u00f3 tulajdons\u00e1g defini\u00e1l\u00e1s\u00e1t a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletek illusztr\u00e1lj\u00e1k (a k\u00f3dunkba NE vezess\u00fck be):</p> <p>a) Autoimplement\u00e1lt eset</p> <pre><code>public string Name { get; }\n</code></pre> <p>b) Nem autoimplement\u00e1lt eset</p> <pre><code>private string name;\n...\npublic string Name { get {return name; } }\n</code></pre>"},{"location":"gyakorlat/nyelvi-eszkozok/#szamitott-ertek-calculated-value","title":"Sz\u00e1m\u00edtott \u00e9rt\u00e9k (calculated value)","text":"<p>A csak getterrel rendelkez\u0151 tulajdons\u00e1goknak van m\u00e9g egy haszn\u00e1lati m\u00f3dja. Valamilyen sz\u00e1m\u00edtott \u00e9rt\u00e9k meghat\u00e1roz\u00e1s\u00e1ra is haszn\u00e1lhat\u00f3, mely mindig kisz\u00e1mol egy megadott logika alapj\u00e1n egy \u00e9rt\u00e9ket, de a \"csak olvashat\u00f3 tulajdons\u00e1g\"-gal szemben nincs m\u00f6g\u00f6tte k\u00f6zvetlen\u00fcl a tulajdons\u00e1ghoz tartoz\u00f3 adattag. Ezt a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet illusztr\u00e1lja (a k\u00f3dunkba NE vezess\u00fck be):</p> <pre><code>public int AgeInDogYear { get { return Age * 7; } }\n</code></pre>"},{"location":"gyakorlat/nyelvi-eszkozok/#2-feladat-delegat-delegate-metodusreferencia","title":"2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia)","text":"<p>Forduljon a k\u00f3d!</p> <p>A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t.</p> <p>A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t seg\u00edts\u00e9g\u00e9vel egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t defini\u00e1lhatunk, amellyel met\u00f3dusokra tudunk mutatni/hivatkozni. Nem ak\u00e1rmilyenre, hanem - a C++ f\u00fcggv\u00e9nypointerekkel anal\u00f3g m\u00f3don - olyanokra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t v\u00e1ltoz\u00f3 \"megh\u00edv\u00e1s\u00e1val\" az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni.</p> <p>N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra:</p> <ul> <li>egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek  param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa,</li> <li>egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba,</li> <li>a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l.</li> </ul> <p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott <code>Person</code> oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust (<code>AgeChangingDelegate</code>), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott <code>Person</code> p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r.</p> <ol> <li> <p>Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust, mely <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab <code>int</code> param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a <code>Person</code> oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk!</p> <pre><code>namespace PropertyDemo\n{\npublic delegate void AgeChangingDelegate(int oldAge, int newAge);\n\npublic class Person\n{\n// ...\n</code></pre> <p>Az <code>AgeChangingDelegate</code> egy t\u00edpus (figyelj\u00fck a VS sz\u00ednez\u00e9s\u00e9t is), mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.).</p> </li> <li> <p>Tegy\u00fck lehet\u0151v\u00e9, hogy a <code>Person</code> objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban!</p> <pre><code>public class Person\n{\npublic AgeChangingDelegate AgeChanging;\n</code></pre> <p>Ez \u00edgy most mennyire objektumorient\u00e1lt?</p> <p>A publikus tagv\u00e1ltoz\u00f3k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az objektumorint\u00e1lt egys\u00e9gbez\u00e1r\u00e1si/inform\u00e1ci\u00f3rejt\u00e9si elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g.</p> </li> <li> <p>H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az <code>Age</code> tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel.</p> <pre><code>public int Age\n{\nget { return age; }\nset {\nif (value &lt; 0)\nthrow new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\nif (AgeChanging != null)\nAgeChanging(age, value);\nage = value; }\n}\n</code></pre> <p>A  fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l:</p> <ul> <li>A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t.</li> <li>Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \"changing\" sz\u00f3 egy folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st, a bek\u00f6vetkez\u00e9st m\u00falt id\u0151 jelezni: \"changed\")</li> <li>Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3hoz m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a tagv\u00e1ltoz\u00f3 \u00e9rt\u00e9ke <code>null</code>-e.</li> <li>Az esem\u00e9ny els\u00fct\u00e9sekor a <code>null</code> vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb, \u00e9s sz\u00e1lbiztosabb form\u00e1ban is meg tudjuk tenni a \"<code>?.</code>\" null-conditional oper\u00e1torral (C# 6-t\u00f3l):</li> </ul> <pre><code>if (AgeChanging != null)\nAgeChanging(age, value);\n</code></pre> <p>helyett</p> <pre><code>AgeChanging?.Invoke(age, value);\n</code></pre> <p>Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem <code>null</code>, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l.</p> </li> <li> <p>Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel:</p> <pre><code>if (age == value) return;\n\u2026\n</code></pre> </li> <li> <p>K\u00e9sz vagyunk a <code>Person</code> oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a <code>Program</code> oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel.</p> <pre><code>class Program\n{\n// ...\n\nprivate static void PersonAgeChanging(int oldAge, int newAge)\n{\nConsole.WriteLine(oldAge + \" =&gt; \" + newAge);\n}\n}\n</code></pre> <p>Tipp</p> <p>Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! M\u00edg a delegate t\u00edpust az oszt\u00e1lyon k\u00edv\u00fclre (de namespace-en bel\u00fclre) helyezt\u00fck el, a f\u00fcggv\u00e9nyt az oszt\u00e1lyon bel\u00fclre helyezz\u00fck!</p> </li> <li> <p>V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a <code>Main</code> f\u00fcggv\u00e9nyben!</p> <pre><code>static void Main(string[] args)\n{\nPerson p = new Person();\np.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\n// ...\n</code></pre> </li> <li> <p>Futtassuk a programot!</p> <p>Pl. az <code>AgeChanging?.Invoke(age, value);</code> sorra t\u00f6r\u00e9spontot helyezve, az alkalmaz\u00e1st debuggolva futtatva, \u00e9s a k\u00f3dot l\u00e9ptetve figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1s sor\u00e1n egyar\u00e1nt lefut.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal (a <code>+=</code> oper\u00e1torral lehet \u00faj feliratkoz\u00f3t felvenni a megl\u00e9v\u0151k mell\u00e9), majd futtassuk a programot.</p> <pre><code>p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += PersonAgeChanging; // T\u00f6m\u00f6rebb szintaktika\n</code></pre> <p>L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9nyreferenci\u00e1t, hanem egy f\u00fcggv\u00e9nyreferencia-list\u00e1t tartalmaznak (\u00e9s tartanak karban).</p> <p>Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a <code>+=</code> oper\u00e1tor ut\u00e1n, a <code>new AgeChangingDelegate(...)</code> n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy <code>AgeChangingDelegate</code> objektum fogja becsomagolni a <code>PersonAgeChanging</code> f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. A  gyakorlatban ezt a t\u00f6m\u00f6rebb szintaktik\u00e1t szoktuk haszn\u00e1lni.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot.</p> <pre><code>p.AgeChanging -= PersonAgeChanging;\n</code></pre> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#3-feladat-esemeny-event","title":"3. Feladat \u2013 Esem\u00e9ny (event)","text":"<p>Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni.</p> <ol> <li> <p>Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veleteib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hiszen \u00edgy az esem\u00e9ny hamis m\u00f3don akkor is kiv\u00e1lthat\u00f3,  r\u00e1ad\u00e1sul val\u00f3tlan adatokkal, amikor az a gyakorlatban be sem k\u00f6vetkezett, becsapva az \u00f6sszes el\u0151fizet\u0151t. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re.</p> <pre><code>p.AgeChanging(67, 12);\n</code></pre> <p>Itt a <code>p</code> <code>Person</code> objektum vonatkoz\u00e1s\u00e1ban egy val\u00f3tlan \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki, becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a <code>Person</code> oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani.</p> </li> <li> <p>Egy m\u00e1sik probl\u00e9ma a k\u00f6vetkez\u0151. B\u00e1r a <code>+=</code> \u00e9s a <code>-=</code> tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az <code>=</code> oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be).</p> <pre><code>p.AgeChanging = null;\n</code></pre> </li> <li> <p>L\u00e1ssuk el az <code>event</code> kulcssz\u00f3val az <code>AgeChanging</code> tagv\u00e1ltoz\u00f3t <code>Person.cs</code>-ben!</p> Person.cs<pre><code>public event AgeChangingDelegate AgeChanging;\n</code></pre> <p>Az <code>event</code> kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t probl\u00e9m\u00e1t kiz\u00e1rva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli.</p> <p></p> </li> <li> <p>T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat!</p> </li> </ol>"},{"location":"gyakorlat/nyelvi-eszkozok/#4-feladat-attributumok","title":"4. Feladat \u2013 Attrib\u00fatumok","text":""},{"location":"gyakorlat/nyelvi-eszkozok/#sorositas-testreszabasa-attributummal","title":"Soros\u00edt\u00e1s testreszab\u00e1sa attrib\u00fatummal","text":"<p>Az attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat. Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz, stb.). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k.</p> <p>property vs. attrib\u00fatum vs. static</p> <p>Felmer\u00fcl a k\u00e9rd\u00e9s, hogy milyen oszt\u00e1lyjellemz\u0151k ker\u00fcljenek tulajdons\u00e1gokba \u00e9s melyek attrib\u00fatumokba egy oszt\u00e1ly eset\u00e9ben. A tulajdons\u00e1gok mag\u00e1ra az objektum p\u00e9ld\u00e1nyra vonatkoznak, m\u00edg az attrib\u00fatum az azt le\u00edr\u00f3 oszt\u00e1lyra (vagy annak valamilyen tagj\u00e1ra).</p> <p>Ilyen szempontb\u00f3l az attrib\u00fatumok k\u00f6zelebb \u00e1llnak a statikus tulajdons\u00e1gokhoz, m\u00e9gis megfontoland\u00f3, hogy egy adott adatot statikus tagk\u00e9nt vagy attrib\u00fatumk\u00e9nt defini\u00e1ln\u00e1nk. Attrib\u00fatummal sokkal deklarat\u00edvabb a le\u00edr\u00e1s, \u00e9s nem szennyezz\u00fck olyan r\u00e9szletekkel a k\u00f3dot, melyeknek nem kellene az oszt\u00e1ly publikus interf\u00e9sz\u00e9n megjelennie.</p> <p>A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat.</p> <ol> <li> <p>Sz\u00farjuk be a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat!</p> <pre><code>var serializer = new XmlSerializer(typeof(Person));\nvar stream = new FileStream(\"person.txt\", FileMode.Create);\nserializer.Serialize(stream, p);\nstream.Close();\nProcess.Start(new ProcessStartInfo\n{\nFileName = \"person.txt\",\nUseShellExecute = true,\n});\n</code></pre> <p>A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 <code>Process.Start</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a <code>person.txt</code> f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a *\\bin\\Debug\\* alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. <li> <p>N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve.</p> </li> <li> <p>.NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a <code>Person</code> oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az <code>XmlRoot</code> attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a <code>Person</code> oszt\u00e1ly f\u00f6l\u00e9!</p> <pre><code>[XmlRoot(\"Szem\u00e9ly\")]\npublic class Person {\n// ...\n}\n</code></pre> </li> <li> <p>Az <code>XmlAttribute</code> attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az <code>Age</code> tulajdons\u00e1got (\u00e9s ne a tagv\u00e1ltoz\u00f3t!)!</p> <pre><code>[XmlAttribute(\"Kor\")]\npublic int Age\n</code></pre> </li> <li> <p>Az <code>XmlIgnore</code> attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a <code>Name</code> tulajdons\u00e1g f\u00f6l\u00f6tt.</p> <pre><code>[XmlIgnore]\npublic string Name { get; set; }\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal.</p> </li>"},{"location":"gyakorlat/nyelvi-eszkozok/#5-feladat-delegat-2","title":"5. Feladat \u2013 Deleg\u00e1t 2.","text":"<p>A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk.</p> <p>A be\u00e9p\u00edtett generikus lista oszt\u00e1ly (<code>List&lt;T&gt;</code>) <code>FindAll</code> f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny, pontosabban delegate form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (ez a <code>FindAll</code> minden elemre megh\u00edvja), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny param\u00e9ter\u00e9nek a t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus (nem kell beg\u00e9pelni/l\u00e9trehozni, hiszen m\u00e1r l\u00e9tezik):</p> <pre><code>public delegate bool Predicate&lt;T&gt;(T obj)\n</code></pre> <p>Note</p> <p>A fenti teljes defin\u00edci\u00f3 megjelen\u00edt\u00e9s\u00e9hez csak g\u00e9pelj\u00fck be valahova, pl. a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a <code>Predicate</code> t\u00edpusnevet, kattintsunk rajta eg\u00e9rrel, \u00e9s az F12 billenty\u0171vel navig\u00e1ljunk el a defin\u00edci\u00f3j\u00e1hoz.</p> <p>Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai (bool) \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani.</p> <ol> <li> <p>Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza:</p> <pre><code>private static bool MyFilter(int n)\n{\nreturn n % 2 == 1;\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val:</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nlist = list.FindAll(MyFilter);\nforeach (int n in list)\n{\nConsole.WriteLine($\"Value: {n}\");\n}\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg.</p> </li> <li>\u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a <code>MyFilter</code> f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben, \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik.</li> </ol> <p>Collection initializer szintaxis</p> <p>Minden <code>Add</code> met\u00f3dussal rendelkez\u0151, az <code>IEnumerable</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyra (tipikusan kollekci\u00f3k) a collection initializer szintaxis az al\u00e1bbi m\u00f3don:</p> <pre><code>var list = new List&lt;int&gt;()\n{\n1,\n2,\n3,\n};\n</code></pre>"},{"location":"gyakorlat/nyelvi-eszkozok/#6-feladat-lambda-kifejezesek","title":"6. Feladat \u2013 Lambda kifejez\u00e9sek","text":"<p>A kulcselem a <code>=&gt;</code> (lambda oper\u00e1tor), mely seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek, vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1s\u00e1ra van lehet\u0151s\u00e9g.</p> <p>Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a <code>FindAll</code> m\u0171veletnek.</p> <p>Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni:</p> <pre><code>list = list.FindAll((int n) =&gt; { return n % 2 == 1; });\n</code></pre> <p>Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a <code>FindAll</code> m\u0171veletnek:</p> <ul> <li>ez egy lambda kifejez\u00e9s,</li> <li>a <code>=&gt;</code> bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt),</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n adtuk meg a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi <code>MyFilter</code> t\u00f6rzse).</li> </ul> <p>A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk:</p> <pre><code>list = list.FindAll(n =&gt; n % 2 == 1);\n</code></pre> <p>A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck:</p> <ul> <li>a param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki: a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a <code>FindAll</code> delegate param\u00e9teram\u00e9ter\u00e9nek t\u00edpus\u00e1b\u00f3l, mely a kor\u00e1bban vizsg\u00e1lt <code>Predicate</code>.</li> <li>a param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk (mert csak egy param\u00e9ter van)</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code>-t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r).</li> </ul> <p><code>Action \u00e9s Func</code></p> <p>A .NET be\u00e9p\u00edtett <code>Func</code> \u00e9s <code>Action</code> generikus delegate t\u00edpusokra a t\u00e1rgy keret\u00e9ben nem t\u00e9r\u00fcnk ki.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#7-feladat-generikus-osztalyok","title":"7. Feladat \u2013 Generikus oszt\u00e1lyok","text":"<p>Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni.</p> <p>A .NET generikus oszt\u00e1lyai hasonl\u00edtanak C++ nyelv template oszt\u00e1lyaihoz, de k\u00f6zelebb \u00e1llnak a Java-ban m\u00e1r megismert generikus oszt\u00e1lyokhoz. A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor <code>object</code> t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az <code>object</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az <code>ArrayList</code>-tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, <code>object</code> t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az <code>ArrayList</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>var list = new ArrayList();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n// Castolni kell, k\u00fcl\u00f6nben nem fordul\nint i = (int)list[n];\nConsole.WriteLine($\"Value: {i}\");\n}\n</code></pre> <p>A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak:</p> <ul> <li>Az <code>ArrayList</code> minden egyes elemet <code>object</code>-k\u00e9nt t\u00e1rol.</li> <li>Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni.</li> <li>Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az <code>int</code> t\u00edpus\u00fa adatok mell\u00e9  besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem <code>int</code> t\u00edpust <code>int</code> t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek.</li> <li>\u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az <code>object</code>-k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen.</li> </ul> <p>A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban):</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\nint i = list[n]; // Nem kell cast-olni\nConsole.WriteLine($\"Value: {i}\");\n}\n</code></pre>"},{"location":"gyakorlat/nyelvi-eszkozok/#8-tovabbi-nyelvi-konstrukciok-opcionalis-temakorok-nem-tananyag","title":"8. Tov\u00e1bbi nyelvi konstrukci\u00f3k - opcion\u00e1lis t\u00e9mak\u00f6r\u00f6k (nem tananyag)","text":"<p>Az al\u00e1bbiakban kitekint\u00fcnk n\u00e9h\u00e1ny olyan C# nyelvi elemre, melyek a napi programoz\u00e1si feladatok sor\u00e1n egyre gyakrabban haszn\u00e1latosak. A gyakorlat sor\u00e1n j\u00f3 es\u00e9llyel m\u00e1r nem marad id\u0151 ezek \u00e1ttekint\u00e9s\u00e9re.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#kifejezestorzsu-tagok-expression-bodied-members","title":"Kifejez\u00e9st\u00f6rzs\u0171 tagok (Expression-bodied members)","text":"<p>Id\u0151nk\u00e9nt olyan r\u00f6vid f\u00fcggv\u00e9nyeket, illetve tulajdons\u00e1gok eset\u00e9n kifejezetten gyakran olyan r\u00f6vid get/set/init defin\u00edci\u00f3kat \u00edrunk, melyek egyetlen kifejez\u00e9sb\u0151l \u00e1llnak. Ez esetben a f\u00fcggv\u00e9ny, illetve tulajdons\u00e1g eset\u00e9n a get/set/init t\u00f6rzse megadhat\u00f3 \u00fan. kifejez\u00e9st\u00f6rzs\u0171 tagok (expression-bodied members) szintaktik\u00e1val is, a <code>=&gt;</code> alkalmaz\u00e1s\u00e1val. Ez akkor is megtehet\u0151, ha az adott kontextusban van visszat\u00e9r\u00e9si \u00e9rt\u00e9k (return utas\u00edt\u00e1s), ak\u00e1r nincs.</p> <p>A p\u00e9ld\u00e1kban l\u00e1tni fogjuk, hogy a kifejez\u00e9stest\u0171 tagok alkalmaz\u00e1sa nem t\u00f6bb, mint egy kisebb szintaktikai \"csavar\" annak \u00e9rdek\u00e9ben, hogy ilyen egyszer\u0171 esetekben min\u00e9l kevesebb k\u00f6r\u00edt\u0151 k\u00f3dot kelljen \u00edrni.</p> <p>N\u00e9zz\u00fcnk el\u0151sz\u00f6r egy f\u00fcggv\u00e9ny p\u00e9ld\u00e1t (feltessz\u00fck, hogy az oszt\u00e1lyban van egy <code>Age</code> tagv\u00e1ltoz\u00f3 vagy tulajdons\u00e1g):</p> <p><pre><code>public int GetAgeInDogYear() =&gt; Age * 7; public void DisplayName() =&gt; Console.WriteLine(ToString());\n</code></pre> Mint l\u00e1that\u00f3, elhagytuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code> utas\u00edt\u00e1st, \u00edgy t\u00f6m\u00f6rebb a szintaktika.</p> <p>Fontos</p> <p>B\u00e1r itt is a <code>=&gt;</code> tokent haszn\u00e1ljuk, ennek semmi k\u00f6ze nincs a kor\u00e1bban t\u00e1rgyalt lambda kifejez\u00e9sekhez: egyszer\u0171en csak arr\u00f3l van sz\u00f3, hogy ugyanazt a <code>=&gt;</code> tokent (szimb\u00f3lump\u00e1rt) k\u00e9t teljesen elt\u00e9r\u0151 dologra haszn\u00e1lja a C# nyelv.</p> <p>P\u00e9lda tulajdons\u00e1g getter megad\u00e1s\u00e1ra:</p> <pre><code>public int AgeInDogYear { get =&gt; Age * 7; }\n</code></pre> <p>S\u0151t, ha csak getterje van a tulajdons\u00e1gnak, a <code>get</code> kulcssz\u00f3t \u00e9s a kapcsos z\u00e1r\u00f3jeleket is lehagyhatjuk.</p> <pre><code>public int AgeInDogYear =&gt; Age * 7;\n</code></pre> <p>Ezt az k\u00fcl\u00f6nb\u00f6zteti meg a kor\u00e1bban l\u00e1tott f\u00fcggv\u00e9nyek hasonl\u00f3 szintaktik\u00e1j\u00e1t\u00f3l, hogy itt nem \u00edrtuk ki a kerek z\u00e1r\u00f3jeleket.</p> <p>Note</p> <p>A Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1nak magyar ford\u00edt\u00e1s\u00e1ban az \"expression-bodied members\" nem \"kifejez\u00e9st\u00f6rzs\u0171\", hanem \"kifejez\u00e9stest\u0171\" tagk\u00e9nt szerepel. K\u00f6sz\u00f6nj\u00fck sz\u00e9pen, de a f\u00fcggv\u00e9nyeknek sokkal ink\u00e1bb t\u00f6rzse, mint teste van a magyar terminol\u00f3gi\u00e1ban, \u00edgy ezt nem vessz\u00fck \u00e1t...</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#objektuminicializalo-object-initializer","title":"Objektuminicializ\u00e1l\u00f3 (Object initializer)","text":"<p>A publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k inicializ\u00e1l\u00e1sa \u00e9s a konstruktorh\u00edv\u00e1s kombin\u00e1lhat\u00f3 egy \u00fagynevezett objektuminicializ\u00e1l\u00f3 (object initializer) szintaxis seg\u00edts\u00e9g\u00e9vel. Ennek alkalmaz\u00e1sa sor\u00e1n a konstruktorh\u00edv\u00e1s ut\u00e1n kapcsos z\u00e1r\u00f3jelekkel blokkot nyitunk, ahol a publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k \u00e9rt\u00e9ke adhat\u00f3 meg, az al\u00e1bbi szintaktik\u00e1val.</p> <pre><code>var p = new Person()\n{\nAge = 17,\nName = \"Luke\",\n};\n</code></pre> <p>Az tulajdons\u00e1gok/tagok inicializ\u00e1l\u00e1sa a konstruktor lefut\u00e1sa ut\u00e1n t\u00f6rt\u00e9nik (amennyiben tartozik az oszt\u00e1lyhoz konstruktor). Ez a szintaktika az\u00e9rt is el\u0151ny\u00f6s, mert egy kifejez\u00e9snek sz\u00e1m\u00edt (azon h\u00e1rommal szemben, mintha l\u00e9trehozn\u00e1nk egy inicializ\u00e1latlan, <code>Person</code> objektumot, \u00e9s k\u00e9t tov\u00e1bbi l\u00e9p\u00e9sben adn\u00e1nk \u00e9rt\u00e9ket az <code>Age</code> \u00e9s <code>Name</code> tagoknak). \u00cdgy ak\u00e1r k\u00f6zvetlen\u00fcl f\u00fcggv\u00e9nyh\u00edv\u00e1s param\u00e9terek\u00e9nt \u00e1tadhat\u00f3 egy inicializ\u00e1lt objektum, an\u00e9lk\u00fcl, hogy k\u00fcl\u00f6n v\u00e1ltoz\u00f3t kellene deklar\u00e1lni.</p> <pre><code>void Foo(Person p)\n{\n// do something with p\n}\n</code></pre> <pre><code>Foo(new Person() { Age = 17, Name = \"Luke\" });\n</code></pre> <p>A szintaxis r\u00e1ad\u00e1sul copy-paste bar\u00e1t, mert ahogy a fenti p\u00e9ld\u00e1kban is l\u00e1tszik, hogy nem sz\u00e1m\u00edt, hogy az utols\u00f3 tulajdons\u00e1g megad\u00e1sa ut\u00e1n van-e vessz\u0151, vagy nincs.</p>"},{"location":"gyakorlat/nyelvi-eszkozok/#tulajdonsagok-init-only-setter","title":"Tulajdons\u00e1gok - Init only setter","text":"<p>Az el\u0151z\u0151 pontban l\u00e9v\u0151 objektuminicializ\u00e1l\u00f3 szintaxis nagyon k\u00e9nyelmes, viszont azt k\u00f6veteli meg a tulajdons\u00e1gt\u00f3l, hogy publikus legyen. Ha azt akarjuk, hogy egy tulajdons\u00e1g \u00e9rt\u00e9ke csak az objektum l\u00e9trehoz\u00e1sakor legyen megadhat\u00f3, ahhoz konstruktor param\u00e9tert kell bevezess\u00fcnk, \u00e9s egy csak olvashat\u00f3 (csak getterrel rendelkez\u0151) tulajdons\u00e1gnak kell azt \u00e9rt\u00e9k\u00fcl adjuk. Erre a probl\u00e9m\u00e1ra ad egyszer\u0171bb megold\u00e1st az \u00fan. Init only setter szintaxis, ahol olyan \"settert\" tudunk k\u00e9sz\u00edteni az <code>init</code> kulcssz\u00f3val, mely \u00e1ll\u00edt\u00e1sa  csak a konstruktorban \u00e9s az el\u0151z\u0151 fejezetben ismertetett objektuminicializ\u00e1l\u00f3 szintaxis alkalmaz\u00e1sa sor\u00e1n enged\u00e9lyezett, ezt k\u00f6vet\u0151en m\u00e1r nem.</p> <pre><code>public string Name { get; init; }\n</code></pre> <pre><code>var p = new Person()\n{\nAge = 17,\nName = \"Luke\",\n};\n\np.Name = \"Test\"; // build hiba, ut\u00f3lag nem megv\u00e1ltoztathat\u00f3\n</code></pre>"},{"location":"gyakorlat/tobbszalu/","title":"T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se","text":""},{"location":"gyakorlat/tobbszalu/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt):</p> <ul> <li>Sz\u00e1lak ind\u00edt\u00e1sa (<code>Thread</code>)</li> <li>Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa</li> <li>Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a <code>lock</code> kulcssz\u00f3 alkalmaz\u00e1s\u00e1val</li> <li><code>ThreadPool</code> haszn\u00e1lata</li> <li>Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel (<code>WaitHandle</code>)</li> <li>Windows Forms sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok (<code>Invoke</code>)</li> </ul> <p>Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban.</p> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se.</p>"},{"location":"gyakorlat/tobbszalu/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"gyakorlat/tobbszalu/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo-winforms -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"gyakorlat/tobbszalu/#bevezeto","title":"Bevezet\u0151","text":"<p>A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet miden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck.</p> <p>A feladat sor\u00e1n egyszer\u0171 Windows Forms alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.</p>"},{"location":"gyakorlat/tobbszalu/#0-feladat-ismerkedes-a-kiindulo-alkalmazassal-elokeszites","title":"0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Kl\u00f3nozzuk le a gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1st repositoryj\u00e1t.</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo-winforms.git</code></li> <li>Nyissuk meg SuperCalculator.sln solutiont Visual Studio-ban.</li> </ul> <p>A feladatunk az, hogy egy bin\u00e1ris form\u00e1ban megkapott algoritmus futtat\u00e1s\u00e1hoz Windows Forms technol\u00f3gi\u00e1val felhaszn\u00e1l\u00f3i fel\u00fcletet k\u00e9sz\u00edts\u00fcnk. A bin\u00e1ris forma .NET eset\u00e9ben egy .dll kiterjeszt\u00e9s\u0171 f\u00e1jlt jelent, ami programoz\u00f3i szemmel egy oszt\u00e1lyk\u00f6nyvt\u00e1r.  A f\u00e1jl neve eset\u00fcnkben Algorithms.dll, megtal\u00e1lhat\u00f3 a lekl\u00f3nozott Git repositoryban.</p> <p>A kiindul\u00f3 alkalmaz\u00e1sban a felhaszn\u00e1l\u00f3i fel\u00fclet el\u0151 is van k\u00e9sz\u00edtve. Futtassuk az alkalmaz\u00e1st:</p> <p></p> <p>Az alkalmaz\u00e1s fel\u00fclet\u00e9n meg tudjuk adni az algoritmus bemen\u0151 param\u00e9tereit (<code>double</code> sz\u00e1mok t\u00f6mbje): a p\u00e9ld\u00e1nkban mindig k\u00e9t <code>double</code> sz\u00e1m param\u00e9terrel h\u00edvjuk az algoritmust, ezt a k\u00e9t fels\u0151 sz\u00f6vegmez\u0151ben lehet megadni. A feladatunk az, hogy a Calculate Result gombra kattint\u00e1s sor\u00e1n futtassuk az algoritmust a megadott param\u00e9terekkel, majd, ha v\u00e9gzett, akkor a Result alatti list\u00e1z\u00f3 mez\u0151 \u00faj sor\u00e1ban jelen\u00edts\u00fck meg a kapott eredm\u00e9nyt a bemen\u0151 param\u00e9terekkel egy\u00fctt.</p> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben ismerkedj\u00fcnk meg a let\u00f6lt\u00f6tt Visual Studio solutionnel:</p> <ol> <li>N\u00e9zz\u00fck v\u00e9gig a <code>MainForm</code> oszt\u00e1lyt.</li> <li>Az l\u00e1tjuk, hogy a fel\u00fclet alapvet\u0151en k\u00e9sz, csak az algoritmus futtat\u00e1sa hi\u00e1nyzik. </li> <li>Az eredm\u00e9ny \u00e9s a param\u00e9terei napl\u00f3z\u00e1s\u00e1hoz is tal\u00e1lunk egy <code>ShowResult</code> nev\u0171 seg\u00e9df\u00fcggv\u00e9nyt.</li> <li>A <code>DataFifo</code> oszt\u00e1lyt egyel\u0151re hagyjuk ki, csak a gyakorlat m\u00e1sodik fel\u00e9ben fogjuk haszn\u00e1lni, majd k\u00e9s\u0151bb megismerked\u00fcnk vele.</li> </ol>"},{"location":"gyakorlat/tobbszalu/#a-dll-ben-levo-kod-felhasznalasa","title":"A DLL-ben lev\u0151 k\u00f3d felhaszn\u00e1l\u00e1sa","text":"<p>A kiindul\u00f3 projektben megtal\u00e1ljuk a Algorithm.dll-t. Ebben leford\u00edtott form\u00e1ban egy <code>Algorithms</code> n\u00e9vt\u00e9rben lev\u0151 <code>SuperAlgorithm</code> nev\u0171 oszt\u00e1ly tal\u00e1lhat\u00f3, melynek egy <code>Calculate</code> nev\u0171 statikus m\u0171velete van. Ahhoz, hogy egy projektben fel tudjuk haszn\u00e1lni a DLL-ben lev\u0151 oszt\u00e1lyokat, a DLL-re a projekt\u00fcnkben egy \u00fan. referenci\u00e1t kell felvegy\u00fcnk.</p> <ol> <li> <p>Solution Explorerben a projekt\u00fcnk Dependencies node-j\u00e1ra jobbklikkelve v\u00e1lasszuk az Add Project reference opci\u00f3t!</p> <p></p> <p>K\u00fcls\u0151 referenci\u00e1k</p> <p>Itt val\u00f3j\u00e1ban nem egy m\u00e1sik Visual Studio projektre adunk referenci\u00e1t, de \u00edgy a legegyszer\u0171bb el\u0151hozni ezt az ablakot.</p> <p>Megeml\u00edtend\u0151 m\u00e9g, hogy k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rak eset\u00e9ben m\u00e1r nem DLL-eket szoktunk refer\u00e1lni egy rendes projektben, hanem a .NET csomagkezel\u0151 rendeszer\u00e9b\u0151l a NuGet-r\u0151l szok\u00e1s a k\u00fcls\u0151 csomagokat beszerezni. Most az Algorithm.dll eset\u00fcnkben nincs NuGet-en publik\u00e1lva, ez\u00e9rt kell k\u00e9zzel felvegy\u00fck azt.</p> </li> <li> <p>Az el\u0151ugr\u00f3 ablak jobb als\u00f3 sarokban tal\u00e1lhat\u00f3 Browse gomb seg\u00edts\u00e9g\u00e9vel keress\u00fck meg \u00e9s v\u00e1lasszuk ki projekt External almapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 Algorithms.dll f\u00e1jlt, majd hagyjuk j\u00f3v\u00e1 a hozz\u00e1ad\u00e1st az OK gombbal!</p> </li> </ol> <p>A Solution Explorerben egy projekt alatti Dependencies csom\u00f3pontot lenyitva l\u00e1thatjuk a hivatkozott k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket. Itt most m\u00e1r megjelenik az Assemblyk k\u00f6z\u00f6tt el\u0151bb felvett Algorithms referencia is. A Frameworks kateg\u00f3ri\u00e1ban a .NET keretrendszer csomagjait tal\u00e1ljuk. Az Analyzerek pedig statikus k\u00f3delemz\u0151 eszk\u00f6z\u00f6k ford\u00edt\u00e1s id\u0151ben. Illetve itt lenn\u00e9nek m\u00e9g a projekt vagy a NuGet referenci\u00e1k is.</p> <p></p> <p>Kattintsunk Algorithms referenci\u00e1n jobb gombbal \u00e9s v\u00e1lasszuk a View in Object Browser funkci\u00f3t. Ekkor megny\u00edlik az Object Browser tabf\u00fcl, ahol megtekinthetj\u00fck, hogy az adott DLL-ben milyen n\u00e9vterek, oszt\u00e1lyok tal\u00e1lhat\u00f3k, illetve ezeknek milyen tagjaik (tagv\u00e1ltoz\u00f3, tagf\u00fcggv\u00e9ny, property, event) vannak. Ezeket a Visual Studio a DLL metaadataib\u00f3l az \u00fan. reflection mechanizmus seg\u00edts\u00e9g\u00e9vel olvassa ki (ilyen k\u00f3dot ak\u00e1r mi is \u00edrhatunk).</p> <p>Az al\u00e1bbi \u00e1br\u00e1nak megfelel\u0151en az Object Browserben baloldalt keress\u00fck ki az Algorithms csom\u00f3pontot, nyissuk le, \u00e9s l\u00e1that\u00f3v\u00e1 v\u00e1lik, hogy egy <code>Algorithms</code> n\u00e9vt\u00e9r van benne, abban pedig egy <code>SuperAlgorithm</code> oszt\u00e1ly. Ezt kiv\u00e1lasztva k\u00f6z\u00e9pen megjelennek az oszt\u00e1ly f\u00fcggv\u00e9nyei, itt egy f\u00fcggv\u00e9nyt kiv\u00e1lasztva pedig az adott f\u00fcggv\u00e9ny pontos szignat\u00far\u00e1ja:</p> <p></p>"},{"location":"gyakorlat/tobbszalu/#1-feladat-muvelet-futtatasa-a-foszalon","title":"1. Feladat \u2013 M\u0171velet futtat\u00e1sa a f\u0151sz\u00e1lon","text":"<p>Most m\u00e1r r\u00e1t\u00e9rhet\u00fcnk az algoritmus futtat\u00e1s\u00e1ra. Els\u0151 l\u00e9p\u00e9sben ezt az alkalmaz\u00e1sunk f\u0151 sz\u00e1l\u00e1n tessz\u00fck meg.</p> <ol> <li> <p>A f\u0151ablakon l\u00e9v\u0151 gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben h\u00edvjuk meg a sz\u00e1mol\u00f3 f\u00fcggv\u00e9ny\u00fcnket. Ehhez kattintsunk a Solution Explorerben dupl\u00e1n a <code>MainForm.cs</code> f\u00e1jlra, majd a megjelen\u0151 Form Designer-ben a Calculate Result gombra. Eg\u00e9sz\u00edts\u00fck ki a k\u00f3dot az \u00fajonnan behivatkozott algoritmus megh\u00edv\u00e1s\u00e1val.</p> <pre><code>private void buttonCalcResult_Click(object sender, EventArgs e)\n{\nif (double.TryParse(textBoxParam1.Text, out var p1) &amp;&amp; double.TryParse(textBoxParam2.Text, out var p2))\n{\nvar parameters = new double[] { p1, p2 };\n\nvar result = Algorithms.SuperAlgorithm.Calculate(parameters);\nShowResult(parameters, result);\n}\nelse\n{\nMessageBox.Show(this, \"Invalid parameter!\", \"Error\");\n}\n}\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az ablak a sz\u00e1mol\u00e1s ideje alatt nem reag\u00e1l a mozgat\u00e1sra, \u00e1tm\u00e9retez\u00e9sre, a fel\u00fclet gyakorlatilag befagy.</p> </li> </ol> <p>Az alkalmaz\u00e1sunk esem\u00e9nyvez\u00e9relt, mint minden Windows alkalmaz\u00e1s. Az oper\u00e1ci\u00f3s rendszer a k\u00fcl\u00f6nb\u00f6z\u0151 interakci\u00f3kr\u00f3l (pl. mozgat\u00e1s, \u00e1tm\u00e9retez\u00e9s) \u00fczenetekben \u00e9rtes\u00edti az alkalmaz\u00e1sunkat. Mivel a gombnyom\u00e1st k\u00f6vet\u0151en az alkalmaz\u00e1sunk egyetlen sz\u00e1la a kalkul\u00e1ci\u00f3val van elfoglalva, nem tudja azonnal feldolgozni a tov\u00e1bbi felhaszn\u00e1l\u00f3i utas\u00edt\u00e1sokat. Amint a sz\u00e1m\u00edt\u00e1s lefutott (\u00e9s az eredm\u00e9nyek megjelennek a list\u00e1ban) a kor\u00e1bban kapott parancsok is v\u00e9grehajt\u00e1sra ker\u00fclnek.</p>"},{"location":"gyakorlat/tobbszalu/#2-feladat-vegezzuk-a-szamitast-kulon-szalban","title":"2. Feladat \u2013 V\u00e9gezz\u00fck a sz\u00e1m\u00edt\u00e1st k\u00fcl\u00f6n sz\u00e1lban","text":"<p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a sz\u00e1m\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9re egy k\u00fcl\u00f6n sz\u00e1lat fogunk ind\u00edtani, hogy az ne blokkolja a felhaszn\u00e1l\u00f3i fel\u00fcletet.</p> <ol> <li> <p>K\u00e9sz\u00edts\u00fcnk egy \u00faj f\u00fcggv\u00e9nyt a <code>MainForm</code> oszt\u00e1lyban, mely a feldolgoz\u00f3 sz\u00e1l bel\u00e9p\u00e9si pontja lesz.</p> <pre><code>private void CalculatorThread(object arg)\n{\nvar parameters = (double[])arg;\nvar result = Algorithms.SuperAlgorithm.Calculate(parameters);\nShowResult(parameters, result);\n}\n</code></pre> </li> <li> <p>Ind\u00edtsuk el a sz\u00e1lat a gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben. Ehhez cser\u00e9lj\u00fck le a kor\u00e1bban hozz\u00e1adott k\u00f3dot:</p> <pre><code>private void buttonCalcResult_Click(object sender, EventArgs e)\n{\nif (double.TryParse(textBoxParam1.Text, out var p1) &amp;&amp; double.TryParse(textBoxParam2.Text, out var p2))\n{\nvar parameters = new double[] { p1, p2 };\n\nvar th = new Thread(CalculatorThread);\nth.Start(parameters);\n}\nelse\n{\nMessageBox.Show(this, \"Invalid parameter!\", \"Error\");\n}\n}\n</code></pre> <p>A Thread objektum <code>Start</code> m\u0171velet\u00e9ben \u00e1tadott param\u00e9tert kapja meg a <code>CalculatorThread</code> sz\u00e1lf\u00fcggv\u00e9ny\u00fcnk.</p> </li> <li> <p>Futtassuk az alkalmaz\u00e1st F5-tel (most fontos, hogy \u00edgy, a debuggerben futtassuk)! InvalidOperationException, Cross-thread operation not valid hiba\u00fczenetet kapunk a <code>ShowResult</code> met\u00f3dusban, ugyanis nem abb\u00f3l a sz\u00e1lb\u00f3l pr\u00f3b\u00e1lunk hozz\u00e1f\u00e9rni a UI elemhez / vez\u00e9rl\u0151h\u00f6z, amelyik l\u00e9trehozta (a vez\u00e9rl\u0151t). A k\u00f6vetkez\u0151 feladatban ezt a probl\u00e9m\u00e1t analiz\u00e1ljuk \u00e9s oldjuk meg.</p> </li> </ol>"},{"location":"gyakorlat/tobbszalu/#3-feladat-az-invoke-es-invokerequired-hasznalata","title":"3. Feladat \u2013 az <code>Invoke</code> \u00e9s <code>InvokeRequired</code> haszn\u00e1lata","text":"<p>Az el\u0151z\u0151 pontban a probl\u00e9m\u00e1t a k\u00f6vetkez\u0151 okozza. Windows Forms alkalmaz\u00e1sokn\u00e1l \u00e9l az al\u00e1bbi szab\u00e1ly: az \u0171rlapok/vez\u00e9rl\u0151elemek alapvet\u0151en nem sz\u00e1lv\u00e9dett objektumok, \u00edgy egy \u0171rlaphoz/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l szabad hozz\u00e1f\u00e9rni (pl. propertyj\u00e9t olvasni, \u00e1ll\u00edtani, m\u0171velet\u00e9t megh\u00edvni), amelyik sz\u00e1l az adott \u0171rlapot/vez\u00e9rl\u0151t l\u00e9trehozta, m\u00e1sk\u00fcl\u00f6nben kiv\u00e9telt kapunk. Alkalmaz\u00e1sunkban az\u00e9rt kaptunk kiv\u00e9telt, mert a <code>listViewResult</code> vez\u00e9rl\u0151t a f\u0151 sz\u00e1lban hoztuk l\u00e9tre, a <code>ShowResult</code> met\u00f3dusban az eredm\u00e9ny megjelen\u00edt\u00e9sekor viszont egy m\u00e1sik sz\u00e1lb\u00f3l f\u00e9r\u00fcnk hozz\u00e1 (<code>listViewResult.Items.Add</code>).</p> <p>A fenti szab\u00e1ly al\u00f3l van p\u00e1r kiv\u00e9tel: ilyen pl. a <code>Control</code> oszt\u00e1lyban defini\u00e1lt <code>InvokeRequired</code> property \u00e9s <code>Invoke</code> met\u00f3dus, melyek b\u00e1rmely sz\u00e1lb\u00f3l biztons\u00e1gosan el\u00e9rhet\u0151k. Ezek pont abban ny\u00fajtanak seg\u00edts\u00e9get, hogy a vez\u00e9rl\u0151kh\u00f6z mindig a megfelel\u0151 sz\u00e1lb\u00f3l f\u00e9rj\u00fcnk hozz\u00e1:</p> <ul> <li>Ha az <code>InvokeRequired</code> tulajdons\u00e1g \u00e9rt\u00e9ke igaz, akkor a sz\u00e1l (mely az <code>InvokeRequired</code>-et h\u00edvja) a h\u00edv\u00e1s hely\u00e9n nem egyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal, \u00e9s ilyenkor csak az <code>Invoke</code> m\u0171velet seg\u00edts\u00e9g\u00e9vel \"ker\u00fcl\u0151 \u00faton\" f\u00e9rhet\u00fcnk vez\u00e9rl\u0151nkh\u00f6z. Vagyis egy vez\u00e9rl\u0151h\u00f6z val\u00f3 hozz\u00e1f\u00e9r\u00e9s sor\u00e1n ezzel tudjuk eld\u00f6nteni, k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk-e egy adott helyen a sz\u00e1lunkb\u00f3l, vagy csak az <code>Invoke</code> seg\u00edts\u00e9g\u00e9vel.</li> <li>Az <code>Invoke</code> met\u00f3dus a vez\u00e9rl\u0151elemet l\u00e9trehoz\u00f3 sz\u00e1lon futtatja le a sz\u00e1m\u00e1ra param\u00e9terk\u00e9nt megadott met\u00f3dust (melyb\u0151l m\u00e1r k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk a vez\u00e9rl\u0151h\u00f6z).</li> </ul> <p>Az <code>InvokeRequired</code> \u00e9s az <code>Invoke</code> felhaszn\u00e1l\u00e1s\u00e1val el tudjuk ker\u00fclni kor\u00e1bbi kiv\u00e9tel\u00fcnket (a vez\u00e9rl\u0151h\u00f6z, eset\u00fcnkben a listViewResult-hoz val\u00f3 hozz\u00e1f\u00e9r\u00e9st a megfelel\u0151 sz\u00e1lra tudjuk \"ir\u00e1ny\u00edtani\"). Ezt fogjuk a k\u00f6vetkez\u0151kben megtenni.</p> <p>Csak debuggerben futtatva j\u00f6n az <code>InvalidOperationException</code>?</p> <p>Ha kipr\u00f3b\u00e1ln\u00e1nk, hogy debugger n\u00e9lk\u00fcl ind\u00edtjuk el az alkalmaz\u00e1st (VS-ben Start without debugging vagy mag\u00e1t az exe-t), akkor azt tapasztaln\u00e1nk, hogy nem j\u00f6n a fenti kiv\u00e9tel. Ennek az az oka, hogy, fejleszt\u00e9s id\u0151ben, debuggerrel vizsg\u00e1lva az alkalmaz\u00e1st, sokkal szigor\u00fabban figyeli a keretrendszer a UI sz\u00e1l s\u00e9rt\u00e9st, hogy m\u00e1r fejleszt\u00e9s id\u0151ben el\u0151j\u00f6jjenek olyan potenci\u00e1lis hib\u00e1k, melyek am\u00fagy m\u00e9g nem jelenten\u00e9k az alkalmaz\u00e1s \u00f6sszeoml\u00e1s\u00e1t.</p> <p>A fenti esetben a <code>ListView</code> <code>Invoke</code> n\u00e9lk\u00fcli manipul\u00e1l\u00e1s\u00e1t j\u00f3 es\u00e9llyel az esetek t\u00f6bbs\u00e9g\u00e9ben m\u00e9g t\u00fal\u00e9ln\u00e9 az app, de a keretrendszer a debuggeren kereszt\u00fcl futtat\u00e1s sor\u00e1n jelzi a hib\u00e1s gyakorlatot.</p> <p>M\u00f3dos\u00edtanunk kell a <code>ShowResult</code> met\u00f3dust annak \u00e9rdek\u00e9ben, hogy mell\u00e9ksz\u00e1lb\u00f3l t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1s eset\u00e9n se dobjon kiv\u00e9telt.</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\nif (InvokeRequired)\n{\nInvoke(ShowResult, new object[] { parameters, result });\n}\nelse if (!IsDisposed)\n{\nvar lvi = listViewResult.Items.Add($\"{parameters[0]} #  {parameters[1]} = {result}\");\nlistViewResult.EnsureVisible(lvi.Index);\nlistViewResult.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);\n}\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>Ez a megold\u00e1s m\u00e1r m\u0171k\u00f6d\u0151k\u00e9pes. A <code>Form</code> oszt\u00e1ly <code>InvokeRequired</code> met\u00f3dusa igazat ad vissza, amennyiben nem az \u0151t l\u00e9trehoz\u00f3 sz\u00e1lb\u00f3l h\u00edvjuk meg. Ilyen esetekben a <code>Form</code>ot az <code>Invoke</code> met\u00f3dus\u00e1n kereszt\u00fcl tudjuk megk\u00e9rni, hogy egy adott m\u0171veletet a saj\u00e1t sz\u00e1l\u00e1n (amelyik a <code>Form</code>ot l\u00e9trehozta, ez a legt\u00f6bb alkalmaz\u00e1sban a f\u0151 sz\u00e1l) hajtson v\u00e9gre. A fenti p\u00e9ld\u00e1ban tulajdonk\u00e9ppen a <code>ShowResult</code> f\u00fcggv\u00e9ny \u00f6nmag\u00e1t h\u00edvja meg m\u00e9g egyszer, csak m\u00e1sodik esetben m\u00e1r a <code>Form</code> saj\u00e1t sz\u00e1l\u00e1n. Ez egy bevett minta a redund\u00e1ns k\u00f3dok elker\u00fcl\u00e9s\u00e9re.</p> <p>Tegy\u00fcnk t\u00f6r\u00e9spontot a <code>ShowResult</code> m\u0171velet els\u0151 sor\u00e1ra, \u00e9s az alkalmaz\u00e1st futtatva gy\u0151z\u0151dj\u00fcnk meg, hogy a <code>ShowResult</code> m\u0171velet \u2013 k\u00fcl\u00f6n\u00f6sen az <code>Invoke</code> tekintet\u00e9ben \u2013 a fentiekben ismertetetteknek megfelel\u0151en m\u0171k\u00f6dik.</p> <p>Vegy\u00fck ki a t\u00f6r\u00e9spontot, \u00edgy futtassuk az alkalmaz\u00e1st: vegy\u00fck \u00e9szre, hogy am\u00edg egy sz\u00e1m\u00edt\u00e1s fut, \u00fajabbakat is ind\u00edthatunk, hiszen a fel\u00fclet\u00fcnk v\u00e9gig reszponz\u00edv maradt.</p>"},{"location":"gyakorlat/tobbszalu/#4-feladat-muvelet-vegzese-threadpool-szalon","title":"4. feladat \u2013 M\u0171velet v\u00e9gz\u00e9se Threadpool sz\u00e1lon","text":"<p>Az el\u0151z\u0151 megold\u00e1s egy jellemz\u0151je, hogy mindig \u00faj sz\u00e1lat hoz l\u00e9tre a m\u0171velethez. Eset\u00fcnkben ennek nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge, de ez a megk\u00f6zel\u00edt\u00e9s egy olyan kiszolg\u00e1l\u00f3 alkalmaz\u00e1s eset\u00e9ben, amely nagysz\u00e1m\u00fa k\u00e9r\u00e9st szolg\u00e1l ki \u00fagy, hogy minden k\u00e9r\u00e9shez k\u00fcl\u00f6n sz\u00e1lat ind\u00edt, m\u00e1r probl\u00e9m\u00e1s lehet. K\u00e9t okb\u00f3l is:</p> <ul> <li>Ha a sz\u00e1lf\u00fcggv\u00e9ny gyorsan lefut (egy kliens kiszolg\u00e1l\u00e1sa gyors), akkor a CPU nagy r\u00e9sz\u00e9t arra pazaroljuk, hogy sz\u00e1lakat ind\u00edtsunk \u00e9s \u00e1ll\u00edtsunk le, ezek ugyanis \u00f6nmagukban is er\u0151forr\u00e1sig\u00e9nyesek.</li> <li>T\u00fal nagy sz\u00e1m\u00fa sz\u00e1l is l\u00e9trej\u00f6het, ennyit kell \u00fctemeznie az oper\u00e1ci\u00f3s rendszernek, ami feleslegesen pazarolja az er\u0151forr\u00e1sokat.</li> <li>Egy m\u00e1sik probl\u00e9ma jelen megold\u00e1sunkkal: mivel a sz\u00e1m\u00edt\u00e1s \u00fan. el\u0151t\u00e9rsz\u00e1lon fut (az \u00fajonnan l\u00e9trehozott sz\u00e1lak alap\u00e9rtelmez\u00e9sben el\u0151t\u00e9rsz\u00e1lak), hi\u00e1ba z\u00e1rjuk be az alkalmaz\u00e1st, a program tov\u00e1bb fut a h\u00e1tt\u00e9rben mindaddig, am\u00edg v\u00e9gre nem hajt\u00f3dik az utolj\u00e1ra ind\u00edtott sz\u00e1mol\u00e1s is: egy processz fut\u00e1sa ugyanis csak akkor fejez\u0151dik csak be, ha m\u00e1r nincs fut\u00f3 el\u0151t\u00e9rsz\u00e1la.</li> </ul> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy \u00faj sz\u00e1l ind\u00edt\u00e1sa helyett threadpool sz\u00e1lon futtassa a sz\u00e1m\u00edt\u00e1st. Ehhez csak a gombnyom\u00e1s esem\u00e9nykezel\u0151j\u00e9t kell ism\u00e9t \u00e1t\u00edrni.</p> <pre><code>private void buttonCalcResult_Click(object sender, EventArgs e)\n{\nif (double.TryParse(textBoxParam1.Text, out var p1) &amp;&amp; double.TryParse(textBoxParam2.Text, out var p2))\n{\nvar parameters = new double[] { p1, p2 };\n\nThreadPool.QueueUserWorkItem(CalculatorThread, parameters);\n}\nelse\n{\nMessageBox.Show(this, \"Invalid parameter!\", \"Error\");\n}\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az alkalmaz\u00e1s az ablak bez\u00e1r\u00e1sakor azonnal le\u00e1ll, nem foglalkozik az esetlegesen m\u00e9g fut\u00f3 sz\u00e1lakkal (mert a threadpool sz\u00e1lak h\u00e1tt\u00e9r sz\u00e1lak).</p>"},{"location":"gyakorlat/tobbszalu/#5-feladat-termelo-fogyaszto-alapu-megoldas","title":"5. Feladat \u2013 Termel\u0151-fogyaszt\u00f3 alap\u00fa megold\u00e1s","text":"<p>Az el\u0151z\u0151 feladatok megold\u00e1sa sor\u00e1n \u00f6nmag\u00e1ban egy j\u00f3l m\u0171k\u00f6d\u0151 komplett megold\u00e1s\u00e1t kaptuk az eredeti probl\u00e9m\u00e1nak, mely lehet\u0151v\u00e9 teszi, hogy ak\u00e1r t\u00f6bb munkasz\u00e1l is p\u00e1rhuzamosan dolgozzon a h\u00e1tt\u00e9rben a sz\u00e1m\u00edt\u00e1son, ha a gombot sokszor egym\u00e1s ut\u00e1n megnyomjuk. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1sunkat, hogy a gombnyom\u00e1sra ne mindig keletkezzen \u00faj sz\u00e1l, hanem a feladatok beker\u00fcljenek egy feladatsorba, ahonnan t\u00f6bb, a h\u00e1tt\u00e9rben folyamatosan fut\u00f3 sz\u00e1l egym\u00e1s ut\u00e1n fogja kivenni \u0151ket \u00e9s v\u00e9grehajtani. Ez a feladat a klasszikus termel\u0151-fogyaszt\u00f3 probl\u00e9ma, mely a gyakorlatban is sokszor el\u0151fordul, a m\u0171k\u00f6d\u00e9s\u00e9t az al\u00e1bbi \u00e1bra szeml\u00e9lteti.</p> <p></p> <p>Termel\u0151 fogyaszt\u00f3 vs <code>ThreadPool</code></p> <p>Ha belegondolunk, a <code>ThreadPool</code> is egy speci\u00e1lis, a .NET \u00e1ltal sz\u00e1munkra biztos\u00edtott termel\u0151-fogyaszt\u00f3 \u00e9s \u00fctemez\u0151 mechanizmus. A k\u00f6vetkez\u0151kben egy m\u00e1s jelleg\u0171 termel\u0151-fogyaszt\u00f3 megold\u00e1st dolgozunk ki annak \u00e9rdek\u00e9ben, hogy bizonyos sz\u00e1lkezel\u00e9ssel kapcsolatos konkurencia probl\u00e9m\u00e1kkal tal\u00e1lkozhassunk.</p> <p>A f\u0151sz\u00e1lunk a termel\u0151, a Calculate result gombra kattintva hoz l\u00e9tre egy \u00faj feladatot. Fogyaszt\u00f3/feldolgoz\u00f3/munkasz\u00e1lb\u00f3l az\u00e9rt ind\u00edtunk majd t\u00f6bbet, mert \u00edgy t\u00f6bb CPU magot is ki tudunk haszn\u00e1lni, valamint a feladatok v\u00e9grehajt\u00e1s\u00e1t p\u00e1rhuzamos\u00edtani tudjuk.</p> <p>A feladatok ideiglenes t\u00e1rol\u00e1s\u00e1ra a kiindul\u00f3 projekt\u00fcnkben m\u00e1r n\u00e9mik\u00e9ppen el\u0151k\u00e9sz\u00edtett <code>DataFifo</code> oszt\u00e1lyt tudjuk haszn\u00e1lni. N\u00e9zz\u00fck meg a forr\u00e1sk\u00f3dj\u00e1t. Egy egyszer\u0171 FIFO sort val\u00f3s\u00edt meg, melyben <code>double[]</code> elemeket t\u00e1rol. A <code>Put</code> met\u00f3dus hozz\u00e1f\u0171zi a bels\u0151 lista v\u00e9g\u00e9hez az \u00faj p\u00e1rokat, m\u00edg a <code>TryGet</code> met\u00f3dus visszaadja (\u00e9s elt\u00e1vol\u00edtja) a bels\u0151 lista els\u0151 elem\u00e9t. Amennyiben a lista \u00fcres, a f\u00fcggv\u00e9ny nem tud visszaadni elemet. Ilyenkor a <code>false</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelzi ezt.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy ne <code>ThreadPool</code>ba dolgozzon, hanem a FIFO-ba:</p> <pre><code>private void buttonCalcResult_Click(object sender, EventArgs e)\n{\nif (double.TryParse(textBoxParam1.Text, out var p1) &amp;&amp; double.TryParse(textBoxParam2.Text, out var p2))\n{\nvar parameters = new double[] { p1, p2 };\n\n_fifo.Put(parameters);\n}\nelse\n{\nMessageBox.Show(this, \"Invalid parameter!\", \"Error\");\n}\n}\n</code></pre> </li> <li> <p>K\u00e9sz\u00edts\u00fck el az \u00faj sz\u00e1lkezel\u0151 f\u00fcggv\u00e9ny na\u00edv implement\u00e1ci\u00f3j\u00e1t az \u0171rlap oszt\u00e1lyunkban:</p> <pre><code>private void WorkerThread()\n{\nwhile (true)\n{\nif (_fifo.TryGet(out var data))\n{\ndouble result = Algorithms.SuperAlgorithm.Calculate(data);\nShowResult(data, result);\n}\n\nThread.Sleep(500);\n}\n}\n</code></pre> <p>A <code>Thread.Sleep</code> bevezet\u00e9s\u00e9re az\u00e9rt van sz\u00fcks\u00e9g, mert e n\u00e9lk\u00fcl a munkasz\u00e1lak \u00fcres FIFO eset\u00e9n folyamatosan feleslegesen p\u00f6r\u00f6gn\u00e9nek, semmi hasznos m\u0171veletet nem v\u00e9gezve is 100%-ban kiterheln\u00e9nek egy-egy CPU magot. Megold\u00e1sunk nem ide\u00e1lis, k\u00e9s\u0151bb tov\u00e1bbfejlesztj\u00fck.</p> </li> <li> <p>Hozzuk l\u00e9tre, \u00e9s ind\u00edtsuk el a feldolgoz\u00f3 sz\u00e1lakat a konstruktorban:</p> <pre><code>new Thread(WorkerThread) { Name = \"Szal1\" }.Start();\nnew Thread(WorkerThread) { Name = \"Szal2\" }.Start();\nnew Thread(WorkerThread) { Name = \"Szal3\" }.Start();\n</code></pre> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, majd z\u00e1rjuk is be azonnal an\u00e9lk\u00fcl, hogy a Calculate Result gombra kattintan\u00e1nk. Az tapasztaljuk, hogy az ablakunk bez\u00e1r\u00f3dik ugyan, de a processz\u00fcnk tov\u00e1bb fut, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1ra csak a Visual Studiob\u00f3l, vagy a Task Managerb\u0151l van lehet\u0151s\u00e9g:</p> <p></p> <p>A feldolgoz\u00f3 sz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9p\u00e9skor megakad\u00e1lyozz\u00e1k a processz megsz\u0171n\u00e9s\u00e9t. Az egyik megold\u00e1s az lehetne, ha a sz\u00e1lak <code>IsBackground</code> tulajdons\u00e1g\u00e1t <code>true</code>-ra \u00e1ll\u00edtan\u00e1nk a l\u00e9trehoz\u00e1sukat k\u00f6vet\u0151en. A m\u00e1sik megold\u00e1s, hogy kil\u00e9p\u00e9skor gondoskodunk a feldolgoz\u00f3 sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9r\u0151l. Egyel\u0151re tegy\u00fck f\u00e9lre ezt a probl\u00e9m\u00e1t, k\u00e9s\u0151bb visszat\u00e9r\u00fcnk r\u00e1.</p> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st azt tapasztaljuk, hogy miut\u00e1n kattintunk a Calculate Result gombon (csak egyszer kattintsunk rajta) nagy val\u00f3sz\u00edn\u0171s\u00e9ggel kiv\u00e9telt fogunk kapni. A probl\u00e9ma az, hogy a <code>DataFifo</code> nem sz\u00e1lbiztos, inkonzisztens\u00e9 v\u00e1lt. K\u00e9t ered\u0151 ok is h\u00faz\u00f3dik a h\u00e1tt\u00e9rben:</p> </li> </ol>"},{"location":"gyakorlat/tobbszalu/#problema-1","title":"Probl\u00e9ma 1","text":"<p>N\u00e9zz\u00fck a k\u00f6vetkez\u0151 forgat\u00f3k\u00f6nyvet:</p> <ol> <li>A sor \u00fcres. A feldolgoz\u00f3 sz\u00e1lak egy <code>while</code> ciklusban folyamatosan pollozz\u00e1k a FIFO-t, vagyis h\u00edvj\u00e1k a <code>TryGet</code> met\u00f3dus\u00e1t.</li> <li>A felhaszn\u00e1l\u00f3 egy feladatot tesz a sorba.</li> <li>Az egyik feldolgoz\u00f3 sz\u00e1l a <code>TryGet</code> met\u00f3dusban azt l\u00e1tja, van adat a sorban, vagyis <code>if ( _innerList.Count &gt; 0 )</code> k\u00f3dsor felt\u00e9tele teljes\u00fcl, \u00e9s r\u00e1l\u00e9p a k\u00f6vetkez\u0151 k\u00f3dsorra. Tegy\u00fck fel, hogy ez a sz\u00e1l ebben a pillanatban elveszti a fut\u00e1si jog\u00e1t, m\u00e1r nincs ideje kivenni az adatot a sorb\u00f3l.</li> <li>Egy m\u00e1sik feldolgoz\u00f3 sz\u00e1l is \u00e9ppen ekkor ejti meg az <code>if ( _innerList.Count &gt; 0 )</code> vizsg\u00e1latot, n\u00e1la is teljes\u00fcl a felt\u00e9tel, \u00e9s ez a sz\u00e1l ki is veszi az adatot a sorb\u00f3l.</li> <li>Az els\u0151 sz\u00e1lunk \u00fajra \u00fctemez\u00e9sre ker\u00fcl, fel\u00e9bred, \u0151 is megpr\u00f3b\u00e1lja kivenni az adatot a sorb\u00f3l: a sor viszont m\u00e1r \u00fcres, a m\u00e1sik sz\u00e1lunk kivette az egyetlen adatot a sorb\u00f3l az orra el\u0151tt. \u00cdgy az <code>_innerList[0]</code> hozz\u00e1f\u00e9r\u00e9s kiv\u00e9telt eredm\u00e9nyez.</li> </ol> <p>Ezt a probl\u00e9m\u00e1t csak \u00fagy tudjuk elker\u00fclni, ha a sor \u00fcress\u00e9g\u00e9nek a vizsg\u00e1lat\u00e1t \u00e9s az elem kiv\u00e9tel\u00e9t oszthatatlann\u00e1 tessz\u00fck.</p> <p>Thread.Sleep(500)</p> <p>Az \u00fcress\u00e9gvizsg\u00e1latot figyel\u0151 k\u00f3dsort k\u00f6vet\u0151 <code>Thread.Sleep(500);</code> k\u00f3dsornak csak az a szerepe a p\u00e9ldak\u00f3dunkban, hogy a fenti peches forgat\u00f3k\u00f6nyv bek\u00f6vetkez\u00e9s\u00e9nek a val\u00f3sz\u00edn\u0171s\u00e9g\u00e9t megn\u00f6velje, s \u00edgy a p\u00e9ld\u00e1t szeml\u00e9letesebb\u00e9 tegye (mivel ilyenkor szinte biztos, hogy \u00e1t\u00fctemez\u0151dik a sz\u00e1l). A k\u00e9s\u0151bbiekben ezt ki is fogjuk venni, egyel\u0151re hagyjuk benne.</p>"},{"location":"gyakorlat/tobbszalu/#problema-2","title":"Probl\u00e9ma 2","text":"<p>A <code>DataFifo</code> oszt\u00e1ly egyid\u0151ben t\u00f6bb sz\u00e1lb\u00f3l is hozz\u00e1f\u00e9rhet a <code>List&lt;double[]&gt;</code> t\u00edpus\u00fa <code>_innerList</code> tagv\u00e1ltoz\u00f3hoz. Ugyanakkor, ha megn\u00e9zz\u00fck a <code>List&lt;T&gt;</code> dokument\u00e1ci\u00f3j\u00e1t, azt tal\u00e1ljuk, hogy az oszt\u00e1ly nem sz\u00e1lbiztos (not thread safe). Ez esetben viszont ez nem tehetj\u00fck meg, nek\u00fcnk kell z\u00e1rakkal biztos\u00edtanunk, hogy a k\u00f3dunk egyid\u0151ben csak egy met\u00f3dus\u00e1hoz / tulajdons\u00e1g\u00e1hoz / tagv\u00e1ltoz\u00f3j\u00e1hoz f\u00e9r hozz\u00e1 (pontosabban inkonzisztencia csak egyidej\u0171 \u00edr\u00e1s, illetve egyidej\u0171 \u00edr\u00e1s \u00e9s olvas\u00e1s eset\u00e9n l\u00e9phet fel, de az \u00edr\u00f3kat \u00e9s az olvas\u00f3kat a legt\u00f6bb esetben nem szoktuk megk\u00fcl\u00f6nb\u00f6ztetni, itt sem tessz\u00fck).</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a <code>DataFifo</code> oszt\u00e1lyunkat sz\u00e1lbiztoss\u00e1 tessz\u00fck, amivel megakad\u00e1lyozzuk, hogy a fenti k\u00e9t probl\u00e9ma bek\u00f6vetkezhessen.</p>"},{"location":"gyakorlat/tobbszalu/#6-feladat-tegyuk-szabiztossa-a-datafifo-osztalyt","title":"6. feladat \u2013 Tegy\u00fck sz\u00e1biztoss\u00e1 a DataFifo oszt\u00e1lyt","text":"<p>A <code>DataFifo</code> oszt\u00e1ly sz\u00e1lbiztoss\u00e1 t\u00e9tel\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy objektumra (ez b\u00e1rmilyen referencia t\u00edpus\u00fa objektum lehet), melyet kulcsk\u00e9nt haszn\u00e1lhatunk a z\u00e1rol\u00e1sn\u00e1l. Ezt k\u00f6vet\u0151en a <code>lock</code> kulcssz\u00f3 seg\u00edts\u00e9g\u00e9vel el tudjuk \u00e9rni, hogy egyszerre mindig csak egy sz\u00e1l tart\u00f3zkodjon az adott kulccsal v\u00e9dett blokkokban.</p> <ol> <li> <p>Vegy\u00fcnk fel egy <code>object</code> t\u00edpus\u00fa mez\u0151t <code>_syncRoot</code> n\u00e9ven a <code>DataFifo</code> oszt\u00e1lyba.</p> <pre><code>private object _syncRoot = new object();\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Put</code> \u00e9s a <code>TryGet</code> f\u00fcggv\u00e9nyeket a z\u00e1rol\u00e1ssal.</p> <pre><code>public void Put(double[] data)\n{\nlock (_syncRoot)\n{\n_innerList.Add(data); }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\nlock (_syncRoot)\n{\nif (_innerList.Count &gt; 0)\n{\nThread.Sleep(500);\n\ndata = _innerList[0];\n_innerList.RemoveAt(0);\nreturn true;\n}\n\ndata = null;\nreturn false;\n}\n}\n</code></pre> <p>Surround with</p> <p>Haszn\u00e1ljuk a Visual Studio Surround with funkci\u00f3j\u00e1t a CTRL + K, CTRL + S billenty\u0171 kombin\u00e1ci\u00f3j\u00e1val a k\u00f6r\u00fclvenni k\u00edv\u00e1nt kijel\u00f6lt k\u00f3dr\u00e9szleten.</p> </li> </ol> <p>Most m\u00e1r nem szabad kiv\u00e9telt kapnunk.</p> <p>Ki is vehetj\u00fck a <code>TryGet</code> met\u00f3dusb\u00f3l a mesters\u00e9ges k\u00e9sleltet\u00e9st (<code>Thread.Sleep(500);</code> sor).</p> <p>Lockol\u00e1s <code>this</code>-en</p> <p>Felmer\u00fclhet a k\u00e9rd\u00e9s, hogy mi\u00e9rt vezett\u00fcnk be egy k\u00fcl\u00f6n <code>_syncRoot</code> tagv\u00e1ltoz\u00f3t \u00e9s haszn\u00e1ltuk ezt z\u00e1rol\u00e1sra a <code>lock</code> param\u00e9terek\u00e9nt, amikor a <code>this</code>-t is haszn\u00e1lhattuk volna helyette (a <code>DataFifo</code> referencia t\u00edpus, \u00edgy ennek nem lenne akad\u00e1lya). A <code>this</code> alkalmaz\u00e1sa azonban s\u00e9rten\u00e9 az oszt\u00e1lyunk egys\u00e9gbez\u00e1r\u00e1s\u00e1t! Ne feledj\u00fck: a <code>this</code> egy referencia az objektumunkra, de m\u00e1s oszt\u00e1lyoknak is van ugyanerre az objektumra referenci\u00e1juk (pl. eset\u00fcnkben a <code>MainForm</code>-nak van referenci\u00e1ja a <code>DataFifo</code>-ra), \u00e9s ha ezek a k\u00fcls\u0151 oszt\u00e1lyok z\u00e1rat tesznek a <code>lock</code> seg\u00edts\u00e9g\u00e9vel az objektumra, akkor az \"interfer\u00e1l\" az \u00e1ltalunk az oszt\u00e1lyon bel\u00fck haszn\u00e1lt z\u00e1rol\u00e1ssal (mivel <code>this</code> alkalmaz\u00e1sa miatt a k\u00fcls\u0151 \u00e9s bels\u0151 <code>lock</code>-ok param\u00e9tere ugyanaz lesz). \u00cdgy pl. egy k\u00fcls\u0151 z\u00e1rral teljesen meg lehet \"b\u00e9n\u00edtani\" a <code>TryGet</code> \u00e9s <code>Put</code> m\u0171velet m\u0171k\u00f6d\u00e9s\u00e9t. Ezzel szemben az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban a <code>lock</code> param\u00e9tere, a <code>_syncRoot</code> v\u00e1ltoz\u00f3 priv\u00e1t, ehhez m\u00e1r k\u00fcls\u0151 oszt\u00e1lyok nem f\u00e9rhetnek hozz\u00e1, \u00edgy nem is zavarhatj\u00e1k meg az oszt\u00e1lyunk bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9t.</p>"},{"location":"gyakorlat/tobbszalu/#7-feladat-hatekony-jelzes-megvalositasa","title":"7. feladat \u2013 Hat\u00e9kony jelz\u00e9s megval\u00f3s\u00edt\u00e1sa","text":""},{"location":"gyakorlat/tobbszalu/#manualresetevent-hasznalata","title":"ManualResetEvent haszn\u00e1lata","text":"<p>A <code>WorkerThread</code>-ben folyamatosan fut\u00f3 <code>while</code> ciklus \u00fan. akt\u00edv v\u00e1rakoz\u00e1st val\u00f3s\u00edt meg, ami mindig ker\u00fclend\u0151. Ha a <code>Thread.Sleep</code>-et nem tett\u00fck volna a ciklusmagba, akkor ezzel maximumra ki is terheln\u00e9 a processzort. A <code>Thread.Sleep</code> megoldja ugyan a processzor terhel\u00e9s probl\u00e9m\u00e1t, de bevezet egy m\u00e1sikat: ha mindh\u00e1rom munkasz\u00e1lunk \u00e9ppen alv\u00f3 \u00e1llapotba l\u00e9pett, mikor be\u00e9rkezik egy \u00faj adat, akkor feleslegesen v\u00e1runk 500 ms-ot az adat feldolgoz\u00e1s\u00e1nak megkezd\u00e9s\u00e9ig.</p> <p>A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1st, hogy blokkolva v\u00e1rakozzon, am\u00edg adat nem ker\u00fcl a FIFO-ba (amikor viszont adat ker\u00fcl bele, azonnal kezdje meg a feldolgoz\u00e1st). Annak jelz\u00e9s\u00e9re, hogy van-e adat a sorban egy <code>ManualResetEvent</code>-et fogunk haszn\u00e1lni.</p> <ol> <li> <p>Adjunk hozz\u00e1 egy <code>MaunalResetEvent</code> p\u00e9ld\u00e1nyt a <code>DataFifo</code> oszt\u00e1lyunkhoz <code>_hasData</code> n\u00e9ven.</p> <pre><code>// A false konstruktor param\u00e9ter eredm\u00e9nyek\u00e9ppen kezdetben az esem\u00e9ny nem jelzett (kapu csukva)\nprivate ManualResetEvent _hasData = new ManualResetEvent(false);\n</code></pre> </li> <li> <p>A <code>_hasData</code> alkalmaz\u00e1sunkban kapuk\u00e9nt viselkedik. Amikor adat ker\u00fcl a list\u00e1ba \u201ekinyitjuk\u201d, m\u00edg amikor ki\u00fcr\u00fcl a lista \u201ebez\u00e1rjuk\u201d.</p> <p>Az esem\u00e9ny szemantik\u00e1ja \u00e9s elnevez\u00e9se</p> <p>L\u00e9nyeges, hogy j\u00f3 v\u00e1lasszuk meg az esem\u00e9ny\u00fcnk szemantik\u00e1j\u00e1t \u00e9s ezt a v\u00e1ltoz\u00f3nk nev\u00e9vel pontosan ki is fejezz\u00fck. A p\u00e9ld\u00e1nkban a <code>_hasData</code> n\u00e9v j\u00f3l kifejezi, hogy pontosan akkor \u00e9s csak akkor jelzett az esem\u00e9ny\u00fcnk (nyitott a kapu), amikor van feldolgozand\u00f3 adat. Most m\u00e1r \"csak\" az a dolgunk, hogy ezt a szemantik\u00e1t megval\u00f3s\u00edtsuk: jelzettbe tegy\u00fck az esem\u00e9nyt, mikor adat ker\u00fcl a FIFO-ba, \u00e9s jelzetlenbe, amikor ki\u00fcr\u00fcl a FIFO.</p> <pre><code>public void Put(double[] data)\n{\nlock (_syncRoot)\n{\n_innerList.Add(data);\n_hasData.Set();\n}\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\nlock (_syncRoot)\n{\nif (_innerList.Count &gt; 0)\n{\ndata = _innerList[0];\n_innerList.RemoveAt(0);\nif (_innerList.Count == 0)\n{\n_hasData.Reset();\n}\nreturn true;\n}\n\ndata = null;\nreturn false;\n}\n}\n</code></pre> </li> </ol>"},{"location":"gyakorlat/tobbszalu/#jelzesre-varakozas-blokkolo-a-get","title":"Jelz\u00e9sre v\u00e1rakoz\u00e1s (blokkol\u00f3 a Get)","text":"<p>Az el\u0151z\u0151 pontban megoldottuk a jelz\u00e9st, \u00e1m ez \u00f6nmag\u00e1ban nem sokat \u00e9r, hiszen nem v\u00e1rakoznak r\u00e1. Ennek megval\u00f3s\u00edt\u00e1sa j\u00f6n most.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a met\u00f3dust az al\u00e1bbiak szerint: kidobjuk az \u00fcress\u00e9g vizsg\u00e1latot \u00e9s az esem\u00e9nyre val\u00f3 v\u00e1rakoz\u00e1ssal p\u00f3toljuk.</p> <pre><code>public bool TryGet(out double[] data)\n{\nlock (_syncRoot)\n{\nif (_hasData.WaitOne())\n{\n// ...\n</code></pre> <p>A WaitOne m\u0171velet visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9nek vizsg\u00e1lata</p> <p>A <code>WaitOne</code> m\u0171velet egy <code>bool</code> \u00e9rt\u00e9kkel t\u00e9r vissza, mely igaz, ha a <code>WaitOne</code> param\u00e9ter\u00e9ben megadott id\u0151korl\u00e1t el\u0151tt jelzett \u00e1llapotba ker\u00fcl az esem\u00e9ny (ill. ennek megfelel\u0151en hamis, ha lej\u00e1rt az id\u0151korl\u00e1t). A p\u00e9ld\u00e1nkban nem adtunk meg id\u0151korl\u00e1tot param\u00e9terben, mely v\u00e9gtelen id\u0151korl\u00e1t alkalmaz\u00e1s\u00e1t jelenti. Ennek megfelel\u0151en felesleges is az <code>if</code> felt\u00e9telvizsg\u00e1lat, hiszen eset\u00fcnkben a <code>WaitOne()</code> mindig igaz \u00e9rt\u00e9kkel t\u00e9r vissza. Ez egyetlen ok, ami\u00e9rt m\u00e9gis \u00e9lt\u00fcnk felt\u00e9telvizsg\u00e1lattal: \u00edgy a k\u00f6vetketkez\u0151 \u00e9s egy k\u00e9s\u0151bbi feladatn\u00e1l kisebb \u00e1talak\u00edt\u00e1sra lesz majd sz\u00fcks\u00e9g.</p> </li> <li> <p>Ezzel a <code>Thread.Sleep</code> a <code>WorkerThread</code>-ben feleslegess\u00e9 v\u00e1lt, kommentezz\u00fck ki!</p> <p>A fenti megold\u00e1s futtat\u00e1sakor azt tapasztaljuk, hogy az alkalmaz\u00e1sunk fel\u00fclete az els\u0151 gombnyom\u00e1st k\u00f6vet\u0151en befagy. Az el\u0151z\u0151 megold\u00e1sunkban ugyanis egy amat\u0151r hib\u00e1t k\u00f6vett\u00fcnk el. A lock-olt k\u00f3dr\u00e9szleten bel\u00fcl v\u00e1rakozunk a <code>_hasData</code> jelz\u00e9s\u00e9re, \u00edgy a f\u0151sz\u00e1lnak lehet\u0151s\u00e9ge sincs arra, hogy a <code>Put</code> m\u0171veletben (egy szint\u00e9n <code>lock</code>-kal v\u00e9dett r\u00e9szen bel\u00fcl) jelz\u00e9st k\u00fcldj\u00f6n <code>_hasData</code>-val. Gyakorlatilag egy holtpont (deadlock) helyzet alakult ki.</p> <p>Gyors hibajav\u00edt\u00e1sk\u00e9nt megadhatunk egy id\u0151korl\u00e1tot (ms) a v\u00e1rakoz\u00e1sn\u00e1l:</p> <pre><code>if (_hasData.WaitOne(100))\n</code></pre> <p>Tesztelj\u00fck az alkalmaz\u00e1st! A megold\u00e1s ugyan fut, de az eleg\u00e1ns \u00e9s k\u00f6vetend\u0151 minta az, hogy lock-on bel\u00fcl ker\u00fclj\u00fck a blokkolva v\u00e1rakoz\u00e1st.</p> <p>Val\u00f3di jav\u00edt\u00e1sk\u00e9nt cser\u00e9lj\u00fck meg a <code>lock</code>-ot \u00e9s a <code>WaitOne</code>-t, illetve a <code>WaitOne</code> param\u00e9ter elt\u00e1vol\u00edt\u00e1s\u00e1val sz\u00fcntess\u00fck meg a v\u00e1rakoz\u00e1si id\u0151korl\u00e1tot:</p> <pre><code>public bool TryGet(out double[] data)\n{\nif (_hasData.WaitOne())\n{\nlock (_syncRoot)\n{\ndata = _innerList[0];\n_innerList.RemoveAt(0);\nif (_innerList.Count == 0)\n{\n_hasData.Reset();\n}\n\nreturn true; }\n}\n\ndata = null;\nreturn false;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Az els\u0151 gombnyom\u00e1s hat\u00e1s\u00e1ra kiv\u00e9telt kapunk. \u00cdgy elker\u00fclj\u00fck ugyan a deadlockot, azonban a sz\u00e1lbiztoss\u00e1g s\u00e9r\u00fclt, hiszen mire a <code>lock</code>-on bel\u00fclre jutunk, nem biztos, hogy maradt elem a list\u00e1ban. Ugyanis lehet, t\u00f6bb sz\u00e1l is v\u00e1rakozik a <code>_hasData.WaitOne()</code> m\u0171veletn\u00e9l arra, hogy elem ker\u00fclj\u00f6n a sorba. Mikor ez bek\u00f6vetkezik, a <code>ManualResetEvent</code> objektumunk mind \u00e1tengedi (hacsak \u00e9ppen gyorsan le nem csukja egy sz\u00e1l, de ez nem garant\u00e1lt).</p> <p>A konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s neh\u00e9zs\u00e9gei</p> <p>J\u00f3l illusztr\u00e1lja a feladat, hogy milyen alapos \u00e1tgondol\u00e1st ig\u00e9nyel a konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s. Tulajdonk\u00e9ppen m\u00e9g szerencs\u00e9nk is volt az el\u0151z\u0151ekben, mert j\u00f3l reproduk\u00e1lhat\u00f3an el\u0151j\u00f6tt a hiba. A gyakorlatban azonban ez ritk\u00e1n van \u00edgy. Sajnos sokkal gyakoribb, hogy a konkurenciahib\u00e1k id\u0151nk\u00e9nti, nem reproduk\u00e1lhat\u00f3 probl\u00e9m\u00e1kat okoznak. Az ilyen jelleg\u0171 feladatok megold\u00e1s\u00e1t mindig nagyon \u00e1t kell gondolni, nem lehet az \"addig-pr\u00f3b\u00e1lkozom-m\u00edg-j\u00f3-nem-lesz-a-k\u00e9zi-teszt-sor\u00e1n\" elv ment\u00e9n leprogramozni.</p> </li> <li> <p>Jav\u00edt\u00e1sk\u00e9nt tegy\u00fck vissza a <code>lock</code>-on bel\u00fcli \u00fcress\u00e9g-vizsg\u00e1latot.</p> <pre><code>public bool TryGet(out double[] data)\n{\nif (_hasData.WaitOne())\n{\nlock (_syncRoot)\n{\nif (_innerList.Count &gt; 0)\n{\ndata = _innerList[0];\n_innerList.RemoveAt(0);\nif (_innerList.Count == 0)\n{\n_hasData.Reset();\n}\n\nreturn true;  }\n}\n}\n\ndata = null;\nreturn false;\n}\n</code></pre> <p>Ez m\u00e1r j\u00f3l m\u0171k\u00f6dik. El\u0151fordulhat ugyan, hogy feleslegesen fordulunk a list\u00e1hoz, de ezzel \u00edgy most megel\u00e9gsz\u00fcnk.</p> <p>Tesztelj\u00fck az alkalmaz\u00e1st!</p> </li> </ol> <p>System.Collections.Concurrent</p> <p>A .NET keretrendszerben t\u00f6bb be\u00e9p\u00edtett sz\u00e1lbiztoss\u00e1gra felk\u00e9sz\u00edtett oszt\u00e1ly is tal\u00e1lhat\u00f3 a <code>System.Collections.Concurrent</code> n\u00e9vt\u00e9rben. A fenti p\u00e9ld\u00e1ban a <code>DataFifo</code> oszt\u00e1lyt a <code>System.Collections.Concurrent.ConcurrentQueue</code> oszt\u00e1llyal kiv\u00e1lthattuk volna.</p>"},{"location":"gyakorlat/tobbszalu/#8-feladat-kulturalt-leallas","title":"8. feladat \u2013 Kultur\u00e1lt le\u00e1ll\u00e1s","text":"<p>Kor\u00e1bban f\u00e9lretett\u00fck azt a probl\u00e9m\u00e1t, hogy az ablakunk bez\u00e1r\u00e1sakor a processz\u00fcnk \u201eberagad\u201d, ugyanis a feldolgoz\u00f3 munkasz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9ptet\u00e9s\u00fcket eddig nem oldottuk meg. C\u00e9lunk, hogy a v\u00e9gtelen <code>while</code> ciklust kiv\u00e1ltva a munkasz\u00e1laink az alkalmaz\u00e1s bez\u00e1r\u00e1sakor kultur\u00e1lt m\u00f3don \u00e1lljanak le.</p> <ol> <li> <p>Egy <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel jelezz\u00fck a le\u00e1ll\u00edt\u00e1st a FIFO-ban a <code>TryGet</code>-ben t\u00f6rt\u00e9n\u0151 v\u00e1rakoz\u00e1s sor\u00e1n. A FIFO-ban vegy\u00fcnk fel egy \u00faj <code>ManualResetEvent</code>-et, \u00e9s vezess\u00fcnk be egy <code>Release</code> m\u0171veletet, amellyel a v\u00e1rakoz\u00e1sainkat z\u00e1rhatjuk r\u00f6vidre (\u00faj esem\u00e9ny\u00fcnk jelzett \u00e1llapotba \u00e1ll\u00edthat\u00f3).</p> <pre><code>private ManualResetEvent _releaseTryGet = new ManualResetEvent(false);\n\npublic void Release()\n{\n_releaseTryGet.Set();\n}\n</code></pre> </li> <li> <p>A <code>TryGet</code>-ben erre az esem\u00e9nyre is v\u00e1rakozzunk. A <code>WaitAny</code> met\u00f3dus akkor engedi tov\u00e1bb a futtat\u00e1st, ha a param\u00e9terk\u00e9nt megadott <code>WaitHandle</code> t\u00edpus\u00fa objektumok k\u00f6z\u00fcl valamelyik jelzett \u00e1llapotba ker\u00fcl, \u00e9s visszaadja annak t\u00f6mbb\u00e9li index\u00e9t. T\u00e9nyleges adatfeldolgoz\u00e1st pedig csak akkor szeretn\u00e9nk, ha a <code>_hasData</code> jelzett (amikor is a <code>WaitAny</code> 0-val t\u00e9r vissza).</p> <pre><code>public bool TryGet(out double[] data)\n{\nif (WaitHandle.WaitAny(new[] { _hasData, _releaseTryGet }) == 0)\n{\nlock (_syncRoot)\n{\n</code></pre> </li> <li> <p><code>MainForm.cs</code>-ban vegy\u00fcnk fel egy flag tagv\u00e1ltoz\u00f3t a bez\u00e1r\u00e1s jelz\u00e9s\u00e9re:</p> <pre><code>private bool _isClosed = false;\n</code></pre> </li> <li> <p>A form bez\u00e1r\u00e1sakor \u00e1ll\u00edtsuk jelzettre az \u00faj esem\u00e9nyt \u00e9s billents\u00fcnk be be a flag-et is. (A <code>Form</code> oszt\u00e1ly <code>OnClosed</code> met\u00f3dusa mindig megh\u00edv\u00f3dik bez\u00e1r\u00e1skor, a <code>Dispose</code>-zal ellent\u00e9tben.)</p> <pre><code>protected override void OnClosed(EventArgs e)\n{\nbase.OnClosed(e);\n_isClosed = true;\n_fifo.Release();\n}\n</code></pre> </li> <li> <p>\u00cdrjuk \u00e1t a while ciklust az el\u0151z\u0151 pontban felvett flag figyel\u00e9s\u00e9re.</p> <pre><code>private void WorkerThread()\n{\nwhile (!_isClosed)\n{\n</code></pre> </li> <li> <p>V\u00e9g\u00fcl biztos\u00edtsuk, hogy a m\u00e1r bez\u00e1r\u00f3d\u00f3 ablak eset\u00e9ben ne pr\u00f3b\u00e1ljunk \u00fczeneteket ki\u00edrni</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\nif (_isClosed)\nreturn;\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s ellen\u0151rizz\u00fck, kil\u00e9p\u00e9skor az processz\u00fcnk val\u00f3ban befejezi-e a fut\u00e1s\u00e1t.</p> </li> </ol> <p>Hol h\u00edvjunk Release-t? (kitekint\u00e9s - nem k\u00f6telez\u0151 anyag)</p> <p>Az <code>OnClosed</code> vagy <code>OnClosing</code> \u00e9letciklus f\u00fcggv\u00e9nyei a Formnak j\u00f3 v\u00e1laszt\u00e1sok, mert azokr\u00f3l biztosan tudjuk, hogy helyesen h\u00edv\u00f3dnak meg minden esetben. Cser\u00e9ben egy plusz flag-et kell karbantartanunk. </p> <p>Egyik alternat\u00edva lehetne m\u00e9g az \u00e9letciklus esem\u00e9nyek helyett a <code>Dispose</code> met\u00fadusba rakni ezt a logik\u00e1t, \u00e9s akkor az <code>IsDisposed</code> be\u00e9p\u00edtett flag-et is haszn\u00e1lhatn\u00e1nk. Ezt k\u00e9t okb\u00f3l is \u00e9rdemes ker\u00fclni Formok eset\u00e9ben:</p> <ol> <li>A <code>Dispose</code> met\u00f3dus m\u00e1r l\u00e9tezik a <code>MainForm.Designer.cs</code> f\u00e1jlban, \u00e9s a <code>Designer.cs</code> f\u00e1jlokat alapvet\u0151en nem szok\u00e1s szerkeszteni, b\u00e1r ezt a met\u00f3dust a designer m\u00e1r nem piszk\u00e1lja, ha m\u00e1r l\u00e9trej\u00f6tt a form, \u00edgy ezt ak\u00e1r nyugodtan \u00e1t is helyezhetn\u00e9nk a <code>MainForm.cs</code>-be.</li> <li>A <code>Dispose</code> megh\u00edv\u00e1sa nem mindig determinisztikus Windows Forms eset\u00e9ben, mert el\u0151fordulhat, hogy nem a keretrendszer nyitotta a formot, hanem a fejleszt\u0151 programozottan, \u00e9s elfelejtette <code>Dispose</code>-t h\u00edvni rajta, aminek a hat\u00e1s\u00e1ra, majd csak a GC fogja megh\u00edvni a <code>Dispose</code> f\u00fcggv\u00e9nyt.</li> </ol> <p>A <code>Release</code> m\u0171velet helyett m\u00e9g egy m\u00e1sik alternat\u00edva lehetne, hogy az <code>IDisposable</code> mint\u00e1t megval\u00f3s\u00edtjuk a <code>DataFifo</code>-ba, de ilyenkor is k\u00e9zzel kellene <code>Dispose</code>-t h\u00edvni, mivel nem f\u00fcggv\u00e9ny szint\u0171 az \u00e9letciklusa a FIFO objektumnak, \u00edgy nem tudn\u00e1nk <code>using</code> blokkban haszn\u00e1lni.</p> <p>Egy \u00f6sszetett alkalmaz\u00e1sban egy\u00e9nk\u00e9nt gyakran nem k\u00e9zzel kezelj\u00fck egy-egy oszt\u00e1lynak a f\u00fcgg\u0151s\u00e9geit \u00e9s az \u00e9letciklus\u00e1t. Helyette a Dependency Injection tervez\u00e9si mint\u00e1t \u00e9rdemes alkalmazni, ahol egy k\u00fcl\u00f6n komponensbe szervezz\u00fck ki az objektumok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t \u00e9s \u00e9letciklus\u00e1nak kezel\u00e9s\u00e9t.</p>"},{"location":"gyakorlat/tobbszalu/#kitekintes-task-async-await","title":"Kitekint\u00e9s: Task, async, await","text":"<p>A t\u00e1rgynak nem anyaga, de .NET alkalmaz\u00e1sok (\u00e9s m\u00e1s modern nyelv\u0171 alkalmaz\u00e1sok (Swift, Kotlin, TypeScript, stb.)) eset\u00e9ben megker\u00fclhetetlen az aszinkron programoz\u00e1s koncepci\u00f3ja. A C# (\u00e9s m\u00e1s modern nyelvek) nyelvi szintre emelt\u00e9k az szinkron esem\u00e9nyek bev\u00e1r\u00e1s\u00e1nak kezel\u00e9s\u00e9t az <code>async</code>/<code>await</code> kulcsszavakkal (L\u00e1sd b\u0151vebben)</p> <p>M\u00e9gis ehhez az anyaghoz laz\u00e1n \u00fagy kapcsol\u00f3dhat ez a t\u00e9ma, hogy a <code>Task</code> oszt\u00e1ly olyan aszinkron m\u0171veletet is reprezent\u00e1lhat, ami ak\u00e1r k\u00fcl\u00f6n sz\u00e1lon is futhat (de nem k\u00f6telez\u0151en futnak ezek k\u00fcl\u00f6n sz\u00e1lon!), \u00e9s bev\u00e1rhat\u00f3 ennek az eredm\u00e9nye aszinkron m\u00f3don. A <code>Task.Run</code> statikus f\u00fcggv\u00e9ny pedig egyenesen a <code>ThreadPool</code>-on \u00fctemez egy m\u0171veletet, ami \u00edgy aszinkron bev\u00e1rhat\u00f3.</p>"},{"location":"hazi/","title":"\u00d6n\u00e1ll\u00f3/h\u00e1zi feladatok","text":"<p>Valamennyi h\u00e1zi feladat elk\u00e9sz\u00edt\u00e9se k\u00f6telez\u0151. A megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik (b\u0151vebben itt). Az \u00f6n\u00e1ll\u00f3/h\u00e1zi feladatokra vonatkoz\u00f3 pontos k\u00f6vetelm\u00e9nyek Moodle-ben olvashat\u00f3k alatt olvashat\u00f3k (a \"H\u00e1zi feladat \u00e1ltal\u00e1nos inform\u00e1ci\u00f3k\" oldalon, a f\u0151oldalr\u00f3l el\u00e9rhet\u0151).</p>"},{"location":"hazi/#a-feladatok-beadasa","title":"A feladatok bead\u00e1sa","text":"<p>Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt. K\u00e9r\u00fcnk, alaposan olvasd v\u00e9gig a le\u00edr\u00e1st!</p> <p>FONTOS</p> <p>A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zi feladatokat nem \u00e9rt\u00e9kelj\u00fck.</p> <p>A h\u00e1zi feladatokhoz egy el\u0151ellen\u0151rz\u0151 is tartozik, err\u0151l itt olvashatsz b\u0151vebben.</p>"},{"location":"hazi/#windows-forms-alapu-hazi-feladatok","title":"Windows Forms alap\u00fa h\u00e1zi feladatok","text":"<p>A Windows Forms alap\u00fa h\u00e1zi feladatok kapcs\u00e1n n\u00e9mi extra inform\u00e1ci\u00f3 (rendszerk\u00f6vetelm\u00e9nyek, esetleges Visual Studio probl\u00e9m\u00e1k kezel\u00e9se) itt.</p>"},{"location":"hazi/beadas-ellenorzes/","title":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k","text":"<ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/document-view-architektura/","title":"Document-View architekt\u00fara h\u00e1zi feladat (Signals)","text":""},{"location":"hazi/document-view-architektura/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A feladat meg\u00e9rt\u00e9se szempontj\u00e1b\u00f3l kulcsfontoss\u00e1g\u00fa a Document-View architekt\u00fara r\u00e9szletekbe men\u0151 ismerete, pl. az el\u0151ad\u00e1sanyag, illetve a kapcsol\u00f3d\u00f3 gyakorlat alapj\u00e1n.</p> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok:</p> <ul> <li>Document-View architekt\u00fara elm\u00e9leti ismerete \u00e9s alkalmaz\u00e1sa egyszer\u0171 k\u00f6rnyezetben</li> <li>C# property, delegate, event alkalmaz\u00e1stechnik\u00e1ja</li> <li>Windows Forms alkalmaz\u00e1sok fejleszt\u00e9s\u00e9nek alapjai (<code>Form</code>, vez\u00e9rl\u0151elemek, esem\u00e9nykezel\u00e9s)</li> <li>Grafikus megjelen\u00edt\u00e9s Windows Forms alkalmaz\u00e1sokban</li> <li><code>UserControl</code> \u00e9s haszn\u00e1lata</li> </ul> <p>Kapcsol\u00f3d\u00f3 laborgyakorlatok:</p> <ul> <li>A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa laborgyakorlat</li> <li>Document-View architekt\u00fara laborgyakorlat</li> </ul> <p>Az h\u00e1zi feladat c\u00e9lja:</p> <ul> <li>UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa</li> <li>A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban</li> <li>A <code>UserControl</code> szerep\u00e9nek bemutat\u00e1sa Windows Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n</li> <li>A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Windows Forms alkalmaz\u00e1sokban (<code>Paint</code> esem\u00e9ny, <code>Invalidate</code>, <code>Graphics</code> haszn\u00e1lata)</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezet a szok\u00e1sos.</p>"},{"location":"hazi/document-view-architektura/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod!</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>Signals.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> <li> A beadott megold\u00e1sok mell\u00e9 k\u00fcl\u00f6n indokl\u00e1st, illetve le\u00edr\u00e1st nem v\u00e1runk el, ugyanakkor az elfogad\u00e1s felt\u00e9tele, hogy a beadott k\u00f3dban a Feladat 3 \u2013 Jelek grafikus megjelen\u00edt\u00e9se, saj\u00e1t n\u00e9zet oszt\u00e1ly fejezet feladatainak a megold\u00e1s\u00e1t kommentekkel kell ell\u00e1tni. A t\u00f6bbi fejezet feladatainak megold\u00e1s\u00e1t NEM kell kommentezni.</li> </ul>"},{"location":"hazi/document-view-architektura/#feladatok-attekintese","title":"Feladatok \u00e1ttekint\u00e9se","text":""},{"location":"hazi/document-view-architektura/#feladatleiras","title":"Feladatle\u00edr\u00e1s","text":"<ul> <li>Egy olyan vastagkliens (Windows Forms) alkalmaz\u00e1st kell elk\u00e9sz\u00edteni, amely k\u00e9pes f\u00e1jlban id\u0151b\u00e9lyeggel t\u00e1rolt m\u00e9r\u00e9si \u00e9rt\u00e9kek grafikus megjelen\u00edt\u00e9s\u00e9re. Az alkalmaz\u00e1snak a Document-View architekt\u00far\u00e1t kell k\u00f6vetnie.</li> <li>Egyszerre t\u00f6bb dokumentum is meg lehet nyitva, illetve egy dokumentumnak t\u00f6bb n\u00e9zete is lehet. A f\u0151ablak egy <code>TabControl</code>-t tartalmaz, melyen minden n\u00e9zet egy k\u00fcl\u00f6n tabf\u00fcl\u00f6n jelenik meg.</li> <li>Egy dokumentum l\u00e9trehoz\u00e1sakor/megnyit\u00e1sakor egy n\u00e9zet (tabf\u00fcl) j\u00f6n l\u00e9tre hozz\u00e1, de ut\u00f3lag a Window / New View men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val \u00faj n\u00e9zet/tabf\u00fcl is l\u00e9trehozhat\u00f3. Egy dokumentumhoz az\u00e9rt van \u00e9rtelme t\u00f6bb n\u00e9zetet megjelen\u00edteni, mert az egyes n\u00e9zetek elt\u00e9r\u0151 nagy\u00edt\u00e1sban k\u00e9pesek az adott dokumentum jeleit megjelen\u00edteni.</li> <li>A jelek kirajzol\u00e1sa mellett meg kell jelen\u00edteni a koordin\u00e1tatengelyeket is.</li> </ul>"},{"location":"hazi/document-view-architektura/#iranyelvek","title":"Ir\u00e1nyelvek","text":"<ul> <li>A megval\u00f3s\u00edt\u00e1s sor\u00e1n haszn\u00e1ljunk besz\u00e9des v\u00e1ltoz\u00f3neveket, pl. <code>pixelPerSec</code>.</li> <li>Amennyiben a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n \u201einconsistent visibility\u201d-re vagy \u201einconsistent accessibility\u201d-re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel tal\u00e1lkozunk, ellen\u0151rizz\u00fck, hogy valamennyi t\u00edpusunk (oszt\u00e1lyunk, interf\u00e9sz\u00fcnk) l\u00e1that\u00f3s\u00e1ga publikus-e, a class/interface kulcssz\u00f3 el\u0151tt adjuk meg a <code>public</code> m\u00f3dos\u00edt\u00f3t. Pl.:</li> </ul> <pre><code>public class MyClass\n{ \u2026 }\n</code></pre>"},{"location":"hazi/document-view-architektura/#feladat-1-a-kiindulasi-kornyezet-megismerese","title":"Feladat 1 - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se","text":""},{"location":"hazi/document-view-architektura/#bevezeto-feladatok","title":"Bevezet\u0151 feladatok","text":"<ol> <li> A f\u0151ablak fejl\u00e9ce a \"Signals\" sz\u00f6veg legyen, hozz\u00e1f\u0171zve a saj\u00e1t Neptun k\u00f3dod: (pl. \"ABCDEF\" Neptun k\u00f3d eset\u00e9n \"Signals - ABCDEF\"), fontos, hogy ez legyen a sz\u00f6veg! Ehhez az \u0171rlapunk <code>Text</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be erre a sz\u00f6vegre.</li> </ol>"},{"location":"hazi/document-view-architektura/#kiindulo-alkalmazas-mukodese","title":"Kiindul\u00f3 alkalmaz\u00e1s m\u0171k\u00f6d\u00e9se","text":"<p>A solution\u00fcnk egy Document-View keretet tartalmaz. Futtatva tesztelj\u00fck a kiindul\u00e1si alkalmaz\u00e1st:</p> <ul> <li>A File/New men\u00fc egy \u00faj dokumentumot hoz l\u00e9tre. Els\u0151 l\u00e9p\u00e9sben bek\u00e9ri a dokumentum nev\u00e9t, majd l\u00e9trehozza a dokumentumot \u00e9s a n\u00e9zetet a hozz\u00e1 tartoz\u00f3 tabf\u00fcllel.</li> <li>A File/Open \u00e9s File/Save men\u00fcelemekhez l\u00e9nyegi implement\u00e1ci\u00f3 egyel\u0151re nem tartozik.</li> <li>A File/Close bez\u00e1rja az aktu\u00e1lis dokumentumot/tabf\u00fclet.</li> <li>A Window/New View egy \u00faj n\u00e9zetet/tabf\u00fclet hoz l\u00e9tre az aktu\u00e1lis dokumentumhoz. Amennyiben egy dokumentumhoz t\u00f6bb n\u00e9zet is tartozik, a 2. n\u00e9zettel kezdve a tabf\u00fcl\u00f6n a n\u00e9zet sorsz\u00e1ma is megjelenik.</li> </ul> <p>A f\u0151ablakunk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki, ha k\u00e9t dokumentumot hoztunk l\u00e9tre, \u00e9s a m\u00e1sodikhoz k\u00e9t n\u00e9zetet:</p> <p></p>"},{"location":"hazi/document-view-architektura/#kiindulo-projekt","title":"Kiindul\u00f3 projekt","text":"<p>A megjegyz\u00e9sekkel ell\u00e1tott forr\u00e1sk\u00f3dot n\u00e9zve ismerkedj\u00fcnk meg a keret architekt\u00far\u00e1j\u00e1val, m\u0171k\u00f6d\u00e9s\u00e9vel.</p> <p>A fontosabb oszt\u00e1lyok a k\u00f6vetkez\u0151k:</p> <ul> <li><code>MainForm</code> oszt\u00e1ly: Az alkalmaz\u00e1s f\u0151ablaka. Egy <code>TabControl</code>-t tartalmaz, ahol megjelennek az egyes dokumentumok n\u00e9zetei. Kezeli a <code>MenuStrip</code> esem\u00e9nyeit, a t\u00f6bbs\u00e9g\u00fck kezel\u0151f\u00fcggv\u00e9ny\u00e9ben egyszer\u0171en tov\u00e1bbh\u00edv az <code>App</code> oszt\u00e1lyba (vagyis a logika nem a form oszt\u00e1lyban van meg\u00edrva).</li> <li><code>App</code> oszt\u00e1ly: Az alkalmaz\u00e1st reprezent\u00e1lja. Egy p\u00e9ld\u00e1nyt kell l\u00e9trehozni bel\u0151le az <code>Initialize</code> h\u00edv\u00e1s\u00e1val, ez lesz az alkalmaz\u00e1sunk \u201eroot\u201d objektuma. Ez b\u00e1rmely oszt\u00e1ly sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 az <code>App.Instance</code> statikus property-n kereszt\u00fcl (erre t\u00f6bb p\u00e9ld\u00e1t is l\u00e1tunk a f\u0151ablak men\u00fc esem\u00e9nykezel\u0151iben). T\u00e1rolja a dokumentumok list\u00e1j\u00e1t. Legfontosabb tagjai a k\u00f6vetkez\u0151k:<ul> <li><code>documents</code>: Valamennyi megnyitott dokumentumot tartalmaz\u00f3 lista.</li> <li><code>activeView</code>: Az akt\u00edv n\u00e9zetet adja vissza. Ezt az akt\u00edv <code>TabPage</code> hat\u00e1rozza meg. Tabv\u00e1lt\u00e1skor mindig friss\u00edt\u00e9sre ker\u00fcl. A <code>TabPage</code>-ek a <code>Tag</code> property-j\u00fckben t\u00e1rolj\u00e1k azt a n\u00e9zet objektumot, melyet megjelen\u00edtenek.</li> <li><code>ActiveDocument</code>: Az akt\u00edv dokumentumot adja vissza. Az akt\u00edv <code>TabPage</code> meghat\u00e1rozza, melyik az akt\u00edv n\u00e9zet, a n\u00e9zet pedig referenci\u00e1val rendelkezik a dokumentumra, melyhez tartozik.</li> <li><code>NewDocument</code>: L\u00e9trehoz egy \u00faj dokumentumot, a hozz\u00e1 tartoz\u00f3 n\u00e9zettel. Alaposan tanulm\u00e1nyozzuk \u00e1t az implement\u00e1ci\u00f3t, az \u00e1ltala h\u00edvott f\u00fcggv\u00e9nyeket is bele\u00e9rtve!</li> <li><code>CreateViewForActiveDocument</code>: Egy \u00faj n\u00e9zetet hoz l\u00e9tre az akt\u00edv dokumentumhoz. A Window/New View men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1nak hat\u00e1s\u00e1ra h\u00edv\u00f3dik meg.</li> <li><code>CloseActiveView</code>: Bez\u00e1rja az akt\u00edv n\u00e9zetet.</li> </ul> </li> <li><code>Document</code> oszt\u00e1ly: Az egyes dokumentum t\u00edpusok \u0151soszt\u00e1lya. B\u00e1r eset\u00fcnkben csak egy dokumentum t\u00edpus l\u00e9tezik, a k\u00e9s\u0151bbi b\u0151v\u00edthet\u0151s\u00e9g miatt c\u00e9lszer\u0171 k\u00fcl\u00f6n v\u00e1lasztani. Tartalmazza a n\u00e9zetek list\u00e1j\u00e1t, melyek a dokumentumot megjelen\u00edtik. Az <code>UpdateAllViews</code> m\u0171velete valamennyi n\u00e9zetet \u00e9rtes\u00edt annak \u00e9rdek\u00e9ben, hogy friss\u00edts\u00e9k magukat. A <code>LoadDocument</code> \u00e9s <code>SaveDocument</code> \u00fcres virtu\u00e1lis f\u00fcggv\u00e9nyek, melyek a dokumentum bet\u00f6lt\u00e9sekor \u00e9s ment\u00e9sekor ker\u00fclnek megh\u00edv\u00e1sra. A <code>Document</code> lesz\u00e1rmazott oszt\u00e1lyunkban kell fel\u00fcldefini\u00e1lni \u00e9s \u00e9rtelemszer\u0171en megval\u00f3s\u00edtani \u0151ket.</li> <li><code>IView</code>: Az egyes n\u00e9zetek k\u00f6z\u00f6s interf\u00e9sze. Az\u00e9rt nem oszt\u00e1ly, mert a n\u00e9zetek tipikusan a <code>UserControl</code>-b\u00f3l sz\u00e1rmaznak le, \u00e9s egy oszt\u00e1lynak nem lehet t\u00f6bb \u0151soszt\u00e1lya .NET k\u00f6rnyezetben.</li> <li><code>DemoView</code>: Egy demo n\u00e9zet implement\u00e1ci\u00f3, mintak\u00e9nt szolg\u00e1lhat saj\u00e1t n\u00e9zet l\u00e9trehoz\u00e1s\u00e1hoz. A <code>UserControl</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik, \u00e9s implement\u00e1lja az <code>IView</code> interf\u00e9szt.</li> </ul> <p>Az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok jobb meg\u00e9rt\u00e9s\u00e9t seg\u00edti a solutionben tal\u00e1lhat\u00f3 <code>ClassDiagram1.cd</code> UML oszt\u00e1lydiagram.</p>"},{"location":"hazi/document-view-architektura/#feladat-2-meresi-ertekek-kezelese-dokumentum-logikak","title":"Feladat 2 \u2013 M\u00e9r\u00e9si \u00e9rt\u00e9kek kezel\u00e9se (dokumentum logik\u00e1k)","text":""},{"location":"hazi/document-view-architektura/#meresi-ertekek-reprezentalasa","title":"M\u00e9r\u00e9si \u00e9rt\u00e9kek reprezent\u00e1l\u00e1sa","text":"<p>Vezess\u00fcnk be egy oszt\u00e1lyt a jel\u00e9rt\u00e9kek reprezent\u00e1l\u00e1s\u00e1ra.</p> <p>Legyen az oszt\u00e1ly neve <code>SignalValue</code>, \u00e9s egy <code>Value</code> (<code>double</code>) mez\u0151ben t\u00e1rolja a m\u00e9rt \u00e9rt\u00e9ket, az id\u0151b\u00e9lyeget pedig egy <code>TimeStamp</code> (<code>DateTime</code>) mez\u0151ben. Mivel ezeket nem akarjuk a kezdeti inicializ\u00e1l\u00e1s ut\u00e1n megv\u00e1ltoztatni, defini\u00e1ljuk \u0151ket csak olvashat\u00f3nak (<code>readonly</code> kulcssz\u00f3).</p> <p>Az oszt\u00e1lynak legyen olyan k\u00e9tparam\u00e9teres konstruktora, mely param\u00e9terben megkapja jel\u00e9rt\u00e9ket \u00e9s az id\u0151b\u00e9lyeget, \u00e9s ez alapj\u00e1n inicializ\u00e1lja a tagv\u00e1ltoz\u00f3kat. \u00cdrjuk fel\u00fcl az <code>object</code>-b\u0151l \u00f6r\u00f6k\u00f6lt <code>ToString</code> m\u0171veletet, hogy form\u00e1zottan jelen\u00edtse meg az objektum tagv\u00e1ltoz\u00f3it. Seg\u00edts\u00e9g:</p> <pre><code>public override string ToString()\n{\nreturn $\"Value: {Value}, TimeStamp: {TimeStamp}\";\n}\n</code></pre>"},{"location":"hazi/document-view-architektura/#sajat-dokumentum-osztaly","title":"Saj\u00e1t dokumentum oszt\u00e1ly","text":"<p>Vezess\u00fcnk be egy saj\u00e1t dokumentum oszt\u00e1lyt a dokumentumhoz tartoz\u00f3 jel\u00e9rt\u00e9kek t\u00e1rol\u00e1s\u00e1ra.</p> <p>Legyen az oszt\u00e1ly neve <code>SignalDocument</code>, sz\u00e1rmazzon a <code>Document</code> oszt\u00e1lyb\u00f3l, \u00e9s egy <code>signals</code> nev\u0171 <code>List&lt;SignalValue&gt;</code> t\u00edpus\u00fa tagban t\u00e1rolja a jeleket.</p> <p>Document konstruktor</p> <p>Az \u0151s <code>Document</code> nem rendelkezik default konstruktorral, ez\u00e9rt kell \u00edrjunk a lesz\u00e1rmazottunkban megfelel\u0151 konstruktort:</p> <pre><code>public SignalDocument(string name)\n: base(name)\n{ }\n</code></pre> <p>M\u00f3dos\u00edtsuk az <code>App.NewDocument</code> f\u00fcggv\u00e9nyt, hogy a lesz\u00e1rmazott <code>SignalDocument</code>-et p\u00e9ld\u00e1nyos\u00edtsa.</p>"},{"location":"hazi/document-view-architektura/#adatok-mentese","title":"Adatok ment\u00e9se","text":"<p>Gondoskodjunk a dokumentum \u00e1ltal t\u00e1rolt adatok elment\u00e9s\u00e9r\u0151l.</p> <p>A tesztel\u00e9st seg\u00edtend\u0151 inicializ\u00e1ljuk a <code>SignalDocument</code>-ben t\u00e1rolt jel\u00e9rt\u00e9k list\u00e1t \u00fagy, hogy mindig legyen benne n\u00e9h\u00e1ny elem. C\u00e9lszer\u0171 ezeket egy k\u00fcl\u00f6n tagv\u00e1ltoz\u00f3ban felvenni. Az al\u00e1bbi k\u00f3d arra is p\u00e9ld\u00e1t mutat, hogyan lehet C# nyelven a t\u00f6mb elemeit az inicializ\u00e1l\u00e1s sor\u00e1n egyszer\u0171en megadni (collection initializer).</p> <p>Figyelem</p> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n NE az al\u00e1bbi p\u00e9ld\u00e1ban szerepl\u0151 \u00e9rt\u00e9keket haszn\u00e1ld:</p> <pre><code>public class SignalDocument : Document\n{ // ...\n\nprivate List&lt;SignalValue&gt; signals = new List&lt;SignalValue&gt;();\n\nprivate SignalValue[] testValues = new SignalValue[]\n{\nnew SignalValue(10, new DateTime(2023, 1, 1, 0, 0, 0, 111)),\nnew SignalValue(20, new DateTime(2023, 1, 1, 0, 0, 1, 876)),\nnew SignalValue(30, new DateTime(2023, 1, 1, 0, 0, 2, 300)),\nnew SignalValue(10, new DateTime(2023, 1, 1, 0, 0, 3, 232)),\nnew SignalValue(-10, new DateTime(2023, 1, 1, 0, 0, 5, 885)),\nnew SignalValue(-19, new DateTime(2023, 1, 1, 0, 0, 6, 125)),\n};\n\npublic SignalDocument(string name)\n: base(name)\n{\n// Kezdetben dolgozzunk \u00fagy, hogy a signals\n// jel\u00e9rt\u00e9k list\u00e1t a testValues alapj\u00e1n inicializ\u00e1ljuk.\nsignals.AddRange(testValues);\n}\n\n// ...\n}\n</code></pre> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben \u00edrja meg az <code>App.SaveActiveDocument</code> f\u00fcggv\u00e9nyt a forr\u00e1sk\u00f3dban tal\u00e1lhat\u00f3 megjegyz\u00e9seknek megfelel\u0151en. A <code>SaveFileDialog</code> haszn\u00e1lat\u00e1ra a dokument\u00e1ci\u00f3ban itt vagy itt tal\u00e1l p\u00e9ld\u00e1t. Az el\u0151bb linkelt  p\u00e9lda megt\u00e9veszt\u0151 lehet, mert a dial\u00f3gus meg is nyitja a f\u00e1jlt. Eset\u00fcnkben erre semmi sz\u00fcks\u00e9g, csak egy f\u00e1jl \u00fatvonalat szeretn\u00e9nk szerezni, hiszen a f\u00e1jl megnyit\u00e1sa a dokumentum oszt\u00e1lyunk feladata.</p> Seg\u00edts\u00e9g a megold\u00e1shoz <pre><code>/// &lt;summary&gt;\n/// Elmenti az akt\u00edv dokumentum tartalm\u00e1t.\n/// &lt;/summary&gt;\npublic void SaveActiveDocument()\n{\nif (ActiveDocument == null)\nreturn;\n\n// \u00datvonal bek\u00e9r\u00e9se a felhaszn\u00e1l\u00f3t\u00f3l a SaveFileDialog seg\u00edts\u00e9g\u00e9vel.\nvar saveFileDialog = new SaveFileDialog()\n{\n// Megjelen\u00edt\u00e9s el\u0151tt param\u00e9terezz\u00fck fel a dial\u00f3gus ablakot\nFilter = \"txt files (*.txt)|*.txt|All files (*.*)|*.*\",\nFilterIndex = 0,\nRestoreDirectory = true,\n};\n\n// Mod\u00e1lisan megjelen\u00edtj\u00fck a dial\u00f3gusablakot.\n// Ha a felhaszn\u00e1l\u00f3 nem az OK gommbal z\u00e1rta be az ablakot, \n// nem csin\u00e1lunk semmit (visszat\u00e9r\u00fcnk)\nif(saveFileDialog.ShowDialog() != DialogResult.OK)\nreturn;\n\n// A dokumentum adatainak elment\u00e9se.\n// A saveFileDialog.FileName tartalmazza a teljes \u00fatvonalat.\nActiveDocument.SaveDocument(saveFileDialog.FileName);\n}\n</code></pre> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben defini\u00e1ljuk fel\u00fcl a <code>SignalDocument</code> oszt\u00e1lyban az \u00f6r\u00f6k\u00f6lt <code>SaveDocument</code> f\u00fcggv\u00e9nyt, melyben \u00edrjuk ki a t\u00e1rolt jel\u00e9rt\u00e9keket, id\u0151b\u00e9lyeggel egy\u00fctt. A ment\u00e9s sor\u00e1n arra t\u00f6reksz\u00fcnk, hogy t\u00f6m\u00f6r, m\u00e9gis olvashat\u00f3 form\u00e1tumot kapjunk. Ennek megfelel\u0151en a bin\u00e1ris form\u00e1tum nem javasolt. K\u00f6vess\u00fck a k\u00f6vetkez\u0151 minta \u00e1ltal meghat\u00e1rozott sz\u00f6veges form\u00e1tumot:</p> <pre><code>10  2022-12-31T23:00:00.1110000Z\n20  2022-12-31T23:00:01.8760000Z\n30  2022-12-31T23:00:02.3000000Z\n10  2022-12-31T23:00:03.2320000Z\n</code></pre> <p>Az els\u0151 oszlopban a jel\u00e9rt\u00e9k, a m\u00e1sodikban az id\u0151pont tal\u00e1lhat\u00f3, az oszlopok tabul\u00e1tor karakterrel szepar\u00e1ltak (<code>\\t</code>). Az id\u0151pont legyen UTC id\u0151 annak \u00e9rdek\u00e9ben, hogy ha a f\u00e1jlt m\u00e1s id\u0151z\u00f3n\u00e1ban t\u00f6ltik be, akkor is a helyes helyi id\u0151t mutassa. A megfelel\u0151 <code>string</code> konverzi\u00f3 a k\u00f6vetkez\u0151:</p> <pre><code>var dt = myDateTime.ToUniversalTime().ToString(\"o\");\n</code></pre> <p>Sz\u00f6veges adatok f\u00e1jlba \u00edr\u00e1s\u00e1ra a <code>StreamWriter</code> oszt\u00e1lyt haszn\u00e1ljuk.</p> <p>Figyelem</p> <p>A megold\u00e1sunkban garant\u00e1ljuk, hogy kiv\u00e9tel eset\u00e9n is lez\u00e1r\u00f3djon a f\u00e1jlunk: haszn\u00e1ljunk <code>try-finally</code> blokkot, vagy alkalmazzunk <code>using</code> blokkot:</p> <pre><code>using (StreamWriter sw = new StreamWriter(filePath))\n{\n\n}\n</code></pre> <p>Az alkalmaz\u00e1st futtatva tesztelj\u00fck a ment\u00e9s funkci\u00f3t. Ennek sor\u00e1n ellen\u0151rizz\u00fck, hogy a f\u00e1jlban val\u00f3ban az elv\u00e1r\u00e1soknak megfelel\u0151 form\u00e1tumban ker\u00fclnek-e ki\u00edr\u00e1sra az adatok. Ehhez ind\u00edtsuk el az alkalmaz\u00e1st, hozzunk l\u00e9tre egy \u00faj dokumentumot, majd a File/Save men\u00fc kiv\u00e1laszt\u00e1s\u00e1val ments\u00fck el.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat2-3.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, az <code>App.cs</code> megnyitva, \u00fagy g\u00f6rgetve, hogy f\u00fcgg\u0151legesen a <code>public void SaveActiveDocument()</code> legyen az oldal k\u00f6zep\u00e9n (vagyis l\u00e1tsz\u00f3djon az el\u0151z\u0151 f\u00fcggv\u00e9ny v\u00e9ge \u00e9s a <code>SaveActiveDocument</code> eleje),</li> <li>a VS View/Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/document-view-architektura/#adatok-betoltese","title":"Adatok bet\u00f6lt\u00e9se","text":"<p>Biztos\u00edtsunk lehet\u0151s\u00e9get dokumentum f\u00e1jlb\u00f3l bet\u00f6lt\u00e9s\u00e9re.</p> <p>\u00cdrjuk meg az <code>App.OpenDocument</code> f\u00fcggv\u00e9nyt a benne szerepl\u0151 megjegyz\u00e9seknek megfelel\u0151en, k\u00f6vess\u00fck az ott megadott l\u00e9p\u00e9seket.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben defini\u00e1ljuk fel\u00fcl a <code>SignalDocument</code> oszt\u00e1lyban az \u00f6r\u00f6k\u00f6lt <code>LoadDocument</code> f\u00fcggv\u00e9nyt, melyben t\u00f6lts\u00fck fel a t\u00e1rolt jel\u00e9rt\u00e9k list\u00e1t a f\u00e1jl tartalma alapj\u00e1n. Sz\u00f6veges adatok f\u00e1jlb\u00f3l beolvas\u00e1s\u00e1ra a <code>StreamReader</code> oszt\u00e1lyt haszn\u00e1ljuk, a ment\u00e9shez hasonl\u00f3an <code>try/finally</code> vagy <code>using</code> blokkban.</p> Seg\u00edts\u00e9gk\u00e9ppen <ul> <li> <p>Amennyiben van egy <code>sr</code> nev\u0171 <code>StreamReader</code> objektumunk, a f\u00e1jl soronk\u00e9nti beolvas\u00e1sa a k\u00f6vetkez\u0151k\u00e9ppen lehets\u00e9ges:</p> <pre><code>while ((line = sr.ReadLine()) != null)\n{\n// A line v\u00e1ltoz\u00f3ban benne van az aktu\u00e1lis sor \n// ,,,\n}\n</code></pre> </li> <li> <p>Az \u00fcres, vagy csak whitespace karaktereket tartalmaz\u00f3 sorokat \u00e1t kell ugrani. A <code>string.Trim</code> haszn\u00e1lhat\u00f3 a whitespace karakterek kisz\u0171r\u00e9s\u00e9re, pl.:</p> <pre><code>s = s.Trim();\n</code></pre> </li> <li> <p>Az oszlopok tab karakterrel szepar\u00e1ltak. Egy sztring adott karakter szerinti v\u00e1g\u00e1s\u00e1ra k\u00e9nyelmesen haszn\u00e1lhat\u00f3 a <code>string</code> oszt\u00e1ly <code>Split</code> m\u0171velete, pl.: </p> <pre><code>string[] columns = line.Split(\u2019\\t\u2019);\n</code></pre> </li> <li> <p>Sztringb\u0151l <code>double</code>-t, illetve <code>DateTime</code> objektumot a <code>&lt;t\u00edpusn\u00e9v&gt;.Parse(str)</code> f\u00fcggv\u00e9nnyel lehet pl. kinyerni:</p> <pre><code>double d = double.Parse(strValue);\nDateTime dt = DateTime.Parse(strValue);\n</code></pre> </li> <li> <p>A f\u00e1jlban UTC id\u0151b\u00e9lyegek szerepelnek, ezt a dokumentum oszt\u00e1lyban t\u00e1rol\u00e1s el\u0151tt konvert\u00e1ljuk lok\u00e1lis id\u0151re:</p> <pre><code>DateTime localDt = utcDt.ToLocalTime();\n</code></pre> </li> <li> <p>Miut\u00e1n beolvastuk az adott sort, hozzunk l\u00e9tre egy \u00faj <code>SignalValue</code> objektumot a beolvasott \u00e9rt\u00e9kekkel inicializ\u00e1lva, \u00e9s vegy\u00fck fel a <code>signals</code> list\u00e1ba.</p> </li> </ul> <p>A <code>LoadDocument</code> f\u00fcggv\u00e9ny elej\u00e9n a <code>signals</code> felt\u00f6lt\u00e9se el\u0151tt t\u00f6r\u00f6lj\u00fck ki a <code>Clear</code> m\u0171velettel a benne lev\u0151 elemeket. En\u00e9lk\u00fcl ugyanis a konstruktorban hozz\u00e1adott teszt jel\u00e9rt\u00e9kek benne maradn\u00e1nak.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat2-4.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>\u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, az App.cs megnyitva, \u00fagy g\u00f6rgetve, hogy az <code>OpenDocument</code> f\u00fcggv\u00e9ny t\u00f6rzs\u00e9b\u0151l min\u00e9l t\u00f6bb l\u00e1tsz\u00f3djon.</li> <li>a VS View/Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/document-view-architektura/#betoltes-ellenorzese","title":"Bet\u00f6lt\u00e9s ellen\u0151rz\u00e9se","text":"<p>A bet\u00f6lt\u00e9st k\u00f6vet\u0151en ellen\u0151rizz\u00fck a bet\u00f6lt\u00e9s sikeress\u00e9g\u00e9t.</p> <p>Mivel grafikus megjelen\u00edt\u00e9ssel m\u00e9g nem rendelkezik az alkalmaz\u00e1s, m\u00e1s megold\u00e1st kell v\u00e1lasztani. Nyomk\u00f6vet\u00e9sre, diagnosztik\u00e1ra a <code>System.Diagnostics</code> n\u00e9vt\u00e9r oszt\u00e1lyai haszn\u00e1lhat\u00f3k. A <code>Trace</code> oszt\u00e1ly \u201eDebug\u201d build eset\u00e9n a <code>Write</code>/<code>WriteLine</code> utas\u00edt\u00e1ssal ki\u00edrt adatokat trace-eli: az alap\u00e9rtelmez\u00e9sben azt jelenti, hogy megjelen\u00edti a Visual Studio Output ablak\u00e1ban. \u00cdrjunk egy <code>TraceValues</code> seg\u00e9df\u00fcggv\u00e9nyt a <code>SignalDocument</code> oszt\u00e1lyba, mely trace-eli a t\u00e1rolt jeleket:</p> <pre><code>private void TraceValues()\n{\nforeach (var signal in signals)\nTrace.WriteLine(signal.ToString());\n}\n</code></pre> <p>H\u00edvjuk meg a <code>TraceValues</code>-t a bet\u00f6lt\u0151 f\u00fcggv\u00e9ny\u00fcnk (<code>LoadDocument</code>) v\u00e9g\u00e9n, \u00e9s ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9st: az F5 billenty\u0171 lenyom\u00e1s\u00e1val debug m\u00f3dban ind\u00edtsuk el az alkalmaz\u00e1st, a File/Open kiv\u00e1laszt\u00e1s\u00e1val t\u00f6lts\u00fcnk be egy kor\u00e1bban elmentett f\u00e1jlt. A m\u0171velet v\u00e9g\u00e9n ellen\u0151rizz\u00fck, hogy a Visual Studio Output ablak\u00e1ban (View/Output men\u00fcvel jelen\u00edthet\u0151 meg) ki\u00edr\u00f3dnak-e a f\u00e1jlb\u00f3l bet\u00f6lt\u00f6tt jelek adatai.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat2-5.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>SignalDocument.cs</code> megnyitva, melyben l\u00e1tszik a <code>TraceValues</code> implement\u00e1ci\u00f3ja, valamint az Output ablakban a trace-elt jel\u00e9rt\u00e9kek,</li> <li>az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/document-view-architektura/#feladat-3-jelek-grafikus-megjelenitese-sajat-nezet-osztaly","title":"Feladat 3 \u2013 Jelek grafikus megjelen\u00edt\u00e9se, saj\u00e1t n\u00e9zet oszt\u00e1ly","text":"<p>L\u00e9nyeges</p> <p>Ezen f\u0151fejezet feladatainak megold\u00e1s\u00e1t kommentekkel kell ell\u00e1tni!</p>"},{"location":"hazi/document-view-architektura/#uj-nezet-osztaly","title":"\u00daj n\u00e9zet oszt\u00e1ly","text":"<p>Vezess\u00fcnk be egy \u00faj n\u00e9zet oszt\u00e1lyt <code>UserControl</code> form\u00e1j\u00e1ban.</p> <p>A n\u00e9zetet <code>UserControl</code>-k\u00e9nt val\u00f3s\u00edtjuk meg. A t\u00e9ma elm\u00e9leti h\u00e1ttere az el\u0151ad\u00e1sanyagban megtal\u00e1lhat\u00f3. K\u00f6vetkezzen p\u00e1r fontosabb gondolat ism\u00e9tl\u00e9sk\u00e9ppen. A <code>UserControl</code> alap\u00fa megk\u00f6zel\u00edt\u00e9ssel olyan saj\u00e1t vez\u00e9rl\u0151t k\u00e9sz\u00edthet\u00fcnk, melyek az \u0171rlapokhoz (<code>Form</code>) hasonl\u00f3an m\u00e1s vez\u00e9rl\u0151ket tartalmazhatnak.</p> <p>Sz\u00e1mos pontban nagyon hasonl\u00edtanak az \u0171rlapokhoz, pl.:</p> <ul> <li>K\u00e9t forr\u00e1sf\u00e1jl tartozik hozz\u00e1juk. Egy, amiben mi dolgozunk, \u00e9s egy <code>designer.cs</code> v\u00e9gz\u0151d\u00e9s\u0171, melybe a Visual Studio gener\u00e1l k\u00f3dot. A fejleszt\u0151k sz\u00e1m\u00e1ra dedik\u00e1lt forr\u00e1sf\u00e1jlt t\u00f6bbf\u00e9lek\u00e9ppen lehet megnyitni:<ul> <li>A Solution Explorer \u00f6sszevontan jelen\u00edti meg a forr\u00e1sf\u00e1jlokat: ezen jobb gombbal kattintva a View Code elemet v\u00e1lasszuk a men\u00fcben.</li> <li>Amennyiben duplakattal megnyitottuk a <code>UserControl</code>-t szerkeszt\u00e9sre, a szerkeszt\u0151fel\u00fcleten jobb gombbal kattintva v\u00e1lasszuk a View Code men\u00fct.</li> <li>F7 billenty\u0171 haszn\u00e1lat\u00e1val.</li> </ul> </li> <li>Amikor saj\u00e1t \u0171rlapot k\u00e9sz\u00edt\u00fcnk, a be\u00e9p\u00edtett <code>Form</code> oszt\u00e1lyb\u00f3l kell egy saj\u00e1t oszt\u00e1lyt lesz\u00e1rmaztatni. Saj\u00e1t <code>UserControl</code> eset\u00e9ben a be\u00e9p\u00edtett <code>UserControl</code> oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztatni. Ezt ritk\u00e1n szoktuk manu\u00e1lisan megtenni, \u00e1ltal\u00e1ban a Visual Studio-ra b\u00edzzuk (pl. Project/Add UserControl men\u00fc).</li> <li>Hasonl\u00f3an a Solution Explorerben dupl\u00e1n kattintva rajtuk tudjuk megnyitni a fel\u00fclet\u00fcket szerkeszt\u00e9sre, a Toolbox-b\u00f3l tudunk m\u00e1s vez\u00e9rl\u0151ket elhelyezni a fel\u00fclet\u00fck\u00f6n, melyekb\u0151l a <code>UserControl</code> oszt\u00e1lyunkban tagv\u00e1ltoz\u00f3k lesznek.</li> <li>Hasonl\u00f3 m\u00f3don tudunk esem\u00e9nykezel\u0151ket k\u00e9sz\u00edteni (mag\u00e1hoz a <code>UserControl</code>-hoz, vagy a rajta lev\u0151 vez\u00e9rl\u0151kh\u00f6z).</li> <li>Ugyan\u00fagy tudunk fel\u00fclet\u00e9re rajzolni. Vagy a <code>Paint</code> esem\u00e9nyhez rendel\u00fcnk esem\u00e9nykezel\u0151t, vagy fel\u00fcldefini\u00e1ljuk az <code>OnPaint</code> virtu\u00e1lis f\u00fcggv\u00e9nyt.</li> </ul> <p>Abban term\u00e9szetesen k\u00fcl\u00f6nb\u00f6zik az \u0171rlapokt\u00f3l, hogy m\u00edg az \u0171rlapok, mint \u00f6n\u00e1ll\u00f3 ablakok a <code>Show</code> vagy <code>ShowDialog</code> m\u0171veletekkel megjelen\u00edthet\u0151k, a <code>UserControl</code>-ok vez\u00e9rl\u0151k, melyeket \u0171rlapokon vagy m\u00e1s vez\u00e9rl\u0151k\u00f6n kell elhelyezni.</p> <p>Visszat\u00e9rve a feladatra a megval\u00f3s\u00edt\u00e1s f\u0151bb l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ul> <li>Az \u00faj n\u00e9zet a fentieknek megfelel\u0151en egy <code>UserControl</code> legyen. Saj\u00e1t <code>UserControl</code>-t felvenni pl. a Project/Add UserControl men\u00fcvel lehet. Legyen a neve <code>GraphicsSignalView</code> (jelezve, hogy ez egy grafikus n\u00e9zet, \u00e9s nem karakteresen jelen\u00edti meg a jeleket).</li> <li>B\u0151v\u00edts\u00fck az oszt\u00e1lyt a <code>DemoView</code> mint\u00e1j\u00e1ra (t\u00f6bbek k\u00f6z\u00f6tt implement\u00e1lja az <code>IView</code> interf\u00e9szt). A <code>DemoView</code> a dokumentumra \u0151s <code>Document</code> t\u00edpusk\u00e9nt hivatkozik, l\u00e1sd <code>Document document;</code> tagv\u00e1ltoz\u00f3. A <code>GraphicsSignalView</code>-ban c\u00e9lszer\u0171 a specifikusabb, <code>SignalDocument</code> t\u00edpus\u00fanak defini\u00e1lni a tagv\u00e1ltoz\u00f3t!</li> <li> <p>M\u00f3dos\u00edtsuk az <code>App.CreateView()</code>-t, hogy <code>DemoView</code> helyett <code>GraphicsSignalView</code>-t hozzon l\u00e9tre. Hogy ez m\u0171k\u00f6dhessen, a <code>GraphicsSignalView</code>-ba fel kell venni egy konstruktort a k\u00f6vetkez\u0151nek megfelel\u0151en (hagyjuk meg a default konstruktort \u00e9s h\u00edvjuk is meg):</p> <pre><code>public GraphicsSignalView(SignalDocument document)\n: this()\n{\nthis.document = document;\n}\n</code></pre> <p>Az <code>App.CreateView</code> m\u00f3dos\u00edt\u00e1s\u00e1nak van m\u00e9g egy tr\u00fckkje. Mivel a <code>document</code> referenci\u00e1nk t\u00edpusa <code>Document</code>, a <code>GraphicsSignalView</code> pedig a lesz\u00e1rmazottj\u00e1t v\u00e1rja, a konstruktor h\u00edv\u00e1sakor explicit le kell castoljuk <code>SignalDocument</code>-re:</p> <pre><code>var view = new GraphicsSignalView((SignalDocument)document);\n</code></pre> </li> </ul>"},{"location":"hazi/document-view-architektura/#a-koordinata-tengelyek-kirajzolasa","title":"A koordin\u00e1ta tengelyek kirajzol\u00e1sa","text":"<p>Rajzoljuk ki a koordin\u00e1ta tengelyeket. Legyen az alapelv a k\u00f6vetkez\u0151:</p> <ul> <li>A rajzol\u00f3fel\u00fclet\u00fcnk (vagyis a <code>GraphicsSignalView</code> <code>UserControl</code>) kliens ter\u00fclet\u00e9nek sz\u00e9less\u00e9g\u00e9t a <code>ClientSize.Width</code>, a magass\u00e1g\u00e1t a <code>ClientSize.Height</code> lek\u00e9rdez\u00e9s\u00e9vel kaphatjuk meg. Vonalat rajzolni a <code>Graphics</code> oszt\u00e1ly <code>DrawLine</code> m\u0171velet\u00e9vel lehet.</li> <li>Az Y tengelyt a nulla y pixelpoz\u00edci\u00f3ba rajzoljuk.</li> <li>Az X tengelyt mindig a rajzol\u00f3fel\u00fclet\u00fcnk k\u00f6zep\u00e9re igaz\u00edtva rajzoljuk, ak\u00e1rhogy m\u00e9retezi is a felhaszn\u00e1l\u00f3 az ablakot (seg\u00edts\u00e9gk\u00e9ppen: a teljes aktu\u00e1lis magass\u00e1got a <code>ClientSize.Height</code> adja meg sz\u00e1munkra).</li> <li> <p> A koordin\u00e1ta tengelyek sz\u00edne legyen k\u00e9k, \u00e9s legyenek 2 pixel vastagok. A tengelyeket pontozott vonallal rajzoljuk, \u00e9s a v\u00e9g\u00fck\u00f6n legyen egy kism\u00e9ret\u0171 ny\u00edl. Erre a be\u00e9p\u00edtett <code>Pen</code> t\u00e1mogat\u00e1st ny\u00fajt:</p> <pre><code>var pen = new Pen(Color.Blue, 2)\n{\nDashStyle = DashStyle.Dot,\nEndCap = LineCap.ArrowAnchor,\n};\n</code></pre> </li> <li> <p>A f\u00fcgg\u0151leges tengelyt nem a 0, hanem a 2 koordin\u00e1t\u00e1ba \u00e9rdemes rajzolni (k\u00fcl\u00f6nben csak 1 pixel vastagnak fog l\u00e1tsz\u00f3dni).</p> </li> </ul> <p>A munk\u00e1nk eredm\u00e9nyek\u00e9ppen valami hasonl\u00f3t kell l\u00e1ssunk fut\u00e1s k\u00f6zben (a sz\u00edn \u00e9s minta nem biztos, hogy egyezik), persze csak ha megnyitunk egy l\u00e9tez\u0151 vagy l\u00e9trehozunk egy \u00faj dokumentumot, m\u00e1sk\u00fcl\u00f6nben nincs is n\u00e9zet\u00fcnk:</p> <p></p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat3-2.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Nyiss meg vagy hozz l\u00e9tre egy dokumentumot, hogy l\u00e1tsz\u00f3djanak a koordin\u00e1tatengelyek. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>GraphicsSignalView.cs</code> megnyitva, melyben l\u00e1tszik a koordin\u00e1tatengelyek kirajzol\u00e1sa,</li> <li>a VS View/Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/document-view-architektura/#jelek-megjelenitese","title":"Jelek megjelen\u00edt\u00e9se","text":"<p>Val\u00f3s\u00edtsuk meg a jelek megjelen\u00edt\u00e9s\u00e9t!</p> <p>Az <code>GraphicsSignalView</code>-ban az <code>OnPaint</code>-et fel\u00fcldefini\u00e1lva val\u00f3s\u00edtsuk meg a jelek kirajzol\u00e1s\u00e1t. El\u0151sz\u00f6r 3*3 pixeles \u201epontokat\u201d rajzoljunk (pl. <code>Graphics.FillRectangle</code>-lel), majd a pontokat k\u00f6ss\u00fck \u00f6ssze vonalakkal (<code>Graphics.DrawLine</code>).</p> Seg\u00edts\u00e9gk\u00e9ppen <p>A megval\u00f3s\u00edt\u00e1sban seg\u00edthet a k\u00f6vetkez\u0151:</p> <ul> <li> <p>Az <code>OnPaint</code> m\u0171velet a megjelen\u00edt\u00e9s sor\u00e1n el kell \u00e9rje a <code>SignalDocument</code>-ben t\u00e1rolt <code>SignalValue</code> objektumokat. Ehhez a <code>SignalDocument</code> oszt\u00e1lyban vezess\u00fcnk be egy publikus property-t (a <code>SignalDocument</code>-ben a <code>signals</code> tag priv\u00e1t, \u00e9s ez maradjon is \u00edgy):</p> <pre><code>public IReadOnlyList&lt;SignalValue&gt; Signals\n{\nget { return signals; }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy az objektumokat nem <code>List&lt;SignalValue&gt;</code>-k\u00e9nt, hanem <code>IReadOnlyList&lt;SignalValue&gt;</code> form\u00e1ban adjuk vissza: \u00edgy a h\u00edv\u00f3 nem tudja m\u00f3dos\u00edtani az eredeti list\u00e1t, nem tudja v\u00e9letlen\u00fcl se elrontani a tartalm\u00e1t.</p> </li> <li> <p>K\u00e9t <code>DateTime</code> \u00e9rt\u00e9k k\u00fcl\u00f6nbs\u00e9ge egy <code>TimeSpan</code> (id\u0151tartam) t\u00edpus\u00fa objektumot eredm\u00e9nyez.</p> </li> <li>Egy <code>DateTime</code> objektum a <code>Ticks</code> property-j\u00e9ben adja vissza legjobb felbont\u00e1ssal az \u00e1ltala t\u00e1rolt id\u0151\u00e9rt\u00e9ket (1 tick = 100 nsec felbont\u00e1s).</li> <li>A rajzol\u00f3fel\u00fclet\u00fcnk (vagyis a <code>GraphicsSignalView</code> <code>UserControl</code>) nulla x koordin\u00e1t\u00e1j\u00e1ban jelen\u00edts\u00fck meg a list\u00e1nkban lev\u0151 els\u0151 jelet.</li> <li>A megjelen\u00edt\u00e9s sor\u00e1n semmif\u00e9le k\u00f6vetelm\u00e9ny nincs arra vonatkoz\u00f3an, hogy a jeleket mindig olyan sk\u00e1lat\u00e9nyez\u0151kkel jelen\u00edts\u00fck meg, hogy pont kif\u00e9rjenek a rajzol\u00e1s sor\u00e1n. Helyette a n\u00e9zet oszt\u00e1lyunkban vezess\u00fcnk be \u00e9s haszn\u00e1ljunk olyan <code>pixelPerSec</code> \u00e9s <code>pixelPerValue</code> sk\u00e1lat\u00e9nyez\u0151ket, melyek \u00e9rz\u00e9sre, vagy p\u00e1r pr\u00f3b\u00e1lkoz\u00e1s ut\u00e1n \u00fagy jelen\u00edts\u00e9k meg a jeleket az alap\u00e9rtelmezett megjelen\u00edt\u00e9s sor\u00e1n, hogy a n\u00e9zetbe bef\u00e9rjenek, de ne is legyen a rajz t\u00fal kicsi (de az ablak \u00e1tm\u00e9retez\u00e9sekor m\u00e1r nem kell bef\u00e9rjenek a jelek az ablakba).</li> <li>Amennyiben a rajzunk \u201enem akar\u201d megjelenni, tegy\u00fcnk t\u00f6r\u00e9spontot az <code>OnPaint</code> m\u0171veletbe, \u00e9s a k\u00f3dunkat l\u00e9p\u00e9senk\u00e9nt v\u00e9grehajva a v\u00e1ltoz\u00f3k \u00e9rt\u00e9k\u00e9t tooltipben vagy a Watch ablakban megjelen\u00edtve nyomozzuk, hol cs\u00faszik f\u00e9lre a sz\u00e1m\u00edt\u00e1sunk.</li> </ul> <p>Ha j\u00f3l dolgoztunk, a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3 kimenetet kapunk:</p> <p></p>"},{"location":"hazi/document-view-architektura/#nagyitas-kicsinyites","title":"Nagy\u00edt\u00e1s, kicsiny\u00edt\u00e9s","text":"<p>Biztos\u00edtsunk lehet\u0151s\u00e9get a n\u00e9zet nagy\u00edt\u00e1sra \u00e9s kicsiny\u00edt\u00e9s\u00e9re. Ehhez helyezz\u00fcnk el egy kism\u00e9ret\u0171, \"+\" \u00e9s \"\u2013\" sz\u00f6veget tartalmaz\u00f3 nyom\u00f3gombot a n\u00e9zeten.</p> <p>L\u00e9p\u00e9sek:</p> <ul> <li>Nyissuk meg a <code>GraphicsSignalView</code> <code>UserControl</code>-t szerkeszt\u00e9sre.</li> <li>A Toolbox-r\u00f3l drag&amp;drop-pal helyezz\u00fcnk el rajta k\u00e9t gombot (<code>Button</code>).</li> <li>Nevezz\u00fck el a gombokat megfelel\u0151en \u00e9s \u00e1ll\u00edtsuk be a sz\u00f6veg\u00fcket (<code>Text</code> property).</li> <li>Rendelj\u00fcnk esem\u00e9nykezel\u0151t a gombok <code>Click</code> esem\u00e9ny\u00e9hez (ehhez csak dupl\u00e1n kell a gombokon kattintani a szerkeszt\u0151ben).</li> <li>Vezess\u00fcnk be a n\u00e9zetben egy <code>double</code> t\u00edpus\u00fa sk\u00e1lat\u00e9nyez\u0151t, melynek kezd\u0151\u00e9rt\u00e9ke legyen 1. Nagy\u00edt\u00e1skor ezt n\u00f6velj\u00fck (pl. 1,2-szeres\u00e9re), kicsiny\u00edt\u00e9skor cs\u00f6kkents\u00fck (pl. osszuk 1,2-vel). Az <code>OnPaint</code> m\u0171veleteben, mikor az y \u00e9s x pixelkoordin\u00e1t\u00e1kat sz\u00e1moljuk, a v\u00e9gs\u0151 eredm\u00e9ny sz\u00e1m\u00edt\u00e1sakor a koordin\u00e1t\u00e1kat szorozzuk be az aktu\u00e1lis sk\u00e1lat\u00e9nyez\u0151vel. A sk\u00e1lat\u00e9nyez\u0151 v\u00e1ltoztat\u00e1sa ut\u00e1n ne felejts\u00fck el megh\u00edvni az <code>Invalidate</code> m\u0171veletet!</li> </ul> <p>A k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3 kimenetet a c\u00e9l (n\u00e9mi nagy\u00edt\u00e1st k\u00f6vet\u0151en):</p> <p></p> <p>Az alkalmaz\u00e1st futtatva a Window men\u00fcb\u0151l ugyanahhoz a dokumentumhoz hozzunk l\u00e9tre egy \u00faj n\u00e9zetet, \u00e9s a nagy\u00edt\u00e1s/kicsiny\u00edt\u00e9s gombokat haszn\u00e1lva, valamint a n\u00e9zetek k\u00f6z\u00f6tt v\u00e1ltogatva ellen\u0151rizz\u00fck, hogy a n\u00e9zetek ugyanazokat az adatokat jelen\u00edtik meg, de elt\u00e9r\u0151 nagy\u00edt\u00e1sban.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat3-4.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Nyiss meg vagy hozz l\u00e9tre egy dokumentumot, hogy l\u00e1tsz\u00f3djanak a koordin\u00e1tatengelyek \u00e9s a kirajzolt jelek. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>GraphicsSignalView.cs</code> megnyitva, melyben l\u00e1tszik a jelek kirajzol\u00e1sa,</li> <li>a VS View/Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/document-view-architektura/#opcionalis-feladatok","title":"Opcion\u00e1lis feladatok","text":""},{"location":"hazi/document-view-architektura/#iview-kodduplikacioja-1-imsc-pont","title":"<code>IView</code> k\u00f3dduplik\u00e1ci\u00f3ja (1 iMSc pont)","text":"<p>Az <code>IView</code> egy interf\u00e9sz, ez\u00e9rt a <code>GetDocument</code>/<code>Update</code> stb. k\u00f3dj\u00e1t nem lehet implement\u00e1lni benne. Helyette minden n\u00e9zetben \u201ecopy-paste\u201d-tel duplik\u00e1lni kell a megfelel\u0151 k\u00f3dot. Sz\u00fcntess\u00fck meg ezt a k\u00f3dduplik\u00e1ci\u00f3t az alkalmaz\u00e1sban! A megold\u00e1st el\u0151bb mindenk\u00e9ppen magad pr\u00f3b\u00e1ld kital\u00e1lni, csak ha elakadsz, akkor fordulj az al\u00e1bbi kinyithat\u00f3 seg\u00edts\u00e9ghez:</p> Seg\u00edts\u00e9g <p>Egy <code>ViewBase</code> nev\u0171 oszt\u00e1lyt kell \u00edrni, mely a <code>UserControl</code>-b\u00f3l sz\u00e1rmazik, \u00e9s implement\u00e1lja az <code>IView</code> interf\u00e9szt. A n\u00e9zeteinket a <code>UserControl</code> helyett a <code>ViewBase</code> oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztatni.</p>"},{"location":"hazi/eloellenorzes-ertekeles/","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se","text":"<p>Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut egy nagyon egyszer\u0171 ellen\u0151rz\u0151: megn\u00e9zi, hogy a neptun.txt ki van-e t\u00f6ltve, illetve van-e ford\u00edt\u00e1si hiba a k\u00f3dban. A megold\u00e1s \u00e9rdemi ellen\u0151rz\u00e9s\u00e9t a t\u00e1rgy oktat\u00f3i v\u00e9gzik el a hat\u00e1rid\u0151 lej\u00e1rt\u00e1t k\u00f6vet\u0151en.</p>"},{"location":"hazi/eloellenorzes-ertekeles/#a-github-altal-futtatott-eloellenorzesek-megtekintese","title":"A GitHub \u00e1ltal futtatott el\u0151ellen\u0151rz\u00e9sek megtekint\u00e9se","text":"<ol> <li>GitHub-on a navig\u00e1l\u00e1s a repository-hoz</li> <li>Actions tabf\u00fclre v\u00e1lt\u00e1s</li> <li>Itt megjelenik egy t\u00e1bl\u00e1zat, minden push \u00e1ltal futtatott ellen\u0151rz\u00e9shez egy k\u00fcl\u00f6n sor, a tetej\u00e9n van legfrissebb. A sor elej\u00e9n lev\u0151 ikon jelzi a st\u00e1tuszt: v\u00e1r, fut, sikeres, sikertelen lehet. A sor sz\u00f6vege a Git commit neve.</li> <li> <p>Egy sorban a commit nev\u00e9n kattintva jelenik meg egy \u00e1tfog\u00f3 oldal az ellen\u0151rz\u0151 fut\u00e1s\u00e1r\u00f3l, ez sok inform\u00e1ci\u00f3t nem tartalmaz. Ezen az oldalon baloldalt kell a \"build\" vagy \"build-and-check\" (vagy hasonl\u00f3 nev\u0171) linken  kattintani, ez \u00e1tnavig\u00e1l az ellen\u0151rz\u00e9s r\u00e9szletes n\u00e9zet\u00e9re. Ez egy \u201e\u00e9l\u0151\u201d n\u00e9zet, ha fut a teszt, folyamatosan friss\u00fcl. Ha v\u00e9gzett, a csom\u00f3pontokat lenyitva lehet megn\u00e9zni az adott l\u00e9p\u00e9s kimenet\u00e9t.  Ha minden siker\u00fclt, egy ehhez hasonl\u00f3 n\u00e9zet l\u00e1that\u00f3:</p> <p></p> </li> <li> <p>Itt a legfontosabb tal\u00e1n a \"Run tests\" l\u00e9p\u00e9s. Ha valamelyik l\u00e9p\u00e9s sikertelen, pipa helyett piros x van a csom\u00f3pont elej\u00e9n, \u00e9s a csom\u00f3pontot kibontva a teszt kimenete utal a hiba ok\u00e1ra.</p> </li> </ol>"},{"location":"hazi/git-github-github-classroom/","title":"Git, GitHub, GitHub Classroom","text":"<p>A t\u00e1rgy keret\u00e9ben nem c\u00e9lunk a Git \u00e9s GitHub r\u00e9szletes megismer\u00e9se, csak a legsz\u00fcks\u00e9gesebb l\u00e9p\u00e9sekre szor\u00edtkozunk, valamint a legfontosabb parancsokat haszn\u00e1ljuk ahhoz, hogy a h\u00e1zi feladat(ok) kiindul\u00e1si programv\u00e1z\u00e1t hallgat\u00f3k\u00e9nt egy dedik\u00e1lt GitHub repository-b\u00f3l le tudjuk t\u00f6lteni, illetve a k\u00e9sz munk\u00e1t GitHubra fel tudjuk t\u00f6lteni.</p>"},{"location":"hazi/git-github-github-classroom/#git","title":"Git","text":"<p>A Git egy sok szolg\u00e1ltat\u00e1ssal rendelkez\u0151, rendk\u00edv\u00fcl n\u00e9pszer\u0171 \u00e9s elterjedt, ingyenesen let\u00f6lthet\u0151 \u00e9s telep\u00edthet\u0151, elosztottan is haszn\u00e1lhat\u00f3 verzi\u00f3kezel\u0151 rendszer. A k\u00f6zpontos\u00edtott rendszerekhez k\u00e9pest (TFS, CVS, SVN) a GIT eset\u00e9ben nem egyetlen k\u00f6zponti repository-ba dolgoznak a fejleszt\u0151k, hanem mindenki egy saj\u00e1t lok\u00e1lis repository p\u00e9ld\u00e1nnyal rendelkezik.</p> <p>Egy Git repository (becenev\u00e9n rep\u00f3) nem m\u00e1s, mint egy k\u00f6z\u00f6ns\u00e9ges k\u00f6nyvt\u00e1r a f\u00e1jlrendszerben, benne \u00e1llom\u00e1nyokkal (pl. forr\u00e1sk\u00f3d) \u00e9s alk\u00f6nyvt\u00e1rakkal, illetve egy \".git\" alk\u00f6nyvt\u00e1rral, melyben minden, a verzi\u00f3kezel\u00e9shez kapcsol\u00f3d\u00f3 extra inform\u00e1ci\u00f3 megtal\u00e1lhat\u00f3.</p> <p>A Git alap\u00fa munkafolyamat legfontosabb l\u00e9p\u00e9sei - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel - a k\u00f6vetkez\u0151k (felt\u00e9ve, hogy l\u00e9tezik egy k\u00f6zponti repository, ahol a verzi\u00f3kezelt k\u00f3d adott v\u00e1ltozata m\u00e1r el\u00e9rhet\u0151):</p> <ol> <li>A fejleszt\u0151 kl\u00f3nozza (<code>clone</code>) az adott k\u00f6zponti repository-t, melynek sor\u00e1n egy azzal megegyez\u0151 helyi repository j\u00f6n l\u00e9tre a saj\u00e1t sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n. Ezt a m\u0171veletet el\u00e9g egyszer elv\u00e9gezni.</li> <li>A fejleszt\u0151 a helyi repository-hoz tartoz\u00f3 munkak\u00f6nyvt\u00e1rban (working directory) v\u00e1ltoztat\u00e1sokat v\u00e9gez a k\u00f3don: \u00faj f\u00e1jlokat vesz fel, megl\u00e9v\u0151ket m\u00f3dos\u00edt \u00e9s t\u00f6r\u00f6l.</li> <li>Ha elk\u00e9sz\u00fcl egy \u00e9rdemi r\u00e9szfeladat, akkor a fejleszt\u0151 a v\u00e1ltoztat\u00e1sokat <code>commit</code>-olja a sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n lev\u0151 helyi repository-ba. Ennek sor\u00e1n a commit-ot c\u00e9lszer\u0171 egy a v\u00e1ltoztat\u00e1sok jelleg\u00e9t j\u00f3l \u00f6sszefoglal\u00f3 megjegyz\u00e9ssel ell\u00e1tni.</li> <li>A helyi repository-b\u00f3l egy <code>push</code> m\u0171velettel a fejleszt\u0151 fel\u00f6lti a v\u00e1ltoz\u00e1sokat a k\u00f6zponti repository-ba, ahol \u00edgy v\u00e1ltoztat\u00e1sai m\u00e1sok sz\u00e1m\u00e1ra is l\u00e1that\u00f3v\u00e1 v\u00e1lnak.</li> </ol> <p>Minden egyes commit tulajdonk\u00e9ppen egy id\u0151b\u00e9lyeggel, a fejleszt\u0151 felhaszn\u00e1l\u00f3nev\u00e9vel \u00e9s e-mail c\u00edm\u00e9vel ell\u00e1tott k\u00f3dot \u00e9rint\u0151 v\u00e1ltoz\u00e1shalmaz. A repositoryban ezek \"egym\u00e1sut\u00e1nis\u00e1g\u00e1b\u00f3l\" \u00e1ll \u00f6ssze a teljes verzi\u00f3t\u00f6rt\u00e9net. Mivel a legt\u00f6bb esetben a fejleszt\u0151k csapatban dolgoznak, id\u0151nk\u00e9nt sz\u00fcks\u00e9g van arra, hogy m\u00e1sok \u00e1ltal a k\u00f6zponti repository-ba <code>push</code>-olt v\u00e1ltoztat\u00e1sokat a fejleszt\u0151k a saj\u00e1t lok\u00e1lis repository-jukba let\u00f6lts\u00e9k \u00e9s belemerge-elj\u00e9k: erre szolg\u00e1l a <code>pull</code> m\u0171velet. Fontos szab\u00e1ly, hogy <code>push</code>-olni csak akkor lehet a k\u00f6zponti repository-ba (a Git csak akkor engedi), ha el\u0151tte m\u00e1sok v\u00e1ltoztat\u00e1sait a saj\u00e1t lok\u00e1lis repository-nkba egy <code>pull</code> m\u0171velettel el\u0151tte belemerge-elt\u00fck. A Szoftvertechnik\u00e1k t\u00e1rgy keret\u00e9ben a <code>pull</code> m\u0171veletet nem kell haszn\u00e1lni, mert mindenki \u00f6n\u00e1ll\u00f3an, saj\u00e1t repository-ba dolgozik. Megjegyz\u00e9s: ha esetleg a GitHub fel\u00fclet\u00e9n k\u00f6zvetlen v\u00e1ltoztatunk f\u00e1jlokon (vagy t\u00f6bb clone-ban is dolgozunk), akkor sz\u00fcks\u00e9g van a <code>pull</code> haszn\u00e1lat\u00e1ra ez esetben is. A fentieken t\u00falmen\u0151en a Git sz\u00e1mos tov\u00e1bbi szolg\u00e1ltat\u00e1st biztos\u00edt (pl. teljes verzi\u00f3t\u00f6rt\u00e9net megtekint\u00e9se minden f\u00e1jlra, commit t\u00f6rt\u00e9net megtekint\u00e9se, tetsz\u0151leges m\u00faltbeli verzi\u00f3ra vissza\u00e1ll\u00e1s, \u00e1gak kezel\u00e9se stb.).</p>"},{"location":"hazi/git-github-github-classroom/#github","title":"GitHub","text":"<p>A GitHub egy online el\u00e9rhet\u0151 website \u00e9s szolg\u00e1ltat\u00e1s (https://github.com), mely teljes k\u00f6r\u0171 Git szolg\u00e1ltat\u00e1st biztos\u00edt. Mindezt r\u00e1ad\u00e1sul \u2013 legal\u00e1bbis publikus, vagyis mindenki sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 repositoryk vonatkoz\u00e1s\u00e1ban \u2013 teljesen ingyenesen biztos\u00edtja. Napjainkra a GitHub v\u00e1lt a k\u00f6z\u00f6ss\u00e9gi k\u00f3d (verzi\u00f3kezelt) t\u00e1rol\u00e1s\u00e1nak els\u0151 sz\u00e1m\u00fa platformj\u00e1v\u00e1, a legt\u00f6bb ny\u00edlt forr\u00e1sk\u00f3d\u00fa projekt \u201eotthon\u00e1v\u00e1\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#github-classroom","title":"GitHub Classroom","text":"<p>A GitHub Classroom egy ingyenesen el\u00e9rhet\u0151 GitHub-bal integr\u00e1lt szolg\u00e1ltat\u00e1s, mely t\u00f6bbek k\u00f6z\u00f6tt oktat\u00e1si int\u00e9zm\u00e9nyek sz\u00e1m\u00e1ra lehet\u0151v\u00e9 teszi \u00f6n\u00e1ll\u00f3 tanul\u00f3i feladatokhoz tartoz\u00f3, tanul\u00f3nk\u00e9nt egyedi GitHub repository-k l\u00e9trehoz\u00e1s\u00e1t, ez\u00e1ltal a kiindul\u00e1si k\u00f3d tanul\u00f3k sz\u00e1m\u00e1ra t\u00f6rt\u00e9n\u0151 \u201ekioszt\u00e1s\u00e1t\u201d, valamint az elk\u00e9sz\u00fclt feladatok \u201ebeszed\u00e9s\u00e9t\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#git-github-es-github-classroom-a-targy-kontextusaban","title":"Git, GitHub \u00e9s GitHub Classroom a t\u00e1rgy kontextus\u00e1ban","text":"<p>A t\u00e1rgy keret\u00e9ben a GitHub Classroom seg\u00edts\u00e9g\u00e9vel kap minden hallgat\u00f3 minden h\u00e1zi feladat\u00e1hoz egy dedik\u00e1lt, a GitHub-on hostolt repository-t, mely a megfelel\u0151 kiindul\u00e1si k\u00f6rnyezettel (kiindul\u00f3 Visual Studio solution-\u00f6k) inicializ\u00e1l\u00e1sra ker\u00fcl. Mindenkinek a sz\u00e1m\u00e1ra dedik\u00e1lt repository-t kell a saj\u00e1t g\u00e9p\u00e9re <code>clone</code>-oznia, ebbe a v\u00e1ltoztat\u00e1sait <code>commit</code>-olni, \u00e9s a hat\u00e1rid\u0151ig az elk\u00e9sz\u00fclt megold\u00e1s\u00e1t <code>push</code>-olni (hogy GitHub-on is el\u00e9rhet\u0151 legyen a megold\u00e1s). A pontos l\u00e9p\u00e9sekre r\u00f6videsen visszat\u00e9r\u00fcnk.</p>"},{"location":"hazi/git-github-github-classroom/#visual-studio-es-a-git","title":"Visual Studio \u00e9s a Git","text":"<p>A Git egy elosztott verzi\u00f3kezel\u0151 rendszer. Ahhoz, hogy a saj\u00e1t g\u00e9p\u00fcnk\u00f6n dolgozni tudjunk vele, a Git-nek telep\u00edtve kell lennie. K\u00e9tf\u00e9le m\u00f3don tudjuk haszn\u00e1lni:</p> <ul> <li>A Git \u00f6nmag\u00e1ban is telep\u00edthet\u0151, \u00e9s parancssorb\u00f3l is ki tudjuk adni a sz\u00fcks\u00e9ges <code>clone</code>, <code>commit</code>, <code>push</code> stb. parancsokat.</li> <li>Haszn\u00e1lhatunk a parancsok kiad\u00e1s\u00e1ra egy grafikus fel\u00fclettel rendelkez\u0151 eszk\u00f6zt. Ilyenek pl. a GitHub Desktop, a GitExtensions, vagy maga a Visual Studio is (mely integr\u00e1lt grafikus Git szolg\u00e1ltat\u00e1sokat is biztos\u00edt).</li> </ul> <p>A k\u00e9t megk\u00f6zel\u00edt\u00e9st a mindennapokban kombin\u00e1ltan szoktuk haszn\u00e1lni. Egy repo lekl\u00f3noz\u00e1sa sokszor parancssorb\u00f3l a legegyszer\u0171bb/leggyorsabb. A v\u00e1ltoz\u00e1sok commit-ol\u00e1s\u00e1ra, a k\u00f6zponti repositoryval val\u00f3 szinkroniz\u00e1ci\u00f3ra (push, pull), a verzi\u00f3t\u00f6rt\u00e9nek megjelen\u00edt\u00e9s\u00e9re m\u00e1r c\u00e9lszer\u0171bb egy grafikus eszk\u00f6zt haszn\u00e1lni, k\u00fcl\u00f6n\u00f6sen akkor, ha m\u00e9g kev\u00e9sb\u00e9 vagyunk rutinosak. A t\u00e1rgy keret\u00e9ben a kl\u00f3noz\u00e1sra a parancssor vagy a Visual Studio, az egy\u00e9b parancsok kiad\u00e1s\u00e1ra a Visual Studio javasolt. A git haszn\u00e1latr\u00f3l (a h\u00e1zi feladatok kontextus\u00e1ban) itt tal\u00e1lhat\u00f3 b\u0151vebb le\u00edr\u00e1s.</p>"},{"location":"hazi/git-github-github-classroom/#git-telepitese","title":"Git telep\u00edt\u00e9se","text":"<p>Amennyiben a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre nincs m\u00e9g a Git telep\u00edtve, \u00e9s szeretn\u00e9nk azt parancssorb\u00f3l is haszn\u00e1lni, akkor innen telep\u00edthet\u0151 Windows oper\u00e1ci\u00f3s rendszerre: https://git-scm.com/download/win. Egy\u00e9b oper\u00e1ci\u00f3s rendszerek eset\u00e9n pedig innen \u00e9rdemes indulni: https://git-scm.com/downloads.</p> <p>Git Credential Manager telep\u00edt\u00e9se</p> <p>A GitHub m\u00e1r egy ideje nem t\u00e1mogatja az egyszer\u0171 felhaszn\u00e1l\u00f3n\u00e9v/jelsz\u00f3 alap\u00fa hiteles\u00edt\u00e9st. Ha git parancssorban a login sor\u00e1n \"Support for password authentication was removed.\" hiba\u00fczenetet kapunk, ez az oka. K\u00e9t megold\u00e1s is l\u00e9tezik a probl\u00e9ma megold\u00e1s\u00e1ra: </p> <ul> <li>A legegyszer\u0171bb megold\u00e1s a \"Git Credential Manager\" telep\u00edt\u00e9se. Ezt fel lehet telep\u00edten a git telep\u00edt\u00e9se sor\u00e1n (csak be kell pip\u00e1lni a telep\u00edt\u0151ben), de k\u00fcl\u00f6n is telep\u00edthet\u0151 innen. A telep\u00edt\u00e9st k\u00f6vet\u0151en nincs teend\u0151nk vele, a git automatikusan haszn\u00e1lni fogja, \u00e9s egy b\u00f6ng\u00e9sz\u0151 alap\u00fa (\u00fan. OAuth) hiteles\u00edt\u00e9si folyamaton vezeti v\u00e9gig a felhaszn\u00e1l\u00f3t, ill. plusz k\u00e9nyelmi funkci\u00f3k\u00e9nt meg is jegyzi a hiteles\u00edt\u00e9si adatokat.</li> <li>A m\u00e1sik megold\u00e1s a PAT (Personal Access Token) haszn\u00e1lata, err\u0151l pl. itt lehet olvasni.</li> </ul>"},{"location":"hazi/hf-folyamat/","title":"H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata","text":"<p>Ha m\u00e9g nem olvastad, c\u00e9lszer\u0171 itt kezdeni: Git, GitHub, GitHub Classroom</p>"},{"location":"hazi/hf-folyamat/#lepesek","title":"L\u00e9p\u00e9sek","text":"<p>Az egyes h\u00e1zi feladatok kiindul\u00f3 keret\u00e9t GitHub/GitHub Classroom seg\u00edts\u00e9g\u00e9vel publik\u00e1ljuk. Az \u00edgy publik\u00e1lt h\u00e1zi feladatok kiindul\u00f3 k\u00f6rnyezet let\u00f6lt\u00e9s\u00e9nek \u00e9s a megold\u00e1s bead\u00e1s\u00e1nak l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ol> <li> Az elindul\u00e1ssal ne v\u00e1rd meg a hat\u00e1rid\u0151 k\u00f6zeledt\u00e9t, legal\u00e1bb a saj\u00e1t repository l\u00e9trehoz\u00e1s\u00e1ig juss el miel\u0151bb. \u00cdgy, ha b\u00e1rmi elakad\u00e1s lenne, m\u00e9g id\u0151ben tudunk seg\u00edteni.</li> <li>Regisztr\u00e1lj egy GitHub accountot (https://github.com/), ha m\u00e9g nem regisztr\u00e1lt\u00e1l, \u00e9s l\u00e9pj be vele GitHub-ra.</li> <li>A feladathoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, Moodle-ben ker\u00fclnek meghirdet\u00e9sre fokozatosan a f\u00e9l\u00e9v folyam\u00e1n. A form\u00e1tuma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3: https://classroom.github.com/abcdefgh. Ha a hivatkoz\u00e1sra kattintva hib\u00e1t kapsz (\"There was a problem authenticating with GitHub, please try again.\"), copy-paste-tel m\u00e1sold be k\u00f6zvetlen\u00fcl a b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba a c\u00edmet.</li> <li>Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat.</li> <li>L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept this assignment\"). Kattints a gombra.</li> <li>V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A GitHub nem mindig friss\u00edti az oldalt mag\u00e1t\u00f3l, c\u00e9lszer\u0171 az oldal id\u0151nk\u00e9nti k\u00e9zi friss\u00edt\u00e9s\u00e9vel pr\u00f3b\u00e1lkozni (pl. F5 billenty\u0171). Ha elk\u00e9sz\u00fclt a repository, az oldal ki\u00edrja az \u00faj repository url-j\u00e9t, amin kattintva a repository-ra lehet navig\u00e1lni (ehhez hasonl\u00f3: https://github.com/bmeviauac14/hazi1-2023-username).  De nem is felt\u00e9tlen sz\u00fcks\u00e9ges az url elment\u00e9se, a GitHub nyit\u00f3oldal\u00e1n (https://github.com/) baloldalt a saj\u00e1t repository-k k\u00f6zt b\u00e1rmikor meg lehet k\u00e9s\u0151bb is tal\u00e1lni.</li> <li>Kl\u00f3nozd le a repository-t (ennek mik\u00e9ntj\u00e9re r\u00f6videsen visszat\u00e9r\u00fcnk). Ebben tal\u00e1lni fogsz egy keretet, vagy kiindul\u00f3 k\u00f3dot. Ezen dolgozz, ezt v\u00e1ltoztasd. Az alap\u00e9rtelmezett git \u00e1gon/branchen dolgozz (ha ez nem mond semmit, nem baj: ez csak azoknak sz\u00f3l, akik a git haszn\u00e1lat\u00e1ban j\u00e1rtasak \u00e9s t\u00f6bb \u00e1gon szoktak dolgozni).</li> <li> A kiindul\u00f3 projektben van egy .github/workflows mappa, ennek tartalm\u00e1t tilos megv\u00e1ltoztatni, t\u00f6r\u00f6lni stb.</li> <li> A munka sor\u00e1n a kiindul\u00e1si rep\u00f3ban lev\u0151 solutionben/projektben kell dolgozni, \u00faj projektet/solutiont ne hozz l\u00e9tre.</li> <li> A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>Oldd meg a feladatot. Pushold a hat\u00e1rid\u0151ig. Ak\u00e1rh\u00e1ny commitod lehet, a legutols\u00f3 \u00e1llapotot fogjuk n\u00e9zni.</li> <li>Az eredm\u00e9nyek Moodle-ben ker\u00fclnek meghirdet\u00e9sre (a nyit\u00f3oldalon kapcsol\u00f3d\u00f3 h\u00e1zi feladat oldal\u00e1t Moodle-ben megnyitva az oldal alj\u00e1n a \"Visszajelz\u00e9s\" szekci\u00f3ban l\u00e1that\u00f3). Eredm\u00e9nyek az adott feladatra vonatkoz\u00f3 hat\u00e1rid\u0151t k\u00f6vet\u0151 p\u00e1r napon bel\u00fcl v\u00e1rhat\u00f3k.</li> <li>A h\u00e1zi feladatot k\u00fcl\u00f6n explicit beadni nem kell, csak legyen fent GitHub-on hat\u00e1rid\u0151re a megold\u00e1s.</li> <li> Amikor a h\u00e1zi feladatod beadottnak tekinted,  c\u00e9lszer\u0171 ellen\u0151rizni a b\u00f6ng\u00e9sz\u0151ben a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st push-olt\u00e1l-e, \u00e9s hogy a neptun.txt val\u00f3ban ki van-e t\u00f6ltve.</li> </ol> <p>A fenti l\u00e9p\u00e9sek kapcs\u00e1n k\u00e9t k\u00e9rd\u00e9s v\u00e1r m\u00e9g megv\u00e1laszol\u00e1sra:</p> <ul> <li>Hogyan kl\u00f3nozzuk (clone) a rep\u00f3nkat (mely a h\u00e1zi feladat kiindul\u00f3 keret\u00e9t tartalmazza)?</li> <li>Hogyan commit-\u00e1ljunk \u00e9s push-oljunk a Visual Studio seg\u00edts\u00e9g\u00e9vel GitHub-ra?</li> </ul> <p>Az al\u00e1bbiakban ezekre is kit\u00e9r\u00fcnk.</p>"},{"location":"hazi/hf-folyamat/#github-repository-klonozasa","title":"GitHub repository kl\u00f3noz\u00e1sa","text":"<p>K\u00e9t lehet\u0151s\u00e9get n\u00e9z\u00fcnk meg al\u00e1bb:</p> <ul> <li>Kl\u00f3noz\u00e1s Visual Studioban</li> <li>Kl\u00f3noz\u00e1s parancssorb\u00f3l</li> </ul>"},{"location":"hazi/hf-folyamat/#klonozas-visual-studio-ban","title":"Kl\u00f3noz\u00e1s Visual Studio-ban","text":"<p>Egy (h\u00e1zi feladathoz tartoz\u00f3) repository kl\u00f3noz\u00e1sra sz\u00e1mos m\u00f3d van, egy lehet\u0151s\u00e9g a k\u00f6vetkez\u0151. Nyissuk meg az elk\u00e9sz\u00fclt repository online oldal\u00e1t, melyre t\u00f6bb m\u00f3don eljuthatunk. Lehet\u0151s\u00e9gek pl.:</p> <ul> <li>A repo l\u00e9trehoz\u00e1sakor megjelenik a GitHub fel\u00fcleten az url, csak kattintani kell rajta.</li> <li>A GitHub nyit\u00f3oldalon (https://github.com) - ha be vagyunk l\u00e9pve - list\u00e1z\u00f3dnak baloldalt azon repository-k, melyekhez van hozz\u00e1f\u00e9r\u00e9s\u00fcnk, csak kattintsunk a megfelel\u0151n.</li> <li>Amikor elk\u00e9sz\u00fcl a rep\u00f3nk (a GitHub classroom feladat elfogad\u00e1sa sor\u00e1n), e-mail \u00e9rtes\u00edt\u00e9st is kapunk r\u00f3la, ebben is megtal\u00e1lhat\u00f3 a link.</li> </ul> <p>Az oldal k\u00e9pe nagyj\u00e1b\u00f3l megfelel a k\u00f6vetkez\u0151nek (az mindenk\u00e9ppen k\u00fcl\u00f6nbs\u00e9g, hogy a rep\u00f3 url v\u00e9g\u00e9n mindenkin\u00e9l a saj\u00e1t felhaszn\u00e1l\u00f3neve szerepel):</p> <p></p> <p>Ind\u00edtsuk el a Visual Studiot, \u00e9s a megjelen\u0151 ablak jobb oldal\u00e1n kattintsunk a \"Clone a repository\" gombon. Ekkor a k\u00f6vetkez\u0151 ablak jelenik meg:</p> <p></p> <p>Itt a \"Repository location\" mez\u0151be m\u00e1soljuk be b\u00f6ng\u00e9sz\u0151ablak c\u00edmsor\u00e1b\u00f3l a repository-nk url-j\u00e9t. Az \u00fatvonal (Path) a l\u00e9trehozand\u00f3 projekt \u00fatvonala a f\u00e1jlrendszer\u00fcnkben, tetsz\u00e9s szerint megadhat\u00f3.</p> <p>A Clone-ra kattintva n\u00e9h\u00e1ny m\u00e1sodperc alatt a repository a megadott c\u00e9lmapp\u00e1ba kl\u00f3noz\u00f3dik.</p> <p>A kl\u00f3noz\u00e1st k\u00f6vet\u0151en pl. a Windows F\u00e1jlkezel\u0151ben (File Explorer)-ben meg tudjuk tekinteni a l\u00e9trehozott mapp\u00e1kat \u00e9s f\u00e1jlokat:</p> <p></p> <p>Ebb\u0151l j\u00f3l l\u00e1that\u00f3, hogy egy Git repository nem m\u00e1s, mint mapp\u00e1k \u00e9s f\u00e1jlok gy\u0171jtem\u00e9nye, valamint egy a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 .git mappa, mely - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve - az egyes f\u00e1jlok verzi\u00f3t\u00f6rt\u00e9net\u00e9t tartalmazza (a .git mappa \"rejtett\" tulajdons\u00e1g\u00fa, csak akkor l\u00e1that\u00f3, ha a f\u00e1jlkezel\u0151ben a rejtett f\u00e1jlok megjelen\u00edt\u00e9s\u00e9t is enged\u00e9lyezz\u00fck). A munka megkezd\u00e9s\u00e9hez csak meg kell nyissuk az adott h\u00e1zi feladathoz tartoz\u00f3 .sln kiterjeszt\u00e9s\u0171 solution f\u00e1jlt (pl. duplakatt a F\u00e1jlkezel\u0151ben).</p>"},{"location":"hazi/hf-folyamat/#klonozas-parancssorbol","title":"Kl\u00f3noz\u00e1s parancssorb\u00f3l","text":"<p>Alternat\u00edv lehet\u0151s\u00e9g a parancssor haszn\u00e1lata. Parancssorban navig\u00e1ljunk abba a mapp\u00e1ba, ahov\u00e1 a forr\u00e1sk\u00f3dot ki szeretn\u00e9nk clone-ozni, \u00e9s itt adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone &lt;repo url&gt;</code> , ahol a <code>&lt;repo url&gt;</code> a repositorynk c\u00edme (pl. b\u00f6ng\u00e9sz\u0151 c\u00edms\u00e1vj\u00e1b\u00f3l bem\u00e1solva, ehhez hasonl\u00f3: https://github.com/bmeviauac14/hazi1-2022-myusername). A parancs lefut\u00e1sa ut\u00e1n egy a repository nev\u00e9nek megfelel\u0151 alk\u00f6nyvt\u00e1rban tal\u00e1ljuk az \u00faj helyi rep\u00f3nkat.</p> <p>Parancssori git</p> <p>Ne f\u00e9lj\u00fcnk a parancssori git-et haszn\u00e1lni, egy repository clone-oz\u00e1s\u00e1nak tulajdonk\u00e9ppen ez a legegyszer\u0171bb m\u00f3dja.</p> <p>Amennyiben a parancs futtat\u00e1sa sor\u00e1n azt tapasztaljuk, hogy a git parancsot nem ismeri fel a k\u00f6rnyezet, annak oka val\u00f3sz\u00edn\u0171leg az, hogy nem telep\u00edtett\u00fcnk m\u00e9g a parancssori gitet a g\u00e9p\u00fcnkre. Err\u0151l b\u0151vebben itt.</p>"},{"location":"hazi/hf-folyamat/#napi-git-munka-visual-studio-segitsegevel-commit-push","title":"Napi Git munka Visual Studio seg\u00edts\u00e9g\u00e9vel (commit, push)","text":"<p>Miut\u00e1n lekl\u00f3noztuk az adott h\u00e1zi feladathoz tartoz\u00f3 GitHub repository-t a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre, \u00e9s ennek sor\u00e1n l\u00e9trej\u00f6tt a lok\u00e1lis Git repository-nk, a benne lev\u0151 .sln f\u00e1jlokat Visual Studioban megnyitva pont \u00fagy dolgozunk \u2013 vesz\u00fcnk fel \u00faj f\u00e1jlokat, m\u00f3dos\u00edtunk/t\u00f6rl\u00fcnk megl\u00e9v\u0151ket \u2013 mintha a f\u00e1jlok nem is tartozn\u00e1nak semmif\u00e9le Git rep\u00f3hoz. Ugyanakkor, legk\u00e9s\u0151bb a feladat bead\u00e1sakor a v\u00e1ltoztat\u00e1sainkat commit-olni kell, majd push-olni GitHub-ra. A munka sor\u00e1n ak\u00e1rh\u00e1nyszor commit-\u00e1lhatjuk/push-olhatjuk az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat: a h\u00e1zi feladat ellen\u0151rz\u00e9sekor a hat\u00e1rid\u0151 pillanat\u00e1ban a GitHub-on tal\u00e1lhat\u00f3 \u00e1llapot ker\u00fcl elb\u00edr\u00e1l\u00e1sra, teljesen mindegy, h\u00e1ny commit tartozik hozz\u00e1. A commit \u00e9s push m\u0171veletek v\u00e9grehajt\u00e1s\u00e1hoz a Visual Studio \"Git\" men\u00fcj\u00e9ben lev\u0151 parancsokat haszn\u00e1ljuk.</p>"},{"location":"hazi/hf-folyamat/#commit","title":"Commit","text":"<p>Az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt v\u00e1ltoztat\u00e1sok megtekint\u00e9s\u00e9hez v\u00e1lasszuk ki a \"View\\Git Changes\" men\u00fct. Ennek hat\u00e1s\u00e1ra megjelenik a \"Git Changes\" n\u00e9zet a v\u00e1ltoz\u00e1sok list\u00e1j\u00e1val:</p> <p></p> <p>A v\u00e1ltoztat\u00e1sok commit-\u00e1l\u00e1s\u00e1hoz \u00edrjunk a fenti sz\u00f6vegmez\u0151be egy a v\u00e1ltoztat\u00e1sokra jellemz\u0151 egy-k\u00e9t soros le\u00edr\u00e1st (pl. \"V\u00e9gs\u0151 megold\u00e1s\", \"Az xyz hiba jav\u00edt\u00e1sa\" stb.). A lehet\u0151s\u00e9geink ezt k\u00f6vet\u0151en a k\u00f6vetkez\u0151k:</p> <ul> <li>\"Commit All\" gomb: Csak helyben commit-olja a v\u00e1ltoztat\u00e1sokat (a k\u00f6zponti Git rep\u00f3ban mindaddig nem jelenik meg a commit, am\u00edg egy k\u00fcl\u00f6n Push paranccsal fel nem \"toljuk\").</li> <li>\"Commit All and Push\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit, majd ut\u00e1na push. Ha a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lni is szeretn\u00e9nk a GitHub-on lev\u0151 k\u00f6zponti rep\u00f3ba, akkor haszn\u00e1ljuk b\u00e1tran parancsot. A h\u00e1zi feladatok tekintet\u00e9ben c\u00e9lszer\u0171 is ezt haszn\u00e1lni, mert ekkor nincs sz\u00fcks\u00e9g a commit-ot k\u00f6vet\u0151en k\u00fcl\u00f6n push m\u0171veletre. Megjegyz\u00e9s: ha a parancs az \"Unable to push to the remote repository because your local branch is behind the remote branch\" hib\u00e1val z\u00e1rul, el\u0151bb pull-oljuk, majd ism\u00e9telj\u00fck meg a push-t. Erre m\u00e9g al\u00e1bb visszat\u00e9r\u00fcnk.</li> <li>\"Commit All and Sync\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit ut\u00e1n pull (leszedi a saj\u00e1t helyi rep\u00f3nkba m\u00e1sok esetleges v\u00e1ltoztat\u00e1sait a k\u00f6zponti rep\u00f3b\u00f3l), majd push. \u00cdgy a k\u00f6zponti rep\u00f3ban lev\u0151 esetleges v\u00e1ltoz\u00e1sokat lehozza a helyi rep\u00f3nkba, az ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lja is ide.</li> </ul> <p>Note</p> <p>A git commit-ot mindig meg kell el\u0151zze egy \u00fan. stage l\u00e9p\u00e9s, mely sor\u00e1n kiv\u00e1lasztjuk azokat a helyi v\u00e1ltoztat\u00e1sokat, melyeket a k\u00f6vetkez\u0151 commit-ba be k\u00edv\u00e1nunk tenni. Ez az \u00fan. staging area ter\u00fcletre teszi az \u00e1ltalunk kiv\u00e1lasztott v\u00e1ltoz\u00e1sokat (a f\u00e1jlrendszerben nem mozgat semmif\u00e9le f\u00e1jlt, ez csak a git a bels\u0151 nyilv\u00e1ntart\u00e1s\u00e1ban jelenik meg). Ez az\u00e9rt j\u00f3, mert plusz rugalmass\u00e1got biztos\u00edt, hiszen nem biztos, mindig minden v\u00e1ltoztat\u00e1st bele k\u00edv\u00e1nunk tenni a k\u00f6vetkez\u0151 commit-ba. A fenti \"Commit all\" stb. parancsok nev\u00e9ben nem v\u00e9letlen van benne az \"all\": ezek a sz\u00ednfalak m\u00f6g\u00f6tt a commit el\u0151tt egy megfelel\u0151 git paranccsal valamennyi v\u00e1ltoz\u00e1st a git staging area-ra tesznek, \u00edgy ezt nek\u00fcnk nem kell k\u00fcl\u00f6n megtenn\u00fcnk.</p>"},{"location":"hazi/hf-folyamat/#push-pull","title":"Push, Pull","text":"<p>A commit m\u0171velet csak a helyi repository-ban \"\u00e9rv\u00e9nyes\u00edti\" a v\u00e1ltoztat\u00e1sokat. Ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sokat a GitHub k\u00f6zponti repository-nkba fel kell t\u00f6lteni a push m\u0171velettel. Erre a l\u00e9p\u00e9sre csak akkor van sz\u00fcks\u00e9g, ha a commit sor\u00e1n nem haszn\u00e1ltuk a \"Commit All and Push\" vagy \"Commit All and Sync\" parancsokat. A push m\u0171velet VS-ben a \"Git/Push\" men\u00fc seg\u00edt\u00e9s\u00e9vel ind\u00edthat\u00f3.  Ha t\u00f6bben dolgozunk, a k\u00f6zponti repository-ban lehetnek m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok (vagy ak\u00e1r olyanok, melyeket mi magunk push-oltunk egy m\u00e1sik lok\u00e1lis clone-b\u00f3l, vagy ha a GitHub online fel\u00fclet\u00e9n eszk\u00f6z\u00f6lt\u00fcnk a k\u00f3don v\u00e1ltoz\u00e1sokat). Ezeket a pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni (Git/Pull men\u00fc). A h\u00e1zi feladat vonatkoz\u00e1s\u00e1ban ezt nem haszn\u00e1ljuk, hiszen mindenki saj\u00e1t dedik\u00e1lt k\u00f6zponti repositoryval rendelkezik, melyben egyed\u00fcl dolgozik (kiv\u00e9ve, ha esetleg valaki a GitHub fel\u00fclet\u00e9nek seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztatott a k\u00f3don, akkor ezt egy pull-lal tudja a helyi rep\u00f3j\u00e1ba lehozni).</p> <p>Note</p> <p>A push csak akkor hajthat\u00f3 v\u00e9gre, ha a k\u00f6zponti rep\u00f3ban nincs olyan v\u00e1ltoz\u00e1s, melyet m\u00e9g a pull paranccsal nem hoztunk le \u00e9s merge-elt\u00fcnk a saj\u00e1t lok\u00e1lis rep\u00f3nkba. Ha ez nincs \u00edgy, egy ehhez hasonl\u00f3 hiba\u00fczenet kapunk: \"Unable to push to the remote repository because your local branch is behind the remote branch\". Ekkor pull-oljunk, ut\u00e1na ism\u00e9telj\u00fck meg a pusht.</p> <p>Note</p> <p>A pull m\u0171velet csak akkor hajthat\u00f3 v\u00e9gre, ha nincs olyan v\u00e1ltoztat\u00e1sunk helyben, melyeket m\u00e9g nem commit\u00e1ltunk. Ha van ilyen, akkor azokat vagy commit\u00e1ljuk (vagy ha ezt nem akarjuk megtenni m\u00e9g, akkor stash-elj\u00fck a pull idej\u00e9re).</p> <p>Tip</p> <p>A Pull \u00e9s Push parancsok a \u201eGit Changes\u201d (View/Git Changes men\u00fc jelen\u00edti meg) panel tetej\u00e9n el\u00e9rhet\u0151 le \u00e9s fel nyilakkal is v\u00e9grehajthat\u00f3k:</p> <p></p>"},{"location":"hazi/hf-folyamat/#git-history","title":"Git history","text":"<p>A Git egy v\u00e1ltoz\u00e1sk\u00f6vet\u0151 rendszer. A v\u00e1ltoz\u00e1s egys\u00e9ge a commit (melyben tetsz\u0151leges sz\u00e1m\u00fa f\u00e1jlt \u00e9rint\u0151 v\u00e1ltoz\u00e1s lehet), a Git historyban a commitok egym\u00e1sut\u00e1nis\u00e1g\u00e1t l\u00e1thatjuk. A f\u00e1jlokat \u00e9rint\u0151 v\u00e1ltoz\u00e1sokon t\u00falmen\u0151en minden commithoz tartozik egy egyedi azonos\u00edt\u00f3 (commit hash), id\u0151b\u00e9lyeg, illetve egy szerz\u0151. A szerz\u0151 felhaszn\u00e1l\u00f3, aki a v\u00e1ltoz\u00e1sokat eszk\u00f6z\u00f6lte (val\u00f3j\u00e1ban van k\u00fcl\u00f6n Author \u00e9s Commiter, de a kett\u0151 \u00e1ltal\u00e1ban ugyanaz). Visual Studioban a historyt a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni, de a history term\u00e9szetesen a GitHub online fel\u00fclet\u00e9n is megjelen\u00edthet\u0151. A Visual Studioban a \"Git Repository\" n\u00e9zetet a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni.</p> <ul> <li>Outgoing commits: Megmutatja, hogy milyen, a lok\u00e1lis repository-nkba m\u00e1r l\u00e9tez\u0151, de a k\u00f6zponti rep\u00f3ba m\u00e9g nem push-olt commitok vannak. Ezeket a Push m\u0171velettel tudjuk felt\u00f6lteni.</li> <li>Incoming commits: Megmutatja, hogy a k\u00f6zponti repository-ban milyen m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok vannak. Ezek akkor jelennek meg, ha a Fetch paranccsal lehozzuk a helyi rep\u00f3ba (ez m\u00e9g nem merge-el). Ezeket a Pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni. A fetch parancsot ritk\u00e1n haszn\u00e1ljuk: \u00e1ltal\u00e1ban a pullt haszn\u00e1ljuk mag\u00e1ban, ami egy fecth + merge (v\u00e1ltoz\u00e1sok merge-el\u00e9se a helyi rep\u00f3ba) kombin\u00e1ci\u00f3ja.</li> </ul> <p>P\u00e9lda:</p> <p></p> <p>Tip</p> <p>Am\u00edg nem vagyunk rutinosak a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00fcnk-e.</p>"},{"location":"hazi/hf-folyamat/#egyeb-iranyelvek","title":"Egy\u00e9b ir\u00e1nyelvek","text":"<p>A Git commit \u00e9s push sor\u00e1n megfigyelhetj\u00fck, hogy a solution-jeink k\u00f6ztes \u00e9s kimeneti \u00e1llom\u00e1nyai (.dll, .exe, stb. f\u00e1jlok) nem ker\u00fclnek bele a commitba, \u00e9s \u00edgy nem ker\u00fclnek fel GitHubra sem. Ez \u00edgy is van j\u00f3l, ezen \u00e1llom\u00e1nyok b\u00e1rmikor reproduk\u00e1lhat\u00f3k, a verzi\u00f3kezel\u0151 rendszernek nem feladata ezek t\u00e1rol\u00e1sa, csak felesleges \u00e9s zavar\u00f3 helyfoglal\u00f3k lenn\u00e9nek. Felmer\u00fcl a k\u00e9rd\u00e9s, honnan tudja a Git, hogy mely \u00e1llom\u00e1nyokat sz\u00fcks\u00e9ges figyelmen k\u00edv\u00fcl hagyni a commit sor\u00e1n. Erre szolg\u00e1l a repository-ban (tipikusan annak gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban) tal\u00e1lhat\u00f3 .gitignore f\u00e1jl, mely felsorolja azon mapp\u00e1kat, f\u00e1jlkiterjeszt\u00e9seket, illetve egyedi f\u00e1jlokat, melyeket a commit sor\u00e1n figyelmen k\u00edv\u00fcl szeretn\u00e9nk hagyni. A .gitignore f\u00e1jl tartalma teljes eg\u00e9sz\u00e9ben a kez\u00fcnk al\u00e1 tartozik, szabadon szerkeszthet\u0151/commit\u00e1lhat\u00f3/pusholhat\u00f3. A t\u00e1rgy keret\u00e9ben minden kiindul\u00f3 rep\u00f3nak r\u00e9sze egy .gitignore f\u00e1jl, ne v\u00e1ltoztassuk a tartalm\u00e1t! \u00cdgy a commit/push sor\u00e1n a kimeneti \u00e1llom\u00e1nyok a h\u00e1zi feladatok eset\u00e9ben sem ker\u00fclnek fel GitHub-ra, \u00e9s egy \u00edgy is van rendj\u00e9n.</p> <p>A f\u00e9l\u00e9vben a feladatok megold\u00e1sa sor\u00e1n az egyes oszt\u00e1lyok, interf\u00e9szek stb. forr\u00e1sk\u00f3dj\u00e1t k\u00fcl\u00f6n f\u00e1jlba kell tenni, vagyis egy C# forr\u00e1sf\u00e1jlban egy oszt\u00e1ly/interf\u00e9sz/stb. defin\u00edci\u00f3ja legyen.</p>"},{"location":"hazi/hf-folyamat/#git-hasznalata-parancssorbol","title":"Git haszn\u00e1lata parancssorb\u00f3l","text":"<p>B\u00e1r sokan \u00f3dzkodnak a git parancssori alkalmaz\u00e1s\u00e1t\u00f3l, az egyszer\u0171bb m\u0171veleteket gyakran gyorsabban v\u00e9gre tudjuk hajtani parancssorb\u00f3l, mint a GUI fel\u00fcleteken t\u00f6rt\u00e9n\u0151 kattintgat\u00e1sokkal. Az al\u00e1bbiakban egy egyszer\u0171 l\u00e9p\u00e9ssorozattal illusztr\u00e1ljuk ezt. Ezeket a t\u00e1rgy keret\u00e9ben nem kell tudni, de hosszabb t\u00e1von mindenk\u00e9ppen hasznos (\u00e9s az ipar\u00e1gban elv\u00e1r\u00e1s is) az ismeret\u00fck.</p> <ol> <li> <p>Repository clone (ezt csak egyszer)</p> <p><code>git clone https://github.com/bmeviauac14/hazi1-2022-myusername</code></p> </li> <li> <p>V\u00e1ltoztat\u00e1sok v\u00e9grehajt\u00e1sa a helyi rep\u00f3ban (f\u00e1jlrendszerben, fejleszt\u0151eszk\u00f6zben).</p> </li> <li> <p>V\u00e1ltoztat\u00e1sok megtekint\u00e9se, mutatja melyek az \u00faj/t\u00f6r\u00f6lt/m\u00f3dosult f\u00e1jlok (nem k\u00f6telez\u0151, csak ha k\u00edv\u00e1ncsiak vagyunk r\u00e1)*</p> <p><code>git status</code></p> </li> <li> <p>Minden v\u00e1ltoztat\u00e1s felt\u00e9tele a staging area-ra</p> <p><code>git add -A</code></p> <p>Ha ezt k\u00f6vet\u0151en ism\u00e9t kiadjuk <code>git status</code> parancsot (nem k\u00f6telez\u0151), l\u00e1tjuk, hogy minden v\u00e1ltoz\u00e1s stage-elve van.</p> </li> <li> <p>Commit</p> <p><code>git commit -m \"megjegyz\u00e9s a commithoz\"</code></p> </li> <li> <p>Push</p> <p><code>git push</code></p> </li> </ol> <p>Megjegyz\u00e9sek:</p> <ul> <li>Ha t\u00f6bben is dolgozunk az adott git \u00e1gon, akkor a 6. push el\u0151tt sz\u00fcks\u00e9g lehet/van egy <code>git pull</code>-ra, hogy m\u00e1sok v\u00e1ltoztat\u00e1sai megjelenjenek a mi helyi rep\u00f3nkban (en\u00e9lk\u00fcl nem fogunk tudni push-olni). A pull-nak c\u00e9lszer\u0171 lehet megadni a <code>--rebase</code> opci\u00f3t is, hogy ne sz\u00fclessen a merge-hez egy plusz merge commit, ennek magyar\u00e1zat\u00e1ra itt nem t\u00e9r\u00fcnk ki.</li> <li> <p>Mint kor\u00e1bban eml\u00edtett\u00fck, a commit sor\u00e1n a commithoz hozz\u00e1rendel\u0151dik egy felhaszn\u00e1l\u00f3n\u00e9v \u00e9s e-mail c\u00edm. Ha ezek nincsenek a git sz\u00e1m\u00e1ra bekonfigur\u00e1lva, akkor a git a commit sor\u00e1n ezt hiba\u00fczenetben jelzi. Ekkor az al\u00e1bbi parancsokkal - \u00e9rtelemszer\u0171en a saj\u00e1t felhaszn\u00e1l\u00f3nev\u00fcnket \u00e9s e-mail c\u00edm\u00fcnket megadva - tudjuk ezeket a git glob\u00e1lis konfigur\u00e1ci\u00f3j\u00e1ban be\u00e1ll\u00edtani (ezt csak egyszer kell megtenni):</p> <pre><code>git config --global user.email \"you@example.com\"\ngit config --global user.name \"myusername\"\n</code></pre> </li> <li> <p>Windows parancssorban \u00f6sszevonhatunk t\u00f6bb parancsot is egy sorba, pl. egy l\u00e9p\u00e9sben minden v\u00e1ltoz\u00e1sra stage/commit/push:</p> <p><code>git add -A &amp; git commit -m \"All tests run\" &amp; git push</code></p> <p>Powershell haszn\u00e1latakor a <code>&amp;</code> helyett <code>;</code>-t kell szepar\u00e1tork\u00e9nt haszn\u00e1lni.</p> </li> </ul>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa","text":""},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A feladatok gyakorlati h\u00e1tter\u00e9\u00fcl a kapcsol\u00f3d el\u0151ad\u00e1sok \u00e9s a A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Windows Forms tervez\u0151 haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Alapvet\u0151 vez\u00e9rl\u0151k (gomb, sz\u00f6vegdoboz, men\u00fck, list\u00e1k) haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Esem\u00e9nyvez\u00e9relt programoz\u00e1s gyakorl\u00e1sa</li> <li>Grafikus megjelen\u00edt\u00e9s gyakorl\u00e1sa Windows Forms technol\u00f3gi\u00e1val</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezet: Visual Studio (a \".NET Desktop development\u201d Workloadnak telep\u00edtve kell lennie az installer\u00e9ben).</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<p> B\u00e1r az alapok hasonl\u00f3k, vannak l\u00e9nyeges, a folyamatra \u00e9s k\u00f6vetelm\u00e9nyekre vonatkoz\u00f3 elt\u00e9r\u00e9sek a kor\u00e1bbi h\u00e1zi feladatokhoz k\u00e9pest, \u00edgy mindenk\u00e9ppen figyelmesen olvasd el a k\u00f6vetkez\u0151ket.</p> <ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>WinFormExpl.sln</code>-t megnyitva kell dolgozni.</li> <li> Az egyes feladatok le\u00edr\u00e1s\u00e1n\u00e1l K\u00fcl\u00f6n megjel\u00f6lt\u00fck (olyan st\u00edlusban, mint ahogy itt az el\u0151z\u0151 sz\u00f6vegr\u00e9szt l\u00e1tod) azokat az azonos\u00edt\u00f3kat, sz\u00f6vegeket, melyekn\u00e9l fontos, hogy a beadott feladatban a megadott \u00e9rt\u00e9k szerepeljen.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> </ul>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#elnevezesek","title":"Elnevez\u00e9sek","text":"<p> Az al\u00e1bbiakban, a feladatok le\u00edr\u00e1sa sor\u00e1n bizonyos elnevez\u00e9sek ennek a mint\u00e1nak megfelel\u0151 kiemelt sz\u00f6vegst\u00edlussal szerepelnek. L\u00e9nyeges, hogy ezekn\u00e9l pontosan k\u00f6vesd az elnevez\u00e9st, m\u00e1sk\u00fcl\u00f6nben a megold\u00e1s nem lesz elfogadhat\u00f3 (a megold\u00e1sok r\u00e9szben automata ellen\u0151rz\u0151vel ker\u00fclnek majd ki\u00e9rt\u00e9kel\u00e9sre, mely \u00e9p\u00edt ezekre, emiatt van ennek jelent\u0151s\u00e9ge).</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#visual-studio-designer-hiba","title":"Visual Studio designer hiba","text":"<p>Az al\u00e1bbiakat csak akkor \u00e9rdemes kinyitni \u00e9s megn\u00e9zni, ha valami\u00e9rt nem ny\u00edlik meg Visual Studioban az \u0171rlap szerkeszt\u0151fel\u00fclete.</p> Ha nem ny\u00edlik meg az \u0171rlap szerkeszt\u00e9sre <p>A Visual Studio 2022 a Git-b\u0151l frissen kikl\u00f3nozott forr\u00e1s eset\u00e9n (amikor m\u00e9g nem l\u00e9tezik egy .csproj.user kiterjeszt\u00e9s\u0171 f\u00e1jl) az \u0171rlapokat  - val\u00f3sz\u00edn\u0171s\u00edthet\u0151en egy bug miatt \u2013 id\u0151nk\u00e9nt nem hajland\u00f3 megnyitni szerkeszt\u0151 m\u00f3dban (szerencs\u00e9re ez nagyon ritka). A solution megnyit\u00e1sa ut\u00e1n ez esetben ezt l\u00e1tjuk:</p> <p></p> <p>A probl\u00e9ma az, hogy a <code>Form1.cs</code> el\u0151tti ikon (pirossal bekeretezve) nem egy \u0171rlap, hanem egy z\u00f6ld C# ikon. Ez esetben hi\u00e1ba kattintunk dupl\u00e1n a f\u00e1jlon, nem az \u0171rlap szerkeszt\u0151 ny\u00edlik meg, hanem csak a forr\u00e1sf\u00e1jl. A megold\u00e1s ez esetben a k\u00f6vetkez\u0151: a Build men\u00fcben v\u00e1lasszuk ki a \u201eRebuild solution\u201d men\u00fct, majd a Build men\u00fcben a \u201eClean solution\u201d men\u00fct, \u00e9s v\u00e1rjunk egy kicsit. Ekkor p\u00e1r m\u00e1sodperc m\u00falva a Solution Explorerben az \u0171rlapunk ikonja megv\u00e1ltozik:</p> <p></p> <p>Most m\u00e1r meg tudjuk nyitni az \u0171rlapot szerkeszt\u00e9sre, ha dupl\u00e1n kattintunk a Solution Explorerben a fenti csom\u00f3ponton.</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat-1-menu","title":"Feladat 1- Men\u00fc","text":""},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#bevezeto-feladat","title":"Bevezet\u0151 feladat","text":"<p> A f\u0151ablak fejl\u00e9ce a \"MiniExplorer\" sz\u00f6veg legyen, hozz\u00e1f\u0171zve a saj\u00e1t Neptun k\u00f3dod: (pl. \"ABCDEF\" Neptun k\u00f3d eset\u00e9n \"MiniExplorer - ABCDEF\u201d), fontos, hogy ez legyen a sz\u00f6veg! Ehhez az \u0171rlapunk <code>Text</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be erre a sz\u00f6vegre.</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat","title":"Feladat","text":"<p>Vezess\u00fcnk be egy men\u00fcsort a f\u0151ablakunk (<code>MainForm</code>) tetej\u00e9n. A men\u00fcben egyetlen elem legyen \"File\u201d n\u00e9ven, k\u00e9t almen\u00fcvel:</p> <ul> <li>Open: k\u00e9s\u0151bb adunk neki funkci\u00f3t</li> <li>Exit: kil\u00e9p az alkalmaz\u00e1sb\u00f3l</li> </ul> <p> L\u00e9nyeges, hogy a men\u00fck sz\u00f6vegei a fent megadottak legyenek!</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#megoldas","title":"Megold\u00e1s","text":"<ol> <li>H\u00fazzunk be a fel\u00fcletre egy <code>MenuStrip</code> vez\u00e9rl\u0151t.</li> <li>A <code>MenuStrip</code> vez\u00e9rl\u0151 bal sz\u00e9l\u00e9n megjelen\u0151 sz\u00f6vegdobozba \u00edrjuk be, hogy \"File\u201d, ezzel l\u00e9trehoztuk a f\u0151men\u00fct.</li> <li>Az \u00fajonnan l\u00e9trehozott f\u0151men\u00fct kijel\u00f6lve hozzuk l\u00e9tre a k\u00e9t almen\u00fct.</li> <li> <p>Egyes\u00e9vel kijel\u00f6lgetve a men\u00fcelemeket, t\u00f6lts\u00fck ki a nev\u00fcket (<code>miOpen</code>, <code>miExit</code>).</p> <p> A vez\u00e9rl\u0151knek csak a <code>Name</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsd, az <code>AccessibleName</code>-t ne. Ez a k\u00e9s\u0151bbi feladatokra is vonatkozik.</p> </li> <li> <p>Val\u00f3s\u00edtsuk meg a kil\u00e9p\u00e9s funkci\u00f3t a kapcsol\u00f3d\u00f3 gyakorlathoz hasonl\u00f3an.</p> </li> </ol>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat-2-dialogusablak","title":"Feladat 2 \u2013 Dial\u00f3gusablak","text":"<p>A Windows Forms vil\u00e1gban gyakran fordul el\u0151, hogy egyedi vez\u00e9rl\u0151ket, vagy \u0171rlap t\u00edpusokat akarunk defini\u00e1lni, tov\u00e1bb\u00e1 ezek \u00e9s a programunk t\u00f6bbi r\u00e9sze k\u00f6z\u00f6tt inform\u00e1ci\u00f3t akarunk \u00e1tadni. A k\u00f6vetkez\u0151 feladat erre mutat p\u00e9ld\u00e1t.</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat_1","title":"Feladat","text":"<p>K\u00e9sz\u00edts egy \u00faj \u0171rlap/ablak (<code>Form</code>) t\u00edpust InputDialog n\u00e9ven (a fejl\u00e9ce is legyen InputDialog), mely egy sz\u00f6vegdobozt (<code>TextBox</code>) \u00e9s Path felirat\u00fa <code>Label</code>-t, tov\u00e1bb\u00e1 egy Ok \u00e9s egy Cancel felirat\u00fa gombot tartalmaz. Az \u0171rlap gombokkal t\u00f6rt\u00e9n\u0151 bez\u00e1r\u00e1shoz \u00e1ll\u00edtsd be a k\u00e9t gomb <code>DialogResult</code> tulajdons\u00e1g\u00e1t <code>DialogResult.OK</code> \u00e9s <code>DialogResult.Cancel</code> \u00e9rt\u00e9kre, majd az \u0171rlap <code>AcceptButton</code> \u00e9s <code>CancelButton</code> tulajdons\u00e1gait a nekik megfelel\u0151 \u00e9rt\u00e9kekre. Az \u0171rlap ezen fel\u00fcl tartalmazzon egy publikus, <code>string</code> t\u00edpus\u00fa, <code>Path</code> nev\u0171 tulajdons\u00e1got (mellyel a sz\u00f6vegdoboz sz\u00f6veg\u00e9t lehet lek\u00e9rni \u00e9s v\u00e1ltoztatni)!</p> <p>Az \u0171rlap tartalma ar\u00e1nyosan v\u00e1ltozzon az \u00e1tm\u00e9retez\u00e9s sor\u00e1n:</p> <ul> <li><code>TextBox</code> sz\u00e9less\u00e9ge n\u00f6vekedjen (a helye \u00e9s magass\u00e1ga ne v\u00e1ltozzon).</li> <li>Az \u0171rlap \u00e1tm\u00e9retez\u00e9sekor a gombok a hozz\u00e1juk k\u00f6zelebbi sarokhoz k\u00e9pest r\u00f6gz\u00edtett poz\u00edci\u00f3ban maradjanak (mind x mind y koordin\u00e1ta tekintet\u00e9ben, az ablak sz\u00e9less\u00e9g\u00e9nek \u00e9s magass\u00e1g\u00e1nak \u00e1ll\u00edt\u00e1sakor is). Az Ok gomb legyen bal als\u00f3, a Cancel pedig jobb als\u00f3 sarokhoz r\u00f6gz\u00edtve.</li> </ul> <p>K\u00f6ss\u00fck be az elk\u00e9sz\u00edtett ablakunkat a f\u0151ablakba! Az Open felirat\u00fa almen\u00fc kattint\u00e1sra mod\u00e1lisan (<code>ShowDialog</code>) nyisson meg egy p\u00e9ld\u00e1nyt az \u00faj ablakb\u00f3l.</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#megoldas_1","title":"Megold\u00e1s","text":"<p>A feladatot pr\u00f3b\u00e1ld meg \u00f6n\u00e1ll\u00f3an megoldani, majd a lenti le\u00edr\u00e1s alapj\u00e1n ellen\u0151rizd a megold\u00e1sod!</p> Megold\u00e1s <ol> <li> <p>Adjunk hozz\u00e1 a projekt\u00fcnkh\u00f6z egy \u00faj \u0171rlap t\u00edpust (projekten jobb klikk, majd Add / Form (Windows Forms), a neve legyen InputDialog.</p> </li> <li> <p>Adjunk az \u0171rlaphoz egy <code>TextBox</code>, egy <code>Label</code> \u00e9s k\u00e9t <code>Button</code> vez\u00e9rl\u0151t. Rendezz\u00fck el \u0151ket a fel\u00fcleten \u00e9s \u00e1ll\u00edtsuk be a tulajdons\u00e1gaikat:</p> <ul> <li><code>TextBox</code><ul> <li><code>Name</code>: <code>tPath</code></li> </ul> </li> <li><code>Button</code><ul> <li><code>Name</code>: <code>bOk</code></li> <li><code>Text</code>: \"Ok\"</li> <li><code>DialogResult</code>: <code>OK</code></li> </ul> </li> <li><code>Button</code><ul> <li><code>Name</code>: <code>bCancel</code></li> <li><code>Text</code>: \"Cancel\"</li> <li><code>DialogResult</code>: <code>Cancel</code></li> </ul> </li> <li><code>Label</code><ul> <li><code>Text</code>: \"Path\"</li> </ul> </li> <li><code>InputDialog</code> (maga a <code>Form</code>)<ul> <li><code>AcceptButton</code>: <code>bOk</code></li> <li><code>CancelButton</code>: <code>bCancel</code></li> </ul> </li> </ul> <p>A dial\u00f3gusablak elk\u00e9sz\u00edt\u00e9sekor kihaszn\u00e1ljuk azt, hogy egy mod\u00e1lis dial\u00f3gusablakot nem csak a <code>Close</code> utas\u00edt\u00e1ssal lehet bez\u00e1rni, hanem \u00fagy is, ha \u00e9rt\u00e9ket adunk a <code>DialogResult</code> tulajdons\u00e1g\u00e1nak. Ezt k\u00f3db\u00f3l is megtehett\u00fck volna, de mi most a gombok erre szolg\u00e1l\u00f3 mechanizmus\u00e1t haszn\u00e1ltuk a <code>Form</code> <code>Accept</code> \u00e9s <code>Cancel</code> button tulajdons\u00e1gaival.</p> </li> <li> <p>Az egyes vez\u00e9rl\u0151k <code>Anchor</code> tulajdons\u00e1gainak be\u00e1ll\u00edt\u00e1saival \u00e9rj\u00fck el, hogy az ablak tartalma ar\u00e1nyosan v\u00e1ltozzon az \u00e1tm\u00e9retez\u00e9s sor\u00e1n: a <code>TextBox</code> sz\u00e9less\u00e9ge n\u00f6vekedjen, a gombok pedig a hozz\u00e1juk k\u00f6zelebbi sarokhoz k\u00e9pest r\u00f6gz\u00edtett poz\u00edci\u00f3ban maradjanak (mind x mind y koordin\u00e1ta tekintet\u00e9ben, az ablak sz\u00e9less\u00e9g\u00e9nek \u00e9s magass\u00e1g\u00e1nak \u00e1ll\u00edt\u00e1sakor is).</p> </li> <li> <p>Vegy\u00fcnk fel egy <code>Path</code> nev\u0171 tulajdons\u00e1got az <code>InputDialog.cs</code> f\u00e1jlba, mely a <code>TextBox</code> tartalm\u00e1t teszi el\u00e9rhet\u0151v\u00e9 az oszt\u00e1lyon k\u00edv\u00fclr\u0151l is. (A tervez\u0151i n\u00e9zet \u00e9s a forr\u00e1sn\u00e9zet k\u00f6z\u00f6tt az F7 billenty\u0171vel v\u00e1lthatunk.)</p> <pre><code>public string Path\n{\nget { return tPath.Text; }\nset { tPath.Text = value; }\n}\n</code></pre> </li> <li> <p>K\u00f6ss\u00fck be a dial\u00f3gusablakot a f\u0151ablakba! Ehhez kattintsunk dupl\u00e1n a Open men\u00fcelemre \u00e9s \u00edrjuk meg a dial\u00f3gusablak l\u00e9trehoz\u00e1s\u00e1nak \u00e9s megjelen\u00edt\u00e9s\u00e9nek k\u00f3dj\u00e1t.</p> <pre><code>private void miOpen_Click(object sender, EventArgs e)\n{\nvar dlg = new InputDialog();\nif (dlg.ShowDialog() == DialogResult.OK)\n{\nstring result = dlg.Path;\nMessageBox.Show(result);\n// TODO: tov\u00e1bbi l\u00e9p\u00e9sek...\n}\n}\n</code></pre> <p>Elnevez\u00e9sek</p> <p>A WinForms vil\u00e1gban rendk\u00edv\u00fcl gyakori, hogy egy adott inform\u00e1ci\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 szint\u0171 el\u00e9r\u00e9s\u00e9rt egy vez\u00e9rl\u0151 \u00e9s egy tulajdons\u00e1g is felel (mint eset\u00fcnkben a <code>tPath</code> sz\u00f6vegdoboz \u00e9s a <code>Path</code> tulajdons\u00e1g). A vez\u00e9rl\u0151k neveinek prefix\u00e1l\u00e1s\u00e1val (amit itt is alkalmaztunk) elker\u00fclhetj\u00fck a nem k\u00edv\u00e1nt n\u00e9v\u00fctk\u00f6z\u00e9seket.</p> <p> A <code>MessageBox.Show(result);</code> sort kommentezz\u00fck is ki, a k\u00e9s\u0151bbiekben zavar\u00f3 lenne.</p> </li> </ol> <p>BEADAND\u00d3</p> <p> Miel\u0151bb tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened <code>Feladat2.png</code> n\u00e9ven az al\u00e1bbiaknak megfelel\u0151en:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>MainForm.cs</code> megnyitva,</li> <li>a VS View / Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>VS-ben zoomolj \u00fagy, hogy a f\u00e1jl teljes tartalma, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka legyen l\u00e1that\u00f3.</li> </ul> <p>Amiatt ne agg\u00f3dj, ha a k\u00e9pen a sz\u00f6veg esetleg nehezen kiolvashat\u00f3.</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat-3-fajlkezelo","title":"Feladat 3 \u2013 F\u00e1jlkezel\u0151","text":""},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat_2","title":"Feladat","text":"<p>A megl\u00e9v\u0151 k\u00f3dunkb\u00f3l kiindulva val\u00f3s\u00edts meg egy f\u00e1jl n\u00e9zeget\u0151 alkalmaz\u00e1st.</p> <ul> <li> <p>Az alkalmaz\u00e1s fel\u00fclet\u00e9t osszuk k\u00e9t r\u00e9szre (erre <code>SplitContainer</code>-t haszn\u00e1ljunk, a neve maradjon az alap\u00e9rtelmezett splitContainer1).</p> </li> <li> <p>Miut\u00e1n a felhaszn\u00e1l\u00f3 az Open men\u00fcponttal bek\u00e9rt egy mappa \u00fatvonalat (pl. <code>c:\\windows</code>) a kor\u00e1bban elk\u00e9sz\u00edtett <code>InputDialog</code> felhaszn\u00e1l\u00e1s\u00e1val, a bal oldalon egy <code>ListView</code> vez\u00e9rl\u0151 seg\u00edts\u00e9g\u00e9vel list\u00e1zzuk ki az adott mapp\u00e1ban tal\u00e1lhat\u00f3 f\u00e1jlok neveit \u00e9s m\u00e9reteit k\u00e9t k\u00fcl\u00f6n oszlopban (Name \u00e9s Size fejl\u00e9c\u0171 oszlopok). A m\u00e9ret oszlop a f\u00e1jl m\u00e9ret\u00e9t jelen\u00edtse meg byte-ban, csak a sz\u00e1mot, mindenf\u00e9le m\u00e9rt\u00e9kegys\u00e9g hozz\u00e1f\u0171z\u00e9se n\u00e9lk\u00fcl.</p> </li> <li> <p>A form jobb oldal\u00e1t egy fix magass\u00e1g\u00fa \u2013 vagyis az ablak \u00e1tm\u00e9retez\u00e9sekor a magass\u00e1ga ne v\u00e1ltozzon - <code>Panel</code> (a neve legyen: detailsPanel) \u00e9s egy alatta (\u00e9s nem rajta!) elhelyezked\u0151 t\u00f6bbsoros sz\u00f6vegdoboz (neve tContent) t\u00f6ltse ki. A sz\u00f6vegdoboz akkor is t\u00f6ltse ki a teret, ha az ablakot a felhaszn\u00e1l\u00f3 nagyobbra/kisebbre m\u00e9retezi \u00e1t!</p> </li> <li> <p>A panelen mindig az aktu\u00e1lisan kiv\u00e1lasztott f\u00e1jl nev\u00e9t \u00e9s l\u00e9trehoz\u00e1s\u00e1nak d\u00e1tum\u00e1t mutassuk egy lName illetve lCreated nev\u0171 <code>Label</code> t\u00edpus\u00fa vez\u00e9rl\u0151 seg\u00edts\u00e9g\u00e9vel.</p> <p>L\u00e9nyeges, hogy a kiv\u00e1laszt\u00e1s nem dupla eg\u00e9rkattint\u00e1st jelent (egy elemet ki lehet v\u00e1lasztani pl. szimpla eg\u00e9r kattint\u00e1ssal, billenty\u0171vel stb.). Az <code>lName</code> sz\u00f6vege pontosan a f\u00e1jl neve legyen, mindenf\u00e9le prefix (pl. \"Name:\u201d \u00e9s hasonl\u00f3k) n\u00e9lk\u00fcl. Ugyanez igaz az <code>lCreated</code> vonatkoz\u00e1s\u00e1ban. A \"prefixek\u201d-hez k\u00fcl\u00f6n <code>Label</code> vez\u00e9rl\u0151t haszn\u00e1lj a name \u00e9s a created vonatkoz\u00e1s\u00e1ban is.</p> </li> <li> <p>A <code>ListView</code> <code>FullRowSelect</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsd <code>true</code> ra (en\u00e9lk\u00fcl a tesztek nem futnak le j\u00f3l majd).</p> </li> <li> <p>Amennyiben a felhaszn\u00e1l\u00f3 a f\u00e1jllist\u00e1b\u00f3l egy f\u00e1jlon dupl\u00e1n kattint, a t\u00f6bbsoros sz\u00f6vegdobozban jelen\u00edts\u00fck meg a f\u00e1jl tartalm\u00e1t sz\u00f6veges form\u00e1tumban. L\u00e9nyeges, hogy csak a dupla kattint\u00e1s sz\u00e1m\u00edt ebben tekintetben, teh\u00e1t ha a felhaszn\u00e1l\u00f3 sim\u00e1n (duplakattint\u00e1s n\u00e9lk\u00fcl) m\u00e1s f\u00e1jlt v\u00e1laszt ki, a sz\u00f6vegdoboz tartalma nem v\u00e1ltozhat.</p> </li> </ul>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#megoldas_2","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1s\u00e1hoz a kapcsol\u00f3d\u00f3 gyakorlatban m\u00e1r alkalmazott, illetve az itt kor\u00e1bban megismert elemeket kell alkalmazni \u00e9s kombin\u00e1lni. A megold\u00e1s l\u00e9p\u00e9seit csak nagy vonalakban adjuk meg, n\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 seg\u00edts\u00e9ggel:</p> <ul> <li>Az ablak ter\u00fclet\u00e9nek kett\u00e9oszt\u00e1s\u00e1ra haszn\u00e1ljuk ism\u00e9t a <code>SplitContainer</code> vez\u00e9rl\u0151t (a neve maradjon az alap\u00e9rtelmezett <code>splitContainer1</code>)</li> <li>A <code>ListView</code> oszlopainak felv\u00e9telekor csak a <code>Text</code> tulajdons\u00e1got v\u00e1ltoztasd, a <code>Name</code>-et ne. Ugyanitt, az oszlopok sz\u00e9less\u00e9g\u00e9t is n\u00f6veld meg.</li> <li>Ha a <code>ListView</code> nem mutatja a 2 oszlopot, csak a f\u00e1jlok neveit, a <code>View</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsd \u00e1t <code>Details</code>-re.</li> <li>A <code>ListView</code> <code>FullRowSelect</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsd <code>true</code> ra (en\u00e9lk\u00fcl a tesztek nem futnak le j\u00f3l majd).</li> <li>Az aktu\u00e1lisan kiv\u00e1lasztott elem adatainak megjelen\u00edt\u00e9s\u00e9t a <code>ListView</code> <code>SelectedIndexChanged</code> esem\u00e9ny\u00e9vel c\u00e9lszer\u0171 megoldani.</li> <li>A <code>detailsPanel</code> <code>Dock</code> tulajdons\u00e1g\u00e1t megfelel\u0151en be kell \u00e1ll\u00edtani.</li> <li> <p>Ahhoz, hogy a <code>TextBox</code> vez\u00e9rl\u0151 kit\u00f6lthesse a rendelkez\u00e9s\u00e9re \u00e1ll\u00f3 teret, nem el\u00e9g a <code>Dock</code> tulajdons\u00e1g\u00e1t <code>Fill</code>-re \u00e1ll\u00edtani, sz\u00fcks\u00e9ges a <code>Multiline</code> tulajdons\u00e1g <code>true</code>-ra \u00e1ll\u00edt\u00e1sa is.</p> <p>Tipp</p> <p>Ha az ablak jobb oldal\u00e1n a <code>Textbox</code> teteje beker\u00fcl a panel m\u00f6g\u00e9, annak val\u00f3sz\u00edn\u0171leg az oka az, hogy a <code>SplitContainer</code> kettes panelj\u00e9hez a <code>detailsPanel</code> \u00e9s a <code>tContent</code> sz\u00f6vegdoboz nem j\u00f3 sorrendben ker\u00fcl hozz\u00e1ad\u00e1sra (a j\u00f3 sorrend a <code>tContent</code>, ut\u00e1na <code>detailsPanel</code>). A vez\u00e9rl\u0151k hozz\u00e1ad\u00e1si sorrendje a Document Outline ablakban ellen\u0151rizhet\u0151, \u00e9s a sorrend itt v\u00e1ltoztathat\u00f3 meg drag&amp;droppal.</p> </li> <li> <p>Egy f\u00e1jl tartalm\u00e1t egyszer\u0171en bet\u00f6lthetj\u00fck egy stringbe a <code>File</code> statikus oszt\u00e1ly<code>ReadAllText(filename)</code> f\u00fcggv\u00e9ny\u00e9vel.</p> </li> <li>A <code>FileInfo</code> oszt\u00e1ly <code>Name</code> tulajdons\u00e1ga megadja egy f\u00e1jl teljes nev\u00e9t, a <code>CreationTime</code> pedig l\u00e9trehoz\u00e1s\u00e1nak idej\u00e9t (melyet a <code>ToString()</code> m\u0171velettel alak\u00edtsunk string\u00e9).</li> <li> <p>Ne felejts\u00fck el, hogy a felhaszn\u00e1l\u00f3 t\u00f6bbsz\u00f6r egym\u00e1s ut\u00e1n is v\u00e1laszthat mapp\u00e1t az Open men\u00fcponttal. Az \u00faj mappa tartalm\u00e1nak bet\u00f6lt\u00e9se el\u0151tt az aktu\u00e1lis f\u00e1jl list\u00e1t mindig \u00fcr\u00edteni kell.</p> <p>Tipp</p> <p>A <code>ListView</code> elemeinek elt\u00e1vol\u00edt\u00e1s\u00e1ra ne a <code>ListView</code> oszt\u00e1ly <code>Clear</code> m\u0171velet\u00e9t, hanem a <code>ListView</code> oszt\u00e1ly <code>Items</code> tulajdons\u00e1g\u00e1nak <code>Clear</code> m\u0171velet\u00e9t haszn\u00e1ld!</p> </li> </ul> <p>Az elk\u00e9sz\u00fclt alkalmaz\u00e1s k\u00e9pe:</p> <p></p> <p>T\u00fal r\u00e9gi d\u00e1tum</p> <p>Ha a l\u00e9trehoz\u00e1si d\u00e1tumnak nagyon r\u00e9gi (1601-es \u00e9vhez tartoz\u00f3) d\u00e1tumot kapsz, akkor lehet, hogy a <code>FileInfo</code> objektumot nem a f\u00e1jl teljes \u00fatvonal\u00e1val, hanem csak a f\u00e1jl nev\u00e9vel hozod l\u00e9tre, \u00e9s ez okozza.</p> <p>BEADAND\u00d3</p> <p> Miel\u0151bb tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened, ennek m\u00f3dj\u00e1t az al\u00e1bbi.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat3.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>MainForm.cs</code> megnyitva,</li> <li>a VS View / Full Screen men\u00fcj\u00e9vel kapcsolj ideiglenesen Full Screen n\u00e9zetre, hogy a zavar\u00f3 panelek ne vegyenek el semmi helyet,</li> <li>g\u00f6rgess le a forr\u00e1sf\u00e1jlod legalj\u00e1ra, haszn\u00e1lj kb. norm\u00e1l zoom \u00e9rt\u00e9ket, most fontos, hogy ami a k\u00e9perny\u0151d\u00f6n lesz, legyen j\u00f3l olvashat\u00f3 (az nem baj, ha nem f\u00e9r ki minden, nem is fog), az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat-4-rajzolas","title":"Feladat 4 \u2013 Rajzol\u00e1s","text":""},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#feladat_3","title":"Feladat","text":"<p>Amennyiben a felhaszn\u00e1l\u00f3 megnyitott egy f\u00e1jlt, akkor a megnyitott f\u00e1jl tartalm\u00e1t adott id\u0151k\u00f6z\u00f6nk\u00e9nt friss\u00edts\u00fck. A friss\u00edt\u00e9si id\u0151k\u00f6z 6 m\u00e1sodperc legyen. A friss\u00edt\u00e9s jelz\u00e9s\u00e9re a kijel\u00f6lt f\u00e1jl adatait (n\u00e9v \u00e9s l\u00e9trehoz\u00e1s d\u00e1tuma) tartalmaz\u00f3 panel fels\u0151 fel\u00e9re (0,0 koordin\u00e1t\u00e1b\u00f3l kezdve) rajzoljunk ki barna (Color.Brown) sz\u00ednnel egy 5 pixel magas, kezdetben 125 pixel sz\u00e9les kit\u00f6lt\u00f6tt t\u00e9glalapot. A t\u00e9glalap hossza a k\u00f6vetkez\u0151 friss\u00edt\u00e9sig h\u00e1tralev\u0151 id\u0151vel legyen ar\u00e1nyos: ennek megfelel\u0151en minden tizedm\u00e1sodpercben ar\u00e1nyosan cs\u00f6kkents\u00fck a hossz\u00e1t. \u00cdgy minden friss\u00edt\u00e9si id\u0151k\u00f6z v\u00e9g\u00e9n a t\u00e9glalap hossza nulla lesz. A friss\u00edt\u00e9si id\u0151k\u00f6z v\u00e9g\u00e9n (amikor a t\u00e9glalap hossza el\u00e9rte a 0-t) a kor\u00e1bban kiv\u00e1lasztott f\u00e1jl tartalm\u00e1t t\u00f6lts\u00fck be \u00fajb\u00f3l, \u00e9s kezdj\u00fck elej\u00e9r\u0151l a folyamatot. Az id\u0151z\u00edt\u00e9sre <code>Timer</code> komponenst haszn\u00e1ljunk!</p> <p> A feladat csak akkor elfogadhat\u00f3, ha a fenti, kiemelt sz\u00f6vegst\u00edlussal jel\u00f6lt param\u00e9terekkel dolgozol. Arra figyelj, hogy a kirajzolt t\u00e9glalap ne l\u00f3gjon bele vez\u00e9rl\u0151kbe \u00e9s ne l\u00f3gjon t\u00fal az \u0171rlapon (ha sz\u00fcks\u00e9ges, mozgasd kicsit lentebb a vez\u00e9rl\u0151ket, illetve vedd kicsit sz\u00e9lesebbre az \u0171rlap alap\u00e9rtelmezett m\u00e9ret\u00e9t).</p>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#megoldas_3","title":"Megold\u00e1s","text":"<p>A feladatot pr\u00f3b\u00e1ld meg \u00f6n\u00e1ll\u00f3an megoldani, majd a lenti le\u00edr\u00e1s alapj\u00e1n ellen\u0151rizd a megold\u00e1sod!</p> Megold\u00e1s <p>A megold\u00e1s alapj\u00e1t egy <code>Timer</code> komponens fogja adni. Ez egy olyan vez\u00e9rl\u0151, mely nem rendelkezik vizu\u00e1lis fel\u00fclettel, csup\u00e1n n\u00e9h\u00e1ny testre szabhat\u00f3 tulajdons\u00e1ggal \u00e9s egy <code>Tick</code> esem\u00e9nnyel, mely az <code>Interval</code> tulajdons\u00e1gban (milliszekundumban) megadott id\u0151k\u00f6z\u00f6nk\u00e9nt automatikusan megh\u00edv\u00f3dik. Els\u0151 l\u00e9p\u00e9sk\u00e9nt ezt az \u00fctemez\u00e9st \u00e1ll\u00edtjuk be.</p> <ol> <li> <p>H\u00fazzunk egy <code>Timer</code> komponenst (Toolbox / Componensts) <code>MainForm</code>-ra! Figyelj\u00fck meg, hogy a komponens csup\u00e1n a <code>Form</code> alatti sz\u00fcrke ter\u00fcleten jelenik meg. Itt tudjuk kijel\u00f6lni a k\u00e9s\u0151bbi l\u00e9p\u00e9sekhez.</p> <p></p> </li> <li> <p>Ellen\u0151rizz\u00fck, hogy az <code>Interval</code> tulajdons\u00e1ga 100-ra van \u00e1ll\u00edtva. Ez 100 milliszekundumonk\u00e9nt, vagyis minden tizedm\u00e1sodpercben kiv\u00e1ltja a <code>Tick</code> esem\u00e9nyt.</p> </li> <li> <p>\u00c1ll\u00edtsuk a <code>Name</code> tulajdons\u00e1got <code>reloadTimer</code>-re!</p> </li> <li> <p>Vezess\u00fcnk be n\u00e9h\u00e1ny \u00faj tagv\u00e1ltoz\u00f3t a <code>MainForm</code> oszt\u00e1lyban:</p> <ul> <li><code>loadedFile</code> az utolj\u00e1ra bet\u00f6lt\u00f6tt f\u00e1jl adatait tartalmazza,</li> <li><code>counter</code> az \u00fajrat\u00f6lt\u00e9sig sz\u00fcks\u00e9ges tizedm\u00e1sodpercek sz\u00e1m\u00e1t tartalmazza, a k\u00e9s\u0151bbiekben minden tizedm\u00e1sodpercben eggyel cs\u00f6kkentj\u00fck az \u00e9rt\u00e9k\u00e9t egy id\u0151z\u00edt\u0151 seg\u00edts\u00e9g\u00e9vel, m\u00edg el nem \u00e9ri a null\u00e1t,</li> <li><code>counterInitialValue</code> a <code>counter</code> sz\u00e1ml\u00e1l\u00f3 kezd\u0151\u00e9rt\u00e9ke (ahonnan visszasz\u00e1mol).</li> </ul> <p>A tagv\u00e1ltoz\u00f3kat az oszt\u00e1ly elej\u00e9re szoktuk besz\u00farni:</p> <pre><code>public partial class MainForm: Form\n{\nprivate FileInfo loadedFile = null;\nint counter;\nreadonly int counterInitialValue;\n// ..\n}\n</code></pre> </li> <li> <p>A konstruktorban \u00e1ll\u00edtsuk be a <code>counterInitialValue</code> \u00e9rt\u00e9k\u00e9t (k\u00e9s\u0151bb ez nem is v\u00e1ltozik). </p> <p>A <code>counterInitialValue</code> \u00e9rt\u00e9k\u00e9t a fenti k\u00f3dban neked kell meghat\u00e1rozni: sz\u00e1m\u00edtsd ki a friss\u00edt\u00e9si id\u0151k\u00f6z \u00e9s az <code>timer</code> <code>Interval</code> alapj\u00e1n!</p> <pre><code>public MainForm()\n{\nInitializeComponent();\ncounterInitialValue = ; // TODO a friss\u00edt\u00e9si id\u0151k\u00f6znek megfelel\u0151 \u00e9rt\u00e9k\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a duplakattint\u00e1st kezel\u0151 esem\u00e9nykezel\u0151nket, hogy ne csak bet\u00f6ltse a f\u00e1jlt, hanem:</p> <ol> <li>Ind\u00edtsa el a <code>Timer</code>-t a <code>reloadTimer.Start()</code> h\u00edv\u00e1ssal,</li> <li>\u00e1ll\u00edtsa be <code>counter</code> \u00e9rt\u00e9k\u00e9t <code>counterInitialValue</code>-ra,</li> <li>\u00e1ll\u00edtsa be <code>loadedFile</code> \u00e9rt\u00e9k\u00e9t a mindenkori kiv\u00e1lasztott f\u00e1jl le\u00edr\u00f3j\u00e1ra.</li> </ol> <p>Megjegyz\u00e9s</p> <p>A megold\u00e1s minden egyes \u00faj f\u00e1jl megnyit\u00e1sakor megh\u00edvja a <code>Timer</code> oszt\u00e1ly <code>Start</code> f\u00fcggv\u00e9ny\u00e9t. Ez nem jelent gondot, mivel ilyenkor a m\u00e1r elind\u00edtott <code>Timer</code> egyszer\u0171en fut tov\u00e1bb \u00e9s figyelmen k\u00edv\u00fcl hagyja a tov\u00e1bbi <code>Start</code> h\u00edv\u00e1sokat.</p> </li> <li> <p>Iratkozzunk fel a <code>Timer</code> komponens <code>Tick</code> esem\u00e9ny\u00e9re. Ehhez a <code>reloadTimer</code> kijel\u00f6l\u00e9se ut\u00e1n a Property Editor-ban az Events f\u00fcl\u00f6n kattintsunk dupl\u00e1n a <code>Tick</code> esem\u00e9nyre, ezzel l\u00e9trej\u00f6n a kapcsol\u00f3d\u00f3 esem\u00e9nykezel\u0151 (<code>reloadTimer_Tick</code>). T\u00f6lts\u00fck ki a k\u00f3dj\u00e1t:</p> <pre><code>private void reloadTimer_Tick(object sender, EventArgs e)\n{\ncounter--;\n\n// Fontos! Ez v\u00e1ltja ki a Paint esem\u00e9nyt\n// \u00e9s ezzel a t\u00e9glalap \u00fajrarajzol\u00e1s\u00e1t\ndetailsPanel.Invalidate();\n\nif (counter &lt;= 0)\n{\ncounter = counterInitialValue;\ntContent.Text = File.ReadAllText(loadedFile.FullName);\n}\n}\n</code></pre> <p>A fenti megold\u00e1s minden egyes <code>Tick</code> esem\u00e9nyre cs\u00f6kkenti a <code>counter</code> \u00e9rt\u00e9k\u00e9t, eg\u00e9szen addig, am\u00edg el nem \u00e9ri a 0 \u00e9rt\u00e9ket, ilyenkor ugyanis vissza\u00e1ll\u00edtjuk a kezd\u0151\u00e9rt\u00e9kre, \u00e9s \u00fajra bet\u00f6ltj\u00fck a f\u00e1jlt.</p> <p>A megold\u00e1s j\u00f3l szeml\u00e9lteti a Windows Forms alkalmaz\u00e1sokban a grafikus megjelen\u00edt\u00e9s tipikus mechanizmus\u00e1t:</p> <ul> <li>T\u00e9nyleges rajzol\u00e1st az \u00e1llapotot megv\u00e1ltoztat\u00f3 m\u0171veletben nem v\u00e9gz\u00fcnk, hanem a form/vez\u00e9rl\u0151 (eset\u00fcnkben panel) <code>Invalidate</code> m\u0171velet\u00e9ben v\u00e1ltjuk ki a <code>Paint</code> esem\u00e9nyt.</li> <li>A konkr\u00e9t t\u00e9glalap (aktu\u00e1lis \u00e1llapotnak megfelel\u0151) megjelen\u00edt\u00e9s\u00e9\u00e9rt/kirajzol\u00e1s\u00e1\u00e9rt az \u0171rlap/vez\u00e9rl\u0151 (eset\u00fcnkben a panel) <code>Paint</code> esem\u00e9nye felel\u0151s.</li> </ul> </li> <li> <p>Iratkozzunk fel a <code>detailsPanel</code> komponens <code>Paint</code> esem\u00e9ny\u00e9re. Ehhez a panel kijel\u00f6l\u00e9se ut\u00e1n a Property Editor-ban az Events f\u00fcl\u00f6n kattintsunk dupl\u00e1n a <code>Paint</code> esem\u00e9nyre, ezzel l\u00e9trej\u00f6n a kapcsol\u00f3d\u00f3 esem\u00e9nykezel\u0151 (<code>detailsPanel_Paint</code>). T\u00f6lts\u00fck ki a k\u00f3dj\u00e1t:</p> <pre><code>private void detailsPanel_Paint(object sender, PaintEventArgs e)\n{\nif (loadedFile!=null)\n{\n// A t\u00e9glalap sz\u00e9less\u00e9ge a t\u00e9glalap kezd\u0151hossz\u00fas\u00e1g\u00e1b\u00f3l (adott a feladatki\u00edr\u00e1sban) sz\u00e1m\u00edthat\u00f3,\n// szorozva a sz\u00e1ml\u00e1l\u00f3 aktu\u00e1lis \u00e9s max \u00e9rt\u00e9k\u00e9nek ar\u00e1ny\u00e1val\ne.Graphics.FillRectangle(/*TODO param\u00e9terek*/); }\n}\n</code></pre> <p>A <code>FillRectangle</code> pontos param\u00e9terez\u00e9st a fenti p\u00e9ldak\u00f3d megjegyz\u00e9sben szerepl\u0151 seg\u00edts\u00e9g alapj\u00e1n tudod meghat\u00e1rozni.</p> <p>Lebeg\u0151pontos sz\u00e1m\u00edt\u00e1sok</p> <p>Tipikus probl\u00e9ma szokott lenni, ha eg\u00e9sz \u00e9rt\u00e9k\u0171 oszt\u00e1st v\u00e9gzel a sz\u00e9less\u00e9g sz\u00e1m\u00edt\u00e1sakor (ekkor az eredm\u00e9ny j\u00f3 es\u00e9llyel nulla lesz): az oszt\u00f3t vagy osztand\u00f3t castold el\u0151bb lebeg\u0151pontos sz\u00e1mra \u00e9s \u00edgy dolgozz.</p> </li> <li> <p>Tesztelj\u00fck a megold\u00e1sunkat (az al\u00e1bbi \u00e1br\u00e1n a sz\u00ednes t\u00e9glalap lehet elt\u00e9r a feladatban elv\u00e1rtakt\u00f3l):</p> <p></p> </li> </ol>"},{"location":"hazi/opc-hf-1-felhasznaloi-felulet-kialakitasa/#kiegeszito-gyakorlo-feladat","title":"Kieg\u00e9sz\u00edt\u0151 gyakorl\u00f3 feladat","text":"<p>Eg\u00e9sz\u00edts\u00fck ki az alkalmaz\u00e1sunkat \u00fagy, hogy a f\u00e1jlok k\u00f6zt \"Total Commander\"-szer\u0171en tudjunk mozogni, vagyis:</p> <ul> <li>A list\u00e1ban jelenjenek meg a mapp\u00e1k nevei is. Ezekre dupl\u00e1n kattintva a teljes f\u00e1jl lista cser\u00e9l\u0151dj\u00f6n le az aktu\u00e1lis mappa tartalm\u00e1ra. A mappanevek eredeti form\u00e1jukban jelenjenek meg (pl. ne legyenek k\u00f6rbev\u00e9ve sz\u00f6gletes vagy egy\u00e9b z\u00e1r\u00f3jelekkel).</li> <li>A lista elej\u00e9re ker\u00fclj\u00f6n be egy speci\u00e1lis \"..\" nev\u0171 elem, mely mindig az aktu\u00e1lis mappa sz\u00fcl\u0151mapp\u00e1j\u00e1nak tartalm\u00e1t list\u00e1zza ki.</li> <li>Amikor gy\u00f6k\u00e9relemben vagyunk (pl.: \"C:\\\"), ne jelenjen meg a \"..\" elem.</li> </ul>"},{"location":"hazi/windows-forms-extra-info/","title":"Windows Forms fejleszt\u00e9shez kapcsol\u00f3d\u00f3 extra inform\u00e1ci\u00f3k","text":""},{"location":"hazi/windows-forms-extra-info/#rendszerkovetelmenyek","title":"Rendszerk\u00f6vetelm\u00e9nyek","text":"<p>A h\u00e1zi feladat elk\u00e9sz\u00edt\u00e9se Windows 10 vagy 11 oper\u00e1ci\u00f3s rendszeren, Visual Studio 2022-vel t\u00f6rt\u00e9nik. Windows-ra mindenk\u00e9ppen sz\u00fcks\u00e9g van a fejleszt\u00e9hez \u00e9s az alkalmaz\u00e1s fut\u00e1s\u00e1hoz is. L\u00e9nyeges, hogy a Visual Studio alatt telep\u00edtve legyen a \".NET Desktop development\u201d workload (ez a Visual Studio installerben ellen\u0151rizhet\u0151/adhat\u00f3 meg). Ha valakinek nem \u00e1ll rendelkez\u00e9s\u00e9re ilyen k\u00f6rnyezet, BME Cloud hozz\u00e1f\u00e9r\u00e9s a t\u00e1rgyfelel\u0151sn\u00e9l ig\u00e9nyelhet\u0151.</p>"},{"location":"hazi/windows-forms-extra-info/#visual-studio-designer-hiba-ha-nem-nyilik-meg-az-urlap-szerkesztesre","title":"Visual Studio designer hiba (ha nem ny\u00edlik meg az \u0171rlap szerkeszt\u00e9sre)","text":"<p>A Visual Studio 2022 a Git-b\u0151l frissen kikl\u00f3nozott forr\u00e1s eset\u00e9n (amikor m\u00e9g nem l\u00e9tezik egy .csproj.user kiterjeszt\u00e9s\u0171 f\u00e1jl) az \u0171rlapokat  - val\u00f3sz\u00edn\u0171s\u00edthet\u0151en egy bug miatt \u2013 id\u0151nk\u00e9nt nem hajland\u00f3 megnyitni szerkeszt\u0151 m\u00f3dban (szerencs\u00e9re ez nagyon ritka). A solution megnyit\u00e1sa ut\u00e1n ez esetben ezt l\u00e1tjuk:</p> <p></p> <p>A probl\u00e9ma az, hogy a <code>Form1.cs</code> el\u0151tti ikon (pirossal bekeretezve) nem egy \u0171rlap, hanem egy z\u00f6ld C# ikon. Ez esetben hi\u00e1ba kattintunk dupl\u00e1n a f\u00e1jlon, nem az \u0171rlap szerkeszt\u0151 ny\u00edlik meg, hanem csak a forr\u00e1sf\u00e1jl. A megold\u00e1s ez esetben a k\u00f6vetkez\u0151: a Build men\u00fcben v\u00e1lasszuk ki a \u201eRebuild solution\u201d men\u00fct, majd a Build men\u00fcben a \u201eClean solution\u201d men\u00fct, \u00e9s v\u00e1rjunk egy kicsit. Ekkor p\u00e1r m\u00e1sodperc m\u00falva a Solution Explorerben az \u0171rlapunk ikonja megv\u00e1ltozik:</p> <p></p> <p>Most m\u00e1r meg tudjuk nyitni az \u0171rlapot szerkeszt\u00e9sre, ha dupl\u00e1n kattintunk a Solution Explorerben a fenti csom\u00f3ponton.</p>"}]}